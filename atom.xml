<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>勇往直前</title>
  
  <subtitle>心有远方</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wanglichao.top/"/>
  <updated>2018-11-13T18:45:53.312Z</updated>
  <id>http://www.wanglichao.top/</id>
  
  <author>
    <name>王立超</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React-ajax</title>
    <link href="http://www.wanglichao.top/2018/11/14/React-ajax/"/>
    <id>http://www.wanglichao.top/2018/11/14/React-ajax/</id>
    <published>2018-11-14T02:45:53.000Z</published>
    <updated>2018-11-13T18:45:53.312Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>React学习笔记之Props</title>
    <link href="http://www.wanglichao.top/2018/11/13/React-Props/"/>
    <id>http://www.wanglichao.top/2018/11/13/React-Props/</id>
    <published>2018-11-12T21:28:01.000Z</published>
    <updated>2018-11-12T18:44:43.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-Props"><a href="#React-Props" class="headerlink" title="React Props"></a>React Props</h2><blockquote><p>state 和 props 主要的区别在于props是不可变的,而state可以根据与用户交互来改变;<br>这就是为什么有些容器组件需要定义state来更新和修改数据;<br>而子组件只能通过props来传递数据;<br>演示如何在组件中使用props:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">function Message(props) &#123;<br>            return &lt;h1&gt;Hello, &#123;props.name&#125;!&lt;/h1&gt;<br>        &#125;<br>        const element = &lt;Message name=&quot;React&quot;/&gt;;<br>        ReactDOM.render(<br>            element,<br>            document.getElementById(&quot;box&quot;)<br>        )<br></code></pre></td></tr></table></figure></p><p>实例中name属性通过props.name来获取;</p></blockquote><h3 id="默认Props"><a href="#默认Props" class="headerlink" title="默认Props"></a>默认Props</h3><blockquote><p>你可以通过组件类的defaultProps属性为Props设置默认值:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class Message extends React.Component &#123;<br>            constructor() &#123;<br>                super()<br>            &#125;<br>            render() &#123;<br>                return (<br>                    &lt;h1&gt;Hello, &#123;this.props.name&#125;!&lt;/h1&gt;<br>                )<br>            &#125;<br>        &#125;<br>        Message.defaultProps = &#123;<br>            name: &apos;React&apos;<br>        &#125;;<br>        const element = &lt;Message /&gt;;<br>        ReactDOM.render(<br>            element,<br>            document.getElementById(&apos;box&apos;)<br>        )<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="State-和-Props"><a href="#State-和-Props" class="headerlink" title="State 和 Props"></a>State 和 Props</h3><p>以下实例演示了如何在应用中组合使用state和props, 我们可以在父组件中设置state,并通过在子组件上使用props将其传递到子组件上,在render函数中,我们设置name和site来获取父组件传递过来的数据;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class WebSite extends React.Component &#123;<br>            constructor () &#123;<br>                super();<br>                this.state = &#123;<br>                    name: &quot;勇往直前&quot;,<br>                    site: &quot;http://www.wanglichao.top&quot;<br>                &#125;<br>            &#125;<br>            render() &#123;<br>                return (<br>                    &lt;div&gt;<br>                        &lt;Name name=&#123;this.state.name&#125;/&gt;<br>                        &lt;Link site=&#123;this.state.site&#125;/&gt;<br>                    &lt;/div&gt;<br>                )<br>            &#125;<br>        &#125;<br><br>        class Name extends React.Component &#123;<br>            render() &#123;<br>                return (<br>                    &lt;h1&gt;&#123;this.props.name&#125;&lt;/h1&gt;<br>                )<br>            &#125;<br>        &#125;<br><br>        class Link extends React.Component &#123;<br>            render() &#123;<br>                return (<br>                    &lt;a href=&#123;this.props.site&#125;&gt;<br>                        &#123;this.props.site&#125;<br>                    &lt;/a&gt;<br>                )<br>            &#125;<br>        &#125;<br><br>        ReactDOM.render(<br>            &lt;WebSite /&gt;,<br>            document.getElementById(&quot;box&quot;)<br>        )<br></code></pre></td></tr></table></figure></p><h3 id="Props-验证"><a href="#Props-验证" class="headerlink" title="Props 验证"></a>Props 验证</h3><blockquote><p><code>React.PropTypes 在 React v15.5 版本后已经移动到prop-types库.</code><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;script src=&quot;https://cdn.bootcss.com/prop-types/15.6.1/prop-types.js&quot;&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><p>Props验证使用propTypes,它可以保证我们的应用组件被正确的使用,React.PropTypes 提供很多验证器(validator)来验证传入数据是否有效;<br>当向props传入无效数据时,JavaScript控制台会抛出警告.<br>以下实例创建一个MyTitle组件,属性title是必须的且是字符串,非字符串类型会自动转换为字符串.<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs undefined">// React 16.4 实例<br>let title = &quot;勇往直前&quot;;<br>        // title = 123;<br>        // Failed prop type: Invalid prop `title` of type `number` supplied to `MyTitle`, expected `string`.<br>    in MyTitle<br>        class MyTitle extends React.Component &#123;<br>            render() &#123;<br>                return (<br>                    &lt;h1&gt;Hello, &#123;this.props.title&#125;&lt;/h1&gt;<br>                )<br>            &#125;<br>        &#125;<br><br>        MyTitle.propTypes = &#123;<br>            title: PropTypes.string<br>        &#125;;<br><br>        ReactDOM.render(<br>            &lt;MyTitle title=&#123;title&#125; /&gt;,<br>            document.getElementById(&quot;box&quot;)<br>        )<br></code></pre></td></tr></table></figure></p></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs undefined">// React 15.4 实例<br>let title = &quot;勇往直前&quot;;<br>    // title = 123;<br>    const MyTitle = React.createClass(&#123;<br>        propTypes: &#123;<br>            title: React.PropTypes.string.isRequired<br>        &#125;,<br>        render: function() &#123;<br>            return &lt;h1&gt;&#123;this.props.title&#125;&lt;/h1&gt;<br>        &#125;<br>    &#125;);<br>    ReactDOM.render(<br>        &lt;MyTitle title=&#123;title&#125; /&gt;,<br>        document.getElementById(&apos;example&apos;)<br>    );<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-Props&quot;&gt;&lt;a href=&quot;#React-Props&quot; class=&quot;headerlink&quot; title=&quot;React Props&quot;&gt;&lt;/a&gt;React Props&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;state 和 props 主要的区别在于
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之State</title>
    <link href="http://www.wanglichao.top/2018/11/13/React-State/"/>
    <id>http://www.wanglichao.top/2018/11/13/React-State/</id>
    <published>2018-11-12T21:28:01.000Z</published>
    <updated>2018-11-12T18:44:38.821Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-State"><a href="#React-State" class="headerlink" title="React State"></a>React State</h2><blockquote><p>React 把组件看成是一个状态机(StateMachines).通过与用户的交互,实现不同的状态,然后渲染UI,让用户界面和数据保持一致;<br>React里,只需更新组件的state,然后根据新的state重新渲染用户界面,而不需要去操作DOM;</p></blockquote><h3 id="将生命周期方法添加到类中"><a href="#将生命周期方法添加到类中" class="headerlink" title="将生命周期方法添加到类中"></a>将生命周期方法添加到类中</h3><blockquote><p>在具有许多组件的应用程序中,在销毁时释放组件所占用的资源非常重要;<br>每当组件第一次加载到DOM中的时候,在React中被称为挂载;<br>当这个组件生成的DOM被移除的时候,在React中被称为卸载;</p></blockquote><h3 id="数据自顶向下流动"><a href="#数据自顶向下流动" class="headerlink" title="数据自顶向下流动"></a>数据自顶向下流动</h3><blockquote><p>父组件或子组件都不能知道某个组件是有状态还是无状态，并且它们不应该关心某组件是被定义为一个函数还是一个类。</p><p>这就是为什么状态通常被称为局部或封装。 除了拥有并设置它的组件外，其它组件不可访问。</p><p>通常被称为自顶向下或单向数据流。 任何状态始终由某些特定组件所有，并且从该状态导出的任何数据或 UI 只能影响树中下方的组件;</p><p>在 React 应用程序中，组件是有状态还是无状态被认为是可能随时间而变化的组件的实现细节。</p><p>我们可以在有状态组件中使用无状态组件，也可以在无状态组件中使用有状态组件。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-State&quot;&gt;&lt;a href=&quot;#React-State&quot; class=&quot;headerlink&quot; title=&quot;React State&quot;&gt;&lt;/a&gt;React State&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;React 把组件看成是一个状态机(Sta
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之JSX</title>
    <link href="http://www.wanglichao.top/2018/11/13/React-JSX/"/>
    <id>http://www.wanglichao.top/2018/11/13/React-JSX/</id>
    <published>2018-11-12T21:28:01.000Z</published>
    <updated>2018-11-12T18:44:41.021Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-JSX"><a href="#React-JSX" class="headerlink" title="React JSX"></a>React JSX</h2><blockquote><p>React 使用JSX来替代常规的JavaScript;<br>JSX是一个看起来像XML的JavaScript语法扩展;<br>我们不需要一定使用JSX,但它有以下优点:</p><ul><li>JSX执行更快,因为它在编译为JavaScript代码后进行了优化;</li><li>它是安全类型的,在编译过程中就能发现错误;</li><li>使用JSX编写模板更加简单快速</li></ul></blockquote><h3 id="使用JSX"><a href="#使用JSX" class="headerlink" title="使用JSX"></a>使用JSX</h3><blockquote><p>JSX使用起来类似HTML;<br>JSX代码可以放在一个独立的文件上,例如:创建一个js文件,然后在HTML中引入该js文件;<br> <figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined"> ReactDOM.render(<br>    &lt;h1&gt;Hello React!&lt;/h1&gt;,<br>    document.getElementById(&quot;box&quot;)<br>);<br></code></pre></td></tr></table></figure></p></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;body&gt;<br>    &lt;!--创建一个JS文件引入--&gt;<br>    &lt;div id=&quot;box&quot;&gt;&lt;/div&gt;<br>    &lt;script type=&quot;text/babel&quot; src=&quot;hello_react.js&quot;&gt;&lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h3 id="JavaScript表达式"><a href="#JavaScript表达式" class="headerlink" title="JavaScript表达式"></a>JavaScript表达式</h3><blockquote><p>我们可以在 JSX 中使用 JavaScript 表达式。表达式写在花括号 {} 中<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">let i = 1;<br>ReactDOM.render(<br>    &lt;h1&gt;&#123;i == 1 ? &apos;True&apos; : &apos;False&apos;&#125;&lt;/h1&gt;,<br>    document.getElementById(&quot;box&quot;)<br>);<br></code></pre></td></tr></table></figure></p><p>在 JSX 中不能使用 if else 语句，但可以使用 conditional (三元运算) 表达式来替代。以下实例中如果变量 i 等于 1 浏览器将输出 true, 如果修改 i 的值，则会输出 false.</p></blockquote><h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><blockquote><p>React 推荐使用内联样式。我们可以使用 camelCase 语法来设置内联样式. React 会在指定元素数字后自动添加 px<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">let myStyle = &#123;<br>    fontSize: 50,<br>    color: &apos;#ff0000&apos;<br>&#125;;<br><br>ReactDOM.render(<br>    &lt;h1 style=&#123;myStyle&#125;&gt;我是菜鸟&lt;/h1&gt;,<br>    document.getElementById(&quot;box&quot;)<br>);<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><blockquote><p>注释需要写在花括号中<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">ReactDOM.render(<br>    &lt;div&gt;<br>    &lt;h1&gt;哈哈哈&lt;/h1&gt;<br>    &#123;/*注释...*/&#125;<br>     &lt;/div&gt;,<br>    document.getElementById(&apos;example&apos;)<br>);<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>JSX 允许在模板中插入数组，数组会自动展开所有成员：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">let arr = [<br>    &lt;h1&gt;我是菜鸟&lt;/h1&gt;,<br>    &lt;h2&gt;正在学习&lt;/h2&gt;,<br>    &lt;h3&gt;不仅技术&lt;/h3&gt;,<br>    &lt;h4&gt;更是梦想&lt;/h4&gt;<br>];<br><br>ReactDOM.render(<br>    &lt;h1&gt;&#123;arr&#125;&lt;/h1&gt;,<br>    document.getElementById(&quot;box&quot;)<br>);<br></code></pre></td></tr></table></figure></p><h3 id="HTML标签-VS-React组件"><a href="#HTML标签-VS-React组件" class="headerlink" title="HTML标签 VS React组件"></a>HTML标签 VS React组件</h3><blockquote><p>React 可以渲染 HTML 标签 (strings) 或 React 组件 (classes)。<br>要渲染 HTML 标签，只需在 JSX 里使用小写字母的标签名。<br>React 的 JSX 使用大、小写的约定来区分本地组件的类和 HTML 标签。<br>要渲染 React 组件，只需创建一个大写字母开头的本地变量。</p><p>注意:<br>由于 JSX 就是 JavaScript，一些标识符像 class 和 for 不建议作为 XML 属性名。作为替代，React DOM 使用 className 和 htmlFor 来做对应的属性。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-JSX&quot;&gt;&lt;a href=&quot;#React-JSX&quot; class=&quot;headerlink&quot; title=&quot;React JSX&quot;&gt;&lt;/a&gt;React JSX&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;React 使用JSX来替代常规的JavaScript;&lt;
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之列表和keys</title>
    <link href="http://www.wanglichao.top/2018/11/13/React-list/"/>
    <id>http://www.wanglichao.top/2018/11/13/React-list/</id>
    <published>2018-11-12T21:28:01.000Z</published>
    <updated>2018-11-13T14:08:42.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-列表-和-keys"><a href="#React-列表-和-keys" class="headerlink" title="React 列表 和 keys"></a>React 列表 和 keys</h2><blockquote><p>我们可以使用javascript的map()方法来创建数字列表:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">const numbers = [1, 2, 3, 4, 5];<br>    const listItem = numbers.map(number =&gt;<br>        &lt;li&gt;&#123;number&#125;&lt;/li&gt;<br>    );<br>    ReactDOM.render(<br>        &lt;ul&gt;<br>            &#123;listItem&#125;<br>        &lt;/ul&gt;,<br>        document.getElementById(&quot;example&quot;)<br>    )<br></code></pre></td></tr></table></figure></p><p>我们可以将以上实例重构成一个组件,组件接收数组参数,每个列表元素分配一个key,不然会出现警告<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs undefined">let numbers = [1, 2, 3, 4, 5];<br><br>   function NumberList(props) &#123;<br>       const numbers = props.numbers;<br>       const listItems = numbers.map(number =&gt;<br>           &lt;li key=&#123;number&#125;&gt;&#123;number&#125;&lt;/li&gt;<br>       );<br>       return (<br>           &lt;ul&gt;<br>               &#123;listItems&#125;<br>           &lt;/ul&gt;<br>       )<br>   &#125;<br><br>   ReactDOM.render(<br>       &lt;NumberList numbers=&#123;numbers&#125;/&gt;,<br>       document.getElementById(&quot;example&quot;)<br>   )<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a>Keys</h3><blockquote><p>keys可以在DOM中的某些元素被增加或删除的时候,帮助React识别哪些元素发生了变化,因此应当给数组中每一个元素赋予一个确定的标识.<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;li key=&#123;number.toString()&#125;&gt;<br></code></pre></td></tr></table></figure></p><p>一个元素的key最好是这个元素在列表中拥有的独一无二的字符串,通常,我们使用来自数据的ID作为元素的key;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">const todoItems = todos.map(todo =&gt;<br>&lt;li key=&#123;todo.id&#125;&gt;<br>&#123;todo.text&#125;<br>&lt;/li&gt;<br>);<br></code></pre></td></tr></table></figure></p><p>当元素没有确定的id时,可以使用它的序列号索引index作为它的key<br> <figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">const todoItems = todos.map((todo, index) =&gt;<br>&lt;li key=&#123;index&#125;&gt;<br>&#123;todo.text&#125;<br>&lt;/li&gt;<br>);<br></code></pre></td></tr></table></figure></p><p>如果列表可以重新排序,我们不建议使用索引来进行排序,因为这回导致渲染变得很慢</p></blockquote><h3 id="用Keys-提取组件"><a href="#用Keys-提取组件" class="headerlink" title="用Keys 提取组件"></a>用Keys 提取组件</h3><blockquote><p>元素的key只有在它和它的兄弟节点对比时才有意义;<br>比方说,如果需要提取一个ListItem组件,你应该把key保存在数组中的<listitem>元素上,而不是放在ListItem组件中的li元素上<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs undefined">function ListItem(props) &#123;<br>  // 这里不需要指定key<br>  return &lt;li&gt;&#123;props.value&#125;&lt;/li&gt;;<br>&#125;<br>function NumberList(props) &#123;<br>  const numbers = props.numbers;<br>  const listItems = numbers.map((number) =&gt;<br>    // 建议将key指定在这里,数组的上下文里;<br>    &lt;ListItem key=&#123;number.toString()&#125;<br>              value=&#123;number&#125; /&gt;<br>  );<br>  return (<br>    &lt;ul&gt;<br>      &#123;listItems&#125;<br>    &lt;/ul&gt;<br>  );<br>&#125;<br>const numbers = [1, 2, 3, 4, 5];<br>ReactDOM.render(<br>  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,<br>  document.getElementById(&apos;example&apos;)<br>);<br></code></pre></td></tr></table></figure></listitem></p><p>在map()方法的内部调用元素时,最好随时记得为每一个元素加上独一无二的key;</p></blockquote><h3 id="元素的key在它与它的兄弟元素之间应该是唯一"><a href="#元素的key在它与它的兄弟元素之间应该是唯一" class="headerlink" title="元素的key在它与它的兄弟元素之间应该是唯一"></a>元素的key在它与它的兄弟元素之间应该是唯一</h3><blockquote><p>数组元素中使用的key在其兄弟之间应该是独一无二的,然而,它们不需要是全局唯一的,当生成两个不同的数组时,可以使用相同的key;<br>key会作为给React的提示,但不会传递给你的组件.如果你的组件中需要使用和key相同的值,请将其作为属性传递;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">const content = posts.map((post) =&gt; <br>&lt;Post key=&#123;post.id&#125;<br>  id=&#123;post.id&#125;<br>  title=&#123;post.title&#125; /&gt;<br>);<br></code></pre></td></tr></table></figure></p><p>上面例子中,Post组件可以读出props.id,但是不能读出props.key;</p></blockquote><h3 id="在JSX中嵌入map"><a href="#在JSX中嵌入map" class="headerlink" title="在JSX中嵌入map()"></a>在JSX中嵌入map()</h3><blockquote><p>JSX允许在大括号中嵌入任何表达式,所以我们可以在map()中这样使用:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">function NumberList(props)&#123;<br> const nubers = props.numbers;<br>reutnr (<br>&lt;ul&gt;<br>&#123;numbers.map(number) =&gt;<br>&lt;ListItem key=&#123;number.toString()&#125; value=&#123;number&#125; /&gt;<br>&lt;/ul&gt;<br>)<br> &#125;<br></code></pre></td></tr></table></figure></p><p>这么做有时可以使你的代码更清晰,但有时这种风格会被滥用,就像在javascript中一样,何时需要为了可读性提取出一个变量,这完全取决于你自己,但请记住,如果一个map() 嵌套了太多层级,那你就可以提取出组件;</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-列表-和-keys&quot;&gt;&lt;a href=&quot;#React-列表-和-keys&quot; class=&quot;headerlink&quot; title=&quot;React 列表 和 keys&quot;&gt;&lt;/a&gt;React 列表 和 keys&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;我们可以使
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之介绍</title>
    <link href="http://www.wanglichao.top/2018/11/13/React-anzhuang/"/>
    <id>http://www.wanglichao.top/2018/11/13/React-anzhuang/</id>
    <published>2018-11-12T21:28:01.000Z</published>
    <updated>2018-11-12T18:44:36.212Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React介绍"><a href="#React介绍" class="headerlink" title="React介绍"></a>React介绍</h2><blockquote><p>React是一个 用于构建用户界面的javascript库<br>React主要用于构建UI,很多人认为React是MVC中的V(视图)<br>React起源于Facebook的内部项目,用来架设Instagram的网站,并于2013年开源<br>React拥有较高的性能,代码逻辑非常简单,越来越多的人开始关注和使用它</p></blockquote><h3 id="React特点"><a href="#React特点" class="headerlink" title="React特点"></a>React特点</h3><blockquote><p>1.声明式设计 - React采用声明范式,可以轻松描述应用<br>2.高效  - React通过对DOM的模拟,最大限度的减少与DOM的交互<br>3.灵活 - React可以与已知的库或框架很好的配合<br>4.JSX - JSX是JavaScript语法的扩展,React开发不一定使用JSX,但建议使用它<br>5.组件 - 通过React构建组件,使得代码更加容易得到复用,能够很好的应用在大项目的开发中<br>6.单向响应的数据流 - React实现了单向响应的数据流,从而减少了重复代码,这也是它为什么比传统数据绑定更简单</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React介绍&quot;&gt;&lt;a href=&quot;#React介绍&quot; class=&quot;headerlink&quot; title=&quot;React介绍&quot;&gt;&lt;/a&gt;React介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;React是一个 用于构建用户界面的javascript库&lt;br&gt;Reac
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之事件处理</title>
    <link href="http://www.wanglichao.top/2018/11/13/React-Events/"/>
    <id>http://www.wanglichao.top/2018/11/13/React-Events/</id>
    <published>2018-11-12T21:28:01.000Z</published>
    <updated>2018-11-12T19:41:39.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-事件处理"><a href="#React-事件处理" class="headerlink" title="React 事件处理"></a>React 事件处理</h2><blockquote><p>React 元素的事件处理和DOM元素类似，但是语法上有有点不同；</p><ul><li>React 事件绑定属性的命名采用驼峰式写法，而不是小写；</li><li>如果采用JSX的语法你需要传入一个函数作为事件处理函数，而不是一个字符串（DOM元素的写法）；<br>HTML写法：<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;button onclick=&quot;todoSomething()&quot;&gt;button&lt;/button&gt;<br></code></pre></td></tr></table></figure></li></ul><p>React写法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;button onClick=&quot;todoSomething&quot;&gt;button&lt;/button&gt;<br></code></pre></td></tr></table></figure></p><p>在React中另一个不同是不能使用返回false的方式阻止默认行为，而必须<br>明确的使用preventDefault；<br>使用React的时候通常不需要使用addEventListener为一个已创建的DOM元素添加监视器，仅仅需要在这个元素渲染的时候提供一个监视器；<br>当使用ES6 class语法来定义一个组件的时候，事件处理器会成为类的一个方法。例如：Toggle组件渲染一个让用户切换开关状态的按钮：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class Toggle extends React.Component &#123;<br>        constructor(props) &#123;<br>            super(props);<br>            this.state = &#123;<br>                isToggle: true<br>            &#125;;<br>            this.handleClick = this.handleClick.bind(this);<br>        &#125;<br><br>        handleClick() &#123;<br>            this.setState(prevState =&gt; (&#123;<br>                isToggle: !prevState.isToggle<br>            &#125;))<br>        &#125;<br><br>        render() &#123;<br>            return (<br>                &lt;button onClick=&#123;this.handleClick&#125;&gt;<br>                    &#123;this.state.isToggle ? &apos;ON&apos; : &apos;OFF&apos;&#125;<br>                &lt;/button&gt;<br>            )<br>        &#125;<br>    &#125;<br><br>    ReactDOM.render(<br>        &lt;Toggle /&gt;,<br>        document.getElementById(&quot;example&quot;)<br>    )<br></code></pre></td></tr></table></figure></p><p>必须谨慎对待JSX回调函数中的this， 类的方法默认是不会绑定this的<br>如果忘记绑定this.handleClick并把它传入onClick，当调用这个函数的时候this的值会是undefined。<br>这不是React的特殊行为，它是函数如何在javaScript中运行的一部分。通常情况下，如果没有在方法后面添加（），例如：onClick={this.handleClick},应该为这个方法绑定this。<br>如果使用bind觉得有点烦，可以有两种解决方法：</p><ul><li><p>如果你正在使用实验性的属性初始化器语法，你可以使用属性初始化器来正确的绑定回调函数：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class LoggingButton extends React.Component &#123;<br>  // 这个语法确保了 `this` 绑定在  handleClick 中<br>  handleClick = () =&gt; &#123;<br>    console.log(&apos;this is:&apos;, this);<br>  &#125;<br> <br>  render() &#123;<br>    return (<br>      &lt;button onClick=&#123;this.handleClick&#125;&gt;<br>        Click me<br>      &lt;/button&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如果你没有使用属性初始化器语法，你可以在回调函数中使用 箭头函数：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class LoggingButton extends React.Component &#123;<br>  handleClick() &#123;<br>    console.log(&apos;this is:&apos;, this);<br>  &#125;<br> <br>  render() &#123;<br>    //  这个语法确保了 `this` 绑定在  handleClick 中<br>    return (<br>      &lt;button onClick=&#123;(e) =&gt; this.handleClick(e)&#125;&gt;<br>        Click me<br>      &lt;/button&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>这个语法有个问题就是么次LoggingButton渲染的时候都会创建一个不同的回调函数。在大多数情况下，这没有问题。然而如果这个回调函数作为一个属性值传入低阶组件，这些组件可能会进行额外的重新渲染。通常建议在构造函数中绑定或使用属性初始化器语法来避免这类性能问题。</p></blockquote><h3 id="向事件处理程序传递参数"><a href="#向事件处理程序传递参数" class="headerlink" title="向事件处理程序传递参数"></a>向事件处理程序传递参数</h3><blockquote><p>通常我们会为事件处理程序传递额外的参数。例如，如果是id是要删除的那一行的id，以下两种方式都可以向事件处理程序传递参数：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;button onClick=&#123;(e) =&gt; this.deleteSome(id, e)&#125;&gt;Delete&lt;/button&gt;<br>&lt;button onClick=&#123;this.deleteSome.bind(this, id)&#125;&gt;Delete&lt;/button&gt;<br></code></pre></td></tr></table></figure></p><p>这两种方式是等价的。<br>参数e作为React事件对象将会被作为第二个参数进行传递。<br>通过箭头函数的方式，事件对象必须显式的进行传递。<br>通过bind的方式，事件对象以及更多的参数将会被隐式的进行传递。<br>值得注意的是,通过bind方式向监听函数传参，在类组件中定义的监听函数，事件对象e要排在所传递参数的后面。例如：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class Popper extends React.Component &#123;<br>    constructor(props) &#123;<br>        super(props);<br>        this.state = &#123;<br>            name: &apos;Hello, React&apos;<br>        &#125;<br>    &#125;<br>    preventPop(name, e) &#123;<br>        e.preventDefault();<br>        console.log(name);<br>    &#125;<br>    render() &#123;<br>        return (<br>            &lt;div&gt;<br>                &lt;p&gt;hello&lt;/p&gt;<br>                &#123;/*通过bind()方法传递参数*/&#125;<br>                &lt;a href=&quot;http://www.wanglichao.top&quot;<br>                    onClick=&#123;this.preventPop.bind(this, this.state.name)&#125;<br>                &gt;Click&lt;/a&gt;<br>            &lt;/div&gt;<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-事件处理&quot;&gt;&lt;a href=&quot;#React-事件处理&quot; class=&quot;headerlink&quot; title=&quot;React 事件处理&quot;&gt;&lt;/a&gt;React 事件处理&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;React 元素的事件处理和DOM元素类似，但是语
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之this相关</title>
    <link href="http://www.wanglichao.top/2018/11/13/React-This/"/>
    <id>http://www.wanglichao.top/2018/11/13/React-This/</id>
    <published>2018-11-12T21:28:01.000Z</published>
    <updated>2018-11-12T19:49:32.557Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在JavaScript中，this对象是运行时基于函数的执行环境（也就是上下文）绑定的。</p><p>从 react 中的 demo 说起<br>Facebook一次更新react时，将es6中的class加入了组件的创建方式当中。Facebook也推荐组件创建使用通过定义一个继承自 React.Component 的class来定义一个组件类。官方的demo：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class LikeButton extends React.Component &#123;<br>  constructor() &#123;<br>    super();<br>    this.state = &#123;<br>      liked: false<br>    &#125;;<br>    this.handleClick = this.handleClick.bind(this);<br>  &#125;<br>  handleClick() &#123;<br>    this.setState(&#123;liked: !this.state.liked&#125;);<br>  &#125;<br>  render() &#123;<br>    const text = this.state.liked ? &apos;liked&apos; : &apos;haven\&apos;t liked&apos;;<br>    return (<br>      &lt;div onClick=&#123;this.handleClick&#125;&gt;<br>        You &#123;text&#125; this. Click to toggle.<br>      &lt;/div&gt;<br>    );<br>  &#125;<br>&#125;<br>ReactDOM.render(<br>  &lt;LikeButton /&gt;,<br>  document.getElementById(&apos;example&apos;)<br>);<br></code></pre></td></tr></table></figure></p><p>上面的demo中有大量this的使用，在 class LikeButton extends React.Component 中我们是声明该class，因为this具体是由其上下文决定的，因此在类定义中我们无法得知this用法。<br>相当于是new了上面定义的类，首先调用 constructor() 函数， this.state 的this上下文就是该实例对象；<br>同理，render() 函数中 this.state.liked 的this上下文也是该对象。<br>问题在于 onClick={this.handleClick} ，获取该函数引用是没有问题，这里的this上下文就是该对象。</p><p>这时问题来了，在原来 React.createClass 中， handleClick() 在onClick事件触发的时候，会自动绑定到LikeButton实例上，这时候该函数的this的上下文就是该实例。<br>不过在ES6的class的写法中，Facebook取消了自动绑定，实例化LikeButton后，handleClick()的上下文是div的支撑实例（ backing instance ），而 handleClick() 原本要绑定的上下文是LikeButton的实例。<br>对于该问题，我们有多种解决方案。<br><strong>使用 bind() 函数改变 this 的上下文</strong><br>可以在class声明中的constructor()函数中使用：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">this.handleClick = this.handleClick.bind(this);<br></code></pre></td></tr></table></figure></p><p>该方法是一个bind()绑定，多次使用。在该方法中，我们在声明该实例后，可以在该实例任何地方使用 handleClick() 函数，并且该 handleClick() 函数的this的上下文都是LikeButton实例对象。<br>除此我们也可以在具体使用该函数的地方绑定this的上下文到LikeButton实例对象，代码如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div onClick=&#123;this.handleClick.bind(this)&#125;&gt;<br>   Click to toggle.<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure></p><p>这种方法需要我们每次使用bind()函数绑定到组件对象上。<br><strong>es6的箭头函数</strong><br>es6中新加入了箭头函数=&gt;，箭头函数除了方便之外还有而一个特征就是将函数的this绑定到其定义时所在的上下文。这个特征也可以帮助我们解决这个问题。使用如下代码：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div onClick=&#123;() =&gt; this.handleClick()&#125;&gt;<br>  Click to toggle.<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure></p></blockquote><p>这样该 this.handleClick() 的上下文就会被绑定到 LikeButton 的实例对象上。</p><blockquote><p><strong>this的总结</strong><br>this 的本质就是：this跟作用域无关的，只跟执行上下文有关。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在JavaScript中，this对象是运行时基于函数的执行环境（也就是上下文）绑定的。&lt;/p&gt;
&lt;p&gt;从 react 中的 demo 说起&lt;br&gt;Facebook一次更新react时，将es6中的class加入了组件的创建方式当中。Faceboo
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之组件API</title>
    <link href="http://www.wanglichao.top/2018/11/13/React-component-API/"/>
    <id>http://www.wanglichao.top/2018/11/13/React-component-API/</id>
    <published>2018-11-12T21:28:01.000Z</published>
    <updated>2018-11-13T17:04:39.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-组件-API"><a href="#React-组件-API" class="headerlink" title="React 组件 API"></a>React 组件 API</h2><blockquote><p>React 组件API的7个方法:</p><ul><li>设置状态:setState</li><li>替换状态: replaceState</li><li>设置属性: setProps</li><li>替换属性: replaceState</li><li>强制更新: forceUpdate</li><li>获取DOM节点: findDOMNode</li><li>判断组件挂在状态： isMounted</li></ul></blockquote><h3 id="设置状态-setState"><a href="#设置状态-setState" class="headerlink" title="设置状态: setState"></a>设置状态: setState</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">setState(object nextState[, function callback])<br></code></pre></td></tr></table></figure><h5 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h5><pre><code>&gt; * nextState 将要设置新的状态,该状态会和当前的state合并;&gt; * callback 可选参数,回调函数,该函数会在setState设置成功,且组件重新渲染后调用;</code></pre><blockquote><p>合并nextState和当前state,并重新渲染组件,setState是React事件处理函数中和请求回调函数中触发UI更新的主要方法;</p></blockquote><h5 id="关于setState"><a href="#关于setState" class="headerlink" title="关于setState"></a>关于setState</h5><blockquote><p>不能在组件内部通过this.state修改状态,因为该状态会在调用setState()后被替换;<br>setState()并不会立即改变this.state,而是创建一个即将处理的state;<br>setState()并不一定是同步的,为了提升性能React会批量执行state和DOM渲染;<br>setState()总是会触发一次组件重绘,除非在shouldComponentUpdate()中实现了一些条件渲染逻辑;<br>点击计数器:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class Counter extends React.Component &#123;<br>        constructor(props) &#123;<br>            super(props);<br>            this.state = &#123;<br>                clickCount: 0<br>            &#125;;<br>            this.handleClick = this.handleClick.bind(this);<br>        &#125;<br><br>        handleClick() &#123;<br>            this.setState(function (state) &#123;<br>                return &#123;clickCount: state.clickCount + 1&#125;;<br>            &#125;)<br>        &#125;<br><br>        render() &#123;<br>            return(<br>                &lt;div&gt;<br>                    &lt;button onClick=&#123;this.handleClick&#125;&gt;点我&lt;/button&gt;<br>                    &lt;h3&gt;点击次数为&#123;this.state.clickCount&#125;&lt;/h3&gt;<br>                &lt;/div&gt;<br>            )<br>        &#125;<br>    &#125;<br><br>    ReactDOM.render(<br>        &lt;Counter /&gt;,<br>        document.getElementById(&quot;example&quot;)<br>    )<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="替换状态-replaceState"><a href="#替换状态-replaceState" class="headerlink" title="替换状态: replaceState"></a>替换状态: replaceState</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">replaceState(object nextState[, function callback])<br></code></pre></td></tr></table></figure><blockquote><p>replaceState() 方法与setState() 类似,但是方法只会保留nextState中的状态,原state不在nextState中的状态都会被删除</p></blockquote><h3 id="设置属性-setProps"><a href="#设置属性-setProps" class="headerlink" title="设置属性: setProps"></a>设置属性: setProps</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">setProps(object nextProps[, function callback])<br></code></pre></td></tr></table></figure><pre><code>&gt; * nextProps 将要设置的新属性,该状态会和当前的props合并;&gt; * callback 可选参数,回调函数,该函数会在setProps设置成功,且组件重新渲染后调用;</code></pre><blockquote><p>props相当于组件的数据流,它总是会从父组件向下传递至所有的子组件中.<br>当和一个外部的javascript应用集成时,我们可能需要向组件传递数据或者通知React.render() 组件需要重新渲染,可以使用setProps();<br>更新组件,我可以在节点上再次调用React.render(),也可以通过setProps() 方法改变组件属性,触发组件重新渲染;</p></blockquote><h3 id="替换属性-replaceProps"><a href="#替换属性-replaceProps" class="headerlink" title="替换属性: replaceProps"></a>替换属性: replaceProps</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">replaceProps(object nextProps[, function callback])<br></code></pre></td></tr></table></figure><blockquote><p>replaceProps()方法与setProps()方法类似,但是它会删除原有的props;</p></blockquote><h3 id="强制更新-forceUpdate"><a href="#强制更新-forceUpdate" class="headerlink" title="强制更新: forceUpdate"></a>强制更新: forceUpdate</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">forceUpdate([function callback])<br></code></pre></td></tr></table></figure><blockquote><ul><li>callback 可选参数,回调函数,该函数会在组件render()方法调用后调用;<br>forceUpdate()方法会使组件调用自身的render() 方法重新渲染组件,组件的子组件也会调用自己的render() ,但是,组件重新渲染时,依然会读取this.props和this.state,如果状态没有改变,那么React只会更新DOM;<br>forceUpdate()方式适用于this.props和this.state之外的组件重绘(如:修改了this.state后), 通过该方法通知React需要调用render();<br>一般来说,应该尽量避免使用forceUpdate(),而仅从this.props和this.state中读取状态并由React触发render调用;</li></ul></blockquote><h3 id="获取DOM节点-findDOMNode"><a href="#获取DOM节点-findDOMNode" class="headerlink" title="获取DOM节点: findDOMNode"></a>获取DOM节点: findDOMNode</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">DOMElement findDOMNode<br></code></pre></td></tr></table></figure><blockquote><ul><li>返回值: DOM元素DOMElement<br>如果组件已经挂载到DOM中,该方法返回对应的本地浏览器DOM元素<br>当render()返回null或false时,this.findDOMNode()也会返回null.<br>从DOM中读取值得时候，该方法很有用，如：获取表单字段的值和做一些DOM操作；</li></ul></blockquote><h3 id="判断组件挂载状态：-isMounted"><a href="#判断组件挂载状态：-isMounted" class="headerlink" title="判断组件挂载状态： isMounted"></a>判断组件挂载状态： isMounted</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">bool isMounted()<br></code></pre></td></tr></table></figure><blockquote><ul><li>返回值： true或false，表示组件是否已经挂载到DOM中<br>isMounted()方法用于判断组件是否已挂在到DOM中<br>可以使用该方法保证来setState（）和forceUpdate（）在异步场景下的调用不会出错。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-组件-API&quot;&gt;&lt;a href=&quot;#React-组件-API&quot; class=&quot;headerlink&quot; title=&quot;React 组件 API&quot;&gt;&lt;/a&gt;React 组件 API&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;React 组件API的7个方法:
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之生命周期</title>
    <link href="http://www.wanglichao.top/2018/11/13/React-life/"/>
    <id>http://www.wanglichao.top/2018/11/13/React-life/</id>
    <published>2018-11-12T21:28:01.000Z</published>
    <updated>2018-11-13T19:11:38.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-生命周期"><a href="#React-生命周期" class="headerlink" title="React 生命周期"></a>React 生命周期</h2><blockquote><p>组件的生命周期可分成三个状态:</p><ul><li>Mounting: 已插入真实DOM;</li><li>Updating: 正在被重新渲染;</li><li>Unmounting: 已移出真实DOM;</li></ul></blockquote><p><strong>生命周期的方法有</strong>：</p><blockquote><ul><li>componentWillComponent 在渲染前调用,在客户端也在服务端;</li><li>componentDidMount 在第一次渲染后调用,只在客户端.  之后已经生成了对应的DOM结构,可以通过this.getDOMNode()来进行访问,如果你想和其他javascript框架一起使用,可以在这个方法中调用setTimeout,setInterval或者发送ajax请求等操作(防止异步操作阻塞UI);</li><li>componentWillReceiveProps 在组件接收到一个新的prop(更新后)时被调用,这个方法在初始化render时不会被调用;</li><li>shouldComponentUpdate 返回一个布尔值,在组件接收到新的props或者state时被调用,在初始化时或者使用forceUpdate时不被调用;<br>componentWillUpdate 在组件接收到新的props或者state,但还没有render时调用,在初始化时不会被调用;</li><li>componentDidUpdate 在组件完成更新后立即调用,在初始化时不会被调用;</li><li>componentWillUnmount 在组件从DOM中移除之前立刻被调用;<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs undefined">componentWillMount() &#123;<br>            console.log(&apos;Component Will Mount&apos;);<br>        &#125;<br>        componentDidMount() &#123;<br>            console.log(&apos;Component Did Mount&apos;);<br>        &#125;<br>        componentWillReceiveProps(newProps) &#123;<br>            console.log(&apos;Component Will Receive Props&apos;);<br>        &#125;<br>        shouldComponentUpdate(newProps, newState) &#123;<br>            console.log(&apos;Should Component Update&apos;);<br>            return true;<br>        &#125;<br>        componentWillUpdate(nextProps, nextState) &#123;<br>            console.log(&apos;Component Will Update&apos;);<br>        &#125;<br>        componentDidUpdate(prevProps, prevState) &#123;<br>            console.log(&apos;Component Did Update&apos;);<br>        &#125;<br>        componentWillUnmount() &#123;<br>            console.log(&apos;Component Will Unmount&apos;);<br>        &#125;<br></code></pre></td></tr></table></figure></li></ul></blockquote><p><img src="/2018/11/13/React-life/images/React-life1.png" alt="生命周期1"><br><img src="/2018/11/13/React-life/images/React-life2.jpg" alt="生命周期2"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-生命周期&quot;&gt;&lt;a href=&quot;#React-生命周期&quot; class=&quot;headerlink&quot; title=&quot;React 生命周期&quot;&gt;&lt;/a&gt;React 生命周期&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;组件的生命周期可分成三个状态:&lt;/p&gt;
&lt;ul&gt;

      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之组件</title>
    <link href="http://www.wanglichao.top/2018/11/13/React-component/"/>
    <id>http://www.wanglichao.top/2018/11/13/React-component/</id>
    <published>2018-11-12T21:28:01.000Z</published>
    <updated>2018-11-12T18:44:37.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-组件"><a href="#React-组件" class="headerlink" title="React 组件"></a>React 组件</h2><blockquote><p>封装一个组件:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">// 使用函数定义一个组件<br>function Message(props) &#123;<br>    return &lt;h1&gt;Hello React!&lt;/h1&gt;;<br>&#125;<br> <br>const element = &lt;Message /&gt;;<br> <br>ReactDOM.render(<br>    element,<br>    document.getElementById(&apos;example&apos;)<br>);<br></code></pre></td></tr></table></figure></p><p>也可以使用ES6 class来定义一个组件<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class Welcome extends React.Component &#123;<br>  render() &#123;<br>    return &lt;h1&gt;Hello React!&lt;/h1&gt;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>const element = <hellomessage> 为用户自定义的组件。<br>注意，原生 HTML 元素名以小写字母开头，而自定义的 React 类名以大写字母开头，比如 HelloMessage 不能写成 helloMessage。除此之外还需要注意组件类只能包含一个顶层标签，否则也会报错。</hellomessage></p><p>如果需要向组件传递参数，可以使用 this.props 对象<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;script type=&quot;text/babel&quot;&gt;<br>        function HelloMessage(props) &#123;<br>            return &lt;h1&gt;Hello, &#123;props.name&#125;!&lt;/h1&gt;<br>        &#125;<br>        const element = &lt;HelloMessage name=&apos;React&apos; /&gt;;<br>        ReactDOM.render(<br>            element,<br>            document.getElementById(&apos;box&apos;)<br>        )<br>    &lt;/script&gt;<br></code></pre></td></tr></table></figure></p><p>以上实例中name属性通过proops.name来获取<br><code>注意，在添加属性时， class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字。</code></p></blockquote><h3 id="复合组件"><a href="#复合组件" class="headerlink" title="复合组件"></a>复合组件</h3><blockquote><p>我们可以通过创建多个组件来合成一个组件，即把组件的不同功能点进行分离。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs undefined">function Name(props) &#123;<br>            return &lt;h1&gt;网站名称: &#123;props.name&#125;&lt;/h1&gt;<br>        &#125;<br>        function Url(props) &#123;<br>            return &lt;h1&gt;网站地址: &#123;props.url&#125;&lt;/h1&gt;<br>        &#125;<br>        function Nickname(props) &#123;<br>            return &lt;h1&gt;网站小名: &#123;props.nickname&#125;&lt;/h1&gt;<br>        &#125;<br>        function App() &#123;<br>            return (<br>                &lt;div&gt;<br>                    &lt;Name name=&apos;勇往直前&apos;/&gt;<br>                    &lt;Url url=&quot;http://www.wanglichao.top&quot;/&gt;<br>                    &lt;Nickname nickname=&quot;心有远方&quot;/&gt;<br>                &lt;/div&gt;<br>            )<br>        &#125;<br>        ReactDOM.render(<br>            &lt;App /&gt;,<br>            document.getElementById(&apos;box&apos;)<br>        )<br></code></pre></td></tr></table></figure></p><p>实例中 App 组件使用了 Name、Url 和 Nickname 组件来输出对应的信息。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-组件&quot;&gt;&lt;a href=&quot;#React-组件&quot; class=&quot;headerlink&quot; title=&quot;React 组件&quot;&gt;&lt;/a&gt;React 组件&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;封装一个组件:&lt;br&gt;&lt;figure class=&quot;hljs hi
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之安装</title>
    <link href="http://www.wanglichao.top/2018/11/13/React-install/"/>
    <id>http://www.wanglichao.top/2018/11/13/React-install/</id>
    <published>2018-11-12T21:28:01.000Z</published>
    <updated>2018-11-13T14:08:41.095Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-安装"><a href="#React-安装" class="headerlink" title="React 安装"></a>React 安装</h2><h3 id="React-可以直接下载使用-也可以使用CDN"><a href="#React-可以直接下载使用-也可以使用CDN" class="headerlink" title="React 可以直接下载使用,也可以使用CDN;"></a>React 可以直接下载使用,也可以使用CDN;</h3><blockquote><p>Staticfile CDN 的 React CDN 库:</p></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;script src=&quot;https://cdn.staticfile.org/react/16.4.0/umd/react.development.js&quot;&gt;&lt;/script&gt;<br>&lt;script src=&quot;https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js&quot;&gt;&lt;/script&gt;<br>&lt;!-- 生产环境中不建议使用 --&gt;<br>&lt;script src=&quot;https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js&quot;&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><blockquote><p>官方提供的DCN地址:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;script src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt;<br>&lt;script src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt;<br>&lt;!-- 生产环境中不建议使用 --&gt;<br>&lt;script src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><p>输出Hello,React!的实例<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;meta charset=&quot;UTF-8&quot; /&gt;<br>&lt;title&gt;Hello React!&lt;/title&gt;<br>&lt;script src=&quot;https://cdn.staticfile.org/react/16.4.0/umd/react.development.js&quot;&gt;&lt;/script&gt;<br>&lt;script src=&quot;https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js&quot;&gt;&lt;/script&gt;<br>&lt;script src=&quot;https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js&quot;&gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br> <br>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;<br>&lt;script type=&quot;text/babel&quot;&gt;<br>ReactDOM.render(<br>    &lt;h1&gt;Hello,React!&lt;/h1&gt;,<br>    document.getElementById(&apos;app&apos;)<br>);<br>&lt;/script&gt;<br> <br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure></p><p>实例中需要3个库 react / react-DOM / babel</p><ul><li>react -&gt; React的核心库</li><li>react-dom -&gt; 提供与DOM相关的功能</li><li>babel -&gt;babel可以将ES6代码转为ES5代码,这就可以在不支持ES6的浏览器上执行React代码,babel内嵌了对JSX的支持<br>注意:如果需要使用JSX,则script标签的type属性需要设置为text/babel</li></ul></blockquote><h3 id="通过npm使用React"><a href="#通过npm使用React" class="headerlink" title="通过npm使用React"></a>通过npm使用React</h3><p>国内简易使用cnpm代替npm安装package;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">$ npm install -g cnpm --registry=https://registry.npm.taobao.org<br>$ npm config set registry https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure></p><blockquote><p>这样就可以使用cnpm命令来安装模块了<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">$ cnpm install [packagename]<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="使用create-react-app-快速构建React开发环境"><a href="#使用create-react-app-快速构建React开发环境" class="headerlink" title="使用create-react-app 快速构建React开发环境"></a>使用create-react-app 快速构建React开发环境</h3><blockquote><p>create-react-app 是来自于facebook，通过该命令我们无需配置就能快速构建React开发环境。<br>create-react-app 自动创建的项目是基于Webpack + ES6.<br>执行以下命令创建项目：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">$ cnpm install -g create-react-app<br>$ create-react-app [my-app]<br>$ cd [my-app]<br>$ npm start<br></code></pre></td></tr></table></figure></p><p>在浏览器中打开<a href="http://localhost:3000，就会呈现项目页面" target="_blank" rel="noopener">http://localhost:3000，就会呈现项目页面</a></p></blockquote><p>React 代码的书写格式和以前的 JS 有很大的不同，下面通过对这段代码进行分析了解一下他。</p><p>以前使用JS 定义一个变量使用 var 现在用 const：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">const div = document.createElement(&apos;div&apos;);<br></code></pre></td></tr></table></figure><p>ReactDOM.render(…) 是渲染方法，所有的 js,html 都可通过它进行渲染绘制，他又两个参数，内容和渲染目标 js 对象。</p><p>内容就是要在渲染目标中显示的东西，可以是一个React 部件，也可以是一段HTML或TEXT文本。渲染目标JS对象，就是一个DIV或TABEL,或TD 等HTML的节点对象。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">ReactDOM.render(&lt;App /&gt;, div);<br></code></pre></td></tr></table></figure><p>unmountComponentAtNode() 这个方法是解除渲染挂载，作用和 render 刚好相反，也就清空一个渲染目标中的 React 部件或 html 内容。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">ReactDOM.unmountComponentAtNode(div);<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-安装&quot;&gt;&lt;a href=&quot;#React-安装&quot; class=&quot;headerlink&quot; title=&quot;React 安装&quot;&gt;&lt;/a&gt;React 安装&lt;/h2&gt;&lt;h3 id=&quot;React-可以直接下载使用-也可以使用CDN&quot;&gt;&lt;a href=&quot;#React-
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之渲染</title>
    <link href="http://www.wanglichao.top/2018/11/13/React-render/"/>
    <id>http://www.wanglichao.top/2018/11/13/React-render/</id>
    <published>2018-11-12T21:28:01.000Z</published>
    <updated>2018-11-12T18:44:33.696Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React元素渲染"><a href="#React元素渲染" class="headerlink" title="React元素渲染"></a>React元素渲染</h2><blockquote><p>元素是构成React应用的最小单位，它用于描述屏幕上输出的内容。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">const element = &lt;h1&gt;Hello,React!&lt;/h1&gt;;<br></code></pre></td></tr></table></figure></p><p>与浏览器的DOM元素不同，React当中的元素事实上是普通的对象， React DOM可以确保浏览器DOM的数据内容与React元素保持一致。</p></blockquote><h3 id="将元素渲染到DOM中"><a href="#将元素渲染到DOM中" class="headerlink" title="将元素渲染到DOM中"></a>将元素渲染到DOM中</h3><blockquote><p>首先，在一个html页面中添加一个id=“example”的div<br>在此div中的所有内容都将由React DOM来管理，所以我们将其称之为“根”DOM节点<br>用React开发应用时一般只会定义一个根节点，但如果是在一个已有的项目中引入React的话，可能会需要在不同部分单独定义React根节点。</p></blockquote><h3 id="更新元素渲染"><a href="#更新元素渲染" class="headerlink" title="更新元素渲染"></a>更新元素渲染</h3><blockquote><p>React 元素都是不可变的，当元素被创建之后，是无法改变其内容或属性的。<br>目前更新界面的唯一办法就是创建一个新的元素，然后将它传入React DOM.render()方法；</p></blockquote><h3 id="React-只会更新必要的部分"><a href="#React-只会更新必要的部分" class="headerlink" title="React 只会更新必要的部分"></a>React 只会更新必要的部分</h3><blockquote><p>值得注意的是，React　DOM首先会比较元素内容先后的不同，而在渲染过程中只会更新改变了的部分。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React元素渲染&quot;&gt;&lt;a href=&quot;#React元素渲染&quot; class=&quot;headerlink&quot; title=&quot;React元素渲染&quot;&gt;&lt;/a&gt;React元素渲染&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;元素是构成React应用的最小单位，它用于描述屏幕上输出的
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之条件渲染</title>
    <link href="http://www.wanglichao.top/2018/11/13/React-condition-render/"/>
    <id>http://www.wanglichao.top/2018/11/13/React-condition-render/</id>
    <published>2018-11-12T21:28:01.000Z</published>
    <updated>2018-11-12T21:28:17.363Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-条件渲染"><a href="#React-条件渲染" class="headerlink" title="React 条件渲染"></a>React 条件渲染</h2><blockquote><p>在React中，你可以创建不同的组件来封装你需要的各种行为，然后还可以根据应用的状态变化仅渲染其中的一部分。<br>React中的条件渲染和JavaScript中的一致，使用JavaScript操作符if或条件运算符来创建表示当前状态的元素，然后让React根据它们来更新UI。<br>一个根据用户是否登录来显示其中之一的组件：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs undefined">function UserGreeting() &#123;<br>        return &lt;h1&gt;欢迎登录&lt;/h1&gt;<br>    &#125;<br><br>    function GuestGreeting() &#123;<br>        return &lt;h1&gt;请先注册&lt;/h1&gt;<br>    &#125;<br><br>    function Greeting(props) &#123;<br>        const isLoggedIn = props.isLoggedIn;<br>        if (isLoggedIn) &#123;<br>            return &lt;UserGreeting /&gt;<br>        &#125;<br>        return &lt;GuestGreeting /&gt;<br>    &#125;<br><br>    ReactDOM.render(<br>        // true or false<br>        &lt;Greeting isLoggedIn=&#123;false&#125;/&gt;,<br>        document.getElementById(&apos;example&apos;)<br>    )<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="元素变量"><a href="#元素变量" class="headerlink" title="元素变量"></a>元素变量</h3><blockquote><p>你可以使用变量来储存元素，它可以帮助你有条件的渲染组件中的一部分，而其他的部分不会更改。<br>创建一个LoginControl的有状态的组件，根据当前的状态来渲染<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class LoginControl extends React.Component &#123;<br>        constructor(props) &#123;<br>            super(props);<br>            this.state = &#123;<br>                isLoggedIn: false<br>            &#125;;<br>            this.handleLoginClick = this.handleLoginClick.bind(this);<br>            this.handleLogoutClick = this.handleLogoutClick.bind(this);<br>        &#125;<br>        handleLoginClick() &#123;<br>            this.setState(&#123;<br>                isLoggedIn: true<br>            &#125;)<br>        &#125;<br>        handleLogoutClick() &#123;<br>            this.setState(&#123;<br>                isLoggedIn: false<br>            &#125;)<br>        &#125;<br>        render() &#123;<br>            const isLoggedIn = this.state.isLoggedIn;<br>            let button = null;<br>            if (isLoggedIn) &#123;<br>                button = &lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125;/&gt;<br>            &#125; else &#123;<br>                button = &lt;LoginButton onClick=&#123;this.handleLoginClick&#125;/&gt;<br>            &#125;<br>            return (<br>                &lt;div&gt;<br>                    &lt;Greeting isLoggedIn=&#123;isLoggedIn&#125;/&gt;<br>                    &#123;button&#125;<br>                &lt;/div&gt;<br>            )<br>        &#125;<br>    &#125;<br><br>    function UserGreeting() &#123;<br>        return &lt;h1&gt;欢迎登录&lt;/h1&gt;<br>    &#125;<br><br>    function GuestGreeting() &#123;<br>        return &lt;h1&gt;请先登录或者注册&lt;/h1&gt;<br>    &#125;<br><br>    function Greeting(props) &#123;<br>        const isLoggedIn = props.isLoggedIn;<br>        if (isLoggedIn) &#123;<br>            return &lt;UserGreeting /&gt;<br>        &#125;<br>        return &lt;GuestGreeting /&gt;<br>    &#125;<br><br>    function LoginButton(props) &#123;<br>        return (<br>            &lt;button onClick=&#123;props.onClick&#125;&gt;登录&lt;/button&gt;<br>        )<br>    &#125;<br><br>    function LogoutButton(props) &#123;<br>        return (<br>            &lt;button onClick=&#123;props.onClick&#125;&gt;退出&lt;/button&gt;<br>        )<br>    &#125;<br><br>    ReactDOM.render(<br>        &lt;LoginControl /&gt;,<br>        document.getElementById(&quot;example&quot;)<br>    )<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="与运算符-amp-amp"><a href="#与运算符-amp-amp" class="headerlink" title="与运算符 &amp;&amp;"></a>与运算符 &amp;&amp;</h3><blockquote><p>你可以通过花括号包裹代码在JSX中嵌入任何表达式，也包括JavaScript的逻辑与&amp;&amp;，它可以方便的条件渲染一个元素<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs undefined">function Mailbox(props) &#123;<br>        const unreadMessages = props.unreadMessages;<br>        return (<br>            &lt;div&gt;<br>                &lt;h1&gt;Hello!&lt;/h1&gt;<br>                &#123;unreadMessages.length &gt; 0 &amp;&amp;<br>                    &lt;h2&gt;<br>                        您有&#123;unreadMessages.length&#125;条未读消息<br>                    &lt;/h2&gt;<br>                &#125;<br>            &lt;/div&gt;<br>        )<br>    &#125;<br><br>    const messages = [&apos;react&apos;, &apos;vue&apos;, &apos;javascript&apos;];<br>    ReactDOM.render(<br>        &lt;Mailbox unreadMessages=&#123;messages&#125;/&gt;,<br>        document.getElementById(&quot;example&quot;)<br>    )<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h3><p>条件渲染的另一种方法是使用JavaScript的条件运算符。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">something ? true : false<br></code></pre></td></tr></table></figure></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">render() &#123;<br>  const isLoggedIn = this.state.isLoggedIn;<br>  return (<br>    &lt;div&gt;<br>      &#123;isLoggedIn ? (<br>        &lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125; /&gt;<br>      ) : (<br>        &lt;LoginButton onClick=&#123;this.handleLoginClick&#125; /&gt;<br>      )&#125;<br>    &lt;/div&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在极少数情况下，你可能希望隐藏组件，即使它被其他组件渲染。让 render 方法返回 null 而不是它的渲染结果即可实现。<br>组件的 render 方法返回 null 并不会影响该组件生命周期方法的回调。例如，componentWillUpdate 和 componentDidUpdate 依然可以被调用。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-条件渲染&quot;&gt;&lt;a href=&quot;#React-条件渲染&quot; class=&quot;headerlink&quot; title=&quot;React 条件渲染&quot;&gt;&lt;/a&gt;React 条件渲染&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在React中，你可以创建不同的组件来封装你需要的
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>关于项目打包时的优化</title>
    <link href="http://www.wanglichao.top/2018/11/11/project_webpack_optimize/"/>
    <id>http://www.wanglichao.top/2018/11/11/project_webpack_optimize/</id>
    <published>2018-11-10T22:37:24.000Z</published>
    <updated>2018-11-12T18:44:44.358Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前端-JavaScript-项目优化"><a href="#前端-JavaScript-项目优化" class="headerlink" title="前端 JavaScript 项目优化"></a>前端 JavaScript 项目优化</h2><h3 id="1-CSS抽离"><a href="#1-CSS抽离" class="headerlink" title="1.CSS抽离"></a>1.CSS抽离</h3><blockquote><p>将css文件从js文件中抽离出来;<br>分开加载,代码有改动时css/JS不用全部去加载;</p></blockquote><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 抽离css文件的插件:</span><br><span class="hljs-keyword">const</span> ExtractTextPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">"extract-text-webpack-plugin"</span>);<br><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-attr">module</span>: &#123;<br>        <span class="hljs-attr">rules</span>: [<br>            test: <span class="hljs-regexp">/\.css$/</span>,<br>            <span class="hljs-attr">use</span>: ExtracTextPlugin.extrac(&#123;<br>                <span class="hljs-attr">fallback</span>: <span class="hljs-string">"style-loader"</span>,<br>                <span class="hljs-attr">use</span>: <span class="hljs-string">"css-loader"</span><br>            &#125;)<br>        ]<br>    &#125;,<br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-keyword">new</span> ExtractTextPlugin(<span class="hljs-string">"styles.css"</span>)<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-哈希值"><a href="#2-哈希值" class="headerlink" title="2.哈希值"></a>2.哈希值</h3><blockquote><p>辨识文件是否改动;</p></blockquote><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">output: &#123;<br>   <span class="hljs-attr">path</span>: path.join(__dirname, <span class="hljs-string">'dist'</span>),<br>   <span class="hljs-comment">// js文件的哈希</span><br>   filename: <span class="hljs-string">"[name].[chunkhash:6].js"</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">plugins: [<br>       <span class="hljs-comment">// css文件的哈希</span><br>       <span class="hljs-keyword">new</span> ExtractTextPlugin(<span class="hljs-string">"[name].[contenthash:6].css"</span>)<br>   ]<br></code></pre></td></tr></table></figure><h3 id="3-第三方包抽离"><a href="#3-第三方包抽离" class="headerlink" title="3.第三方包抽离"></a>3.第三方包抽离</h3><blockquote><p>辨识部分文件改动;</p></blockquote><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 此插件依赖webpack</span><br><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>);<br><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-attr">entry</span>: &#123;<br>         <span class="hljs-attr">main</span>: <span class="hljs-string">"./src/main.js"</span>,<br>        <span class="hljs-comment">// 再加一个入口,将第三方包从main.js中分离出来</span><br>        vendors: [<span class="hljs-string">"vue"</span>,<span class="hljs-string">"vue-router"</span>,<span class="hljs-string">"moment"</span>,<span class="hljs-string">"axios"</span>,<span class="hljs-string">"vue-preview"</span>]<br>    &#125;,<br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-comment">// webpack中抽离第三方包的插件:</span><br>        <span class="hljs-keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;<br>            <span class="hljs-comment">// manifest用来记录使用者和第三方包的依赖关系</span><br>            names: [<span class="hljs-string">"vendors"</span>, <span class="hljs-string">"manifest"</span>]<br>        &#125;)<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-代码压缩混淆"><a href="#4-代码压缩混淆" class="headerlink" title="4.代码压缩混淆"></a>4.代码压缩混淆</h3><blockquote><p>很大程度的压缩代码体积</p></blockquote><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 压缩混淆代码的插件,需要 npm i -D uglifyjs-webpack-plugin 下载</span><br><span class="hljs-keyword">const</span> UglifyJSPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">"uglifyjs-webpack-plugin"</span>);<br><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-keyword">new</span> UglifyJSPlugin()<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-main-ui的按需引入"><a href="#5-main-ui的按需引入" class="headerlink" title="5.main-ui的按需引入"></a>5.main-ui的按需引入</h3><blockquote><p>进一步减小代码体积</p></blockquote><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 全部引入的用法:</span><br><span class="hljs-comment">// import Mint from 'mint-ui'</span><br><span class="hljs-comment">// import 'mint-ui/lib/style.css'</span><br><span class="hljs-comment">// Vue.use(Mint);</span><br><br><span class="hljs-comment">// 按需加载的用法:</span><br><span class="hljs-keyword">import</span> Header <span class="hljs-keyword">from</span> <span class="hljs-string">'mint-ui/lib/header'</span><br><span class="hljs-keyword">import</span> Switch <span class="hljs-keyword">from</span> <span class="hljs-string">'mint-ui/lib/switch'</span><br><span class="hljs-keyword">import</span> SwitchItem <span class="hljs-keyword">from</span> <span class="hljs-string">'mint-ui/lib/switch-item'</span><br><span class="hljs-keyword">import</span> Button <span class="hljs-keyword">from</span> <span class="hljs-string">'mint-ui/lib/button'</span><br><span class="hljs-keyword">import</span> Lazyload <span class="hljs-keyword">from</span> <span class="hljs-string">'mint-ui/lib/lazyload'</span><br><span class="hljs-comment">// ...</span><br><br>Vue.component(Header.name, Header);<br>Vue.component(SwitchItem.name, SwitchItem);<br>Vue.component(Button.name, Button);<br>Vue.use(Lazyload); <span class="hljs-comment">// 注意lazyload(懒加载)仍需要use方式调用</span><br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><h3 id="6-代码文件的结构整理"><a href="#6-代码文件的结构整理" class="headerlink" title="6.代码文件的结构整理"></a>6.代码文件的结构整理</h3><blockquote><p>文件的分类整理</p><ul><li>注意: 将文件路径分类整理后,代码中的相对路径引用文件可能会发生错误,需要修正</li></ul></blockquote><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">output: &#123;<br>   <span class="hljs-attr">path</span>: path.join(__dirname, <span class="hljs-string">'dist'</span>),<br>   <span class="hljs-comment">// 修正资源请求路径</span><br>   publicPath: <span class="hljs-string">'/'</span>,   <span class="hljs-comment">// 企业中也可以是 www.xxx.com/为根路径</span><br>   <span class="hljs-comment">// js文件的路径</span><br>   filename: <span class="hljs-string">"js/[name].[chunkhash:6].js"</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>   <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(jpg|png|svg|ttf|woff|woff2|gif)$/</span>,<br>   <span class="hljs-attr">use</span>: [<br>       <span class="hljs-string">'url-loader'</span>,<br>       <span class="hljs-attr">options</span>: &#123;<br>           <span class="hljs-attr">limit</span>: <span class="hljs-number">4096</span>,<br>           <span class="hljs-comment">// 图片文件的路径</span><br>           name: <span class="hljs-string">'/assets/[name].[ext]'</span><br>       &#125;<br>   ]<br>&#125;<br></code></pre></td></tr></table></figure><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">plugins: [<br>       <span class="hljs-comment">// css文件的路径</span><br>       <span class="hljs-keyword">new</span> ExtractTextPlugin(<span class="hljs-string">"css/[name].[contenthash:6].css"</span>)<br>   ]<br></code></pre></td></tr></table></figure><h3 id="7-路由的懒加载"><a href="#7-路由的懒加载" class="headerlink" title="7.路由的懒加载"></a>7.路由的懒加载</h3><blockquote><p>根据路由路径按需加载页面</p></blockquote><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.vue'</span>  <span class="hljs-comment">// 公用App组件不用</span><br><br><span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">'./component/home/home.vue'</span><br><span class="hljs-keyword">import</span> News <span class="hljs-keyword">from</span> <span class="hljs-string">'./component/news/news.vue'</span><br><span class="hljs-comment">// 修改为</span><br><span class="hljs-keyword">const</span> Home = <span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">require</span>([<span class="hljs-string">'./component/home/home.vue'</span>, resolve]);<br><span class="hljs-keyword">const</span> News = <span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> <span class="hljs-built_in">require</span>([<span class="hljs-string">'./component/news/news.vue'</span>, r]);<br></code></pre></td></tr></table></figure><h3 id="8-去除控制台开发的提示"><a href="#8-去除控制台开发的提示" class="headerlink" title="8.去除控制台开发的提示"></a>8.去除控制台开发的提示</h3><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">plugins: [<br>    <span class="hljs-keyword">new</span> webpack.DefinePlugin(&#123;<br>        <span class="hljs-string">'process.env'</span>: &#123;<br>            <span class="hljs-attr">NODE_ENV</span>: <span class="hljs-string">'"production"'</span><br>        &#125;<br>    &#125;)<br>]<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前端-JavaScript-项目优化&quot;&gt;&lt;a href=&quot;#前端-JavaScript-项目优化&quot; class=&quot;headerlink&quot; title=&quot;前端 JavaScript 项目优化&quot;&gt;&lt;/a&gt;前端 JavaScript 项目优化&lt;/h2&gt;&lt;h3 id=&quot;1
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="node" scheme="http://www.wanglichao.top/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>输入URL地址敲回车之后发生了什么</title>
    <link href="http://www.wanglichao.top/2018/11/10/enter-event/"/>
    <id>http://www.wanglichao.top/2018/11/10/enter-event/</id>
    <published>2018-11-10T12:14:24.000Z</published>
    <updated>2018-11-12T18:44:50.292Z</updated>
    
    <content type="html"><![CDATA[<h2 id="输入URL地址敲回车之后发生了什么"><a href="#输入URL地址敲回车之后发生了什么" class="headerlink" title="输入URL地址敲回车之后发生了什么"></a>输入URL地址敲回车之后发生了什么</h2><blockquote><p> 输入网址敲回车之后,<br> 浏览器开始向DNS服务器发送请求,    (request)请求<br> DNS服务器解析,<br> 找到IP地址对应的服务器,<br> 服务器根据对应的端口号找到对应的项目,<br> 将需要的数据代码编码后返回给浏览器客户端,并将数据的类型告诉浏览器(HTML/json…),     (response)响应<br> 浏览器将接收到的数据根据返回来的数据类型进行解析,</p></blockquote><ul><li><p>http事物: request请求和response响应都成功就是一个完整的HTTP事物;</p></li><li><p><a href="https://www.baidu.com:443/xx/yy/index.html?name=aa&amp;age=30#id=5" target="_blank" rel="noopener">https://www.baidu.com:443/xx/yy/index.html?name=aa&amp;age=30#id=5</a></p></li><li><p>(https) – (www.baidu.com ) – (443) – (/xx/yy/index.html) – (name=aa&amp;age=30) – (id=5)</p></li></ul><h2 id="1-HTTPS-传输协议"><a href="#1-HTTPS-传输协议" class="headerlink" title="1.(HTTPS) 传输协议"></a>1.(HTTPS) 传输协议</h2><blockquote><p>https / http  完成客户端和服务端的数据交互传输<br>https: 更加安全<br>http: 超文本传输协议<br>FTP: 往服务器上上传项目文件</p></blockquote><h2 id="2-www-baidu-com-域名"><a href="#2-www-baidu-com-域名" class="headerlink" title="2.(www.baidu.com) 域名:"></a>2.(www.baidu.com) 域名:</h2><blockquote><p>一级域名<br>二级域名<br>三级域名</p></blockquote><h2 id="3-443-端口号"><a href="#3-443-端口号" class="headerlink" title="3.(443) 端口号:"></a>3.(443) 端口号:</h2><ul><li>根据端口号找到对应的项目<blockquote><p>http: 默认端口号80<br>https: 默认端口号443<br>FTP: 默认端口号21</p></blockquote></li></ul><h2 id="4-xx-yy-index-html-项目地址"><a href="#4-xx-yy-index-html-项目地址" class="headerlink" title="4.(/xx/yy/index.html)项目地址"></a>4.(/xx/yy/index.html)项目地址</h2><ul><li>根据地址值找到项目下的具体页面文件<blockquote><p>/xx/yy/index.html 真实地址, 请求资源文件<br>/xxx  伪地址, 请求数据</p></blockquote></li></ul><h2 id="5-name-aa-amp-age-30-参数"><a href="#5-name-aa-amp-age-30-参数" class="headerlink" title="5.(name=aa&amp;age=30)参数"></a>5.(name=aa&amp;age=30)参数</h2><ul><li>参数格式是后台规定的,根据参数的值返回响应的数据</li></ul><h2 id="6-id-5-哈希值-Hash值"><a href="#6-id-5-哈希值-Hash值" class="headerlink" title="6.(id=5) 哈希值 Hash值"></a>6.(id=5) 哈希值 Hash值</h2><blockquote><p>锚点定位<br>路由</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;输入URL地址敲回车之后发生了什么&quot;&gt;&lt;a href=&quot;#输入URL地址敲回车之后发生了什么&quot; class=&quot;headerlink&quot; title=&quot;输入URL地址敲回车之后发生了什么&quot;&gt;&lt;/a&gt;输入URL地址敲回车之后发生了什么&lt;/h2&gt;&lt;blockquote&gt;

      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="http" scheme="http://www.wanglichao.top/tags/http/"/>
    
      <category term="url" scheme="http://www.wanglichao.top/tags/url/"/>
    
  </entry>
  
  <entry>
    <title>javascript学习之json常用方法</title>
    <link href="http://www.wanglichao.top/2018/02/16/page/javascript-json/"/>
    <id>http://www.wanglichao.top/2018/02/16/page/javascript-json/</id>
    <published>2018-02-15T21:30:40.000Z</published>
    <updated>2018-11-10T15:22:40.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="javascript中JSON语法有三种表示方法："><a href="#javascript中JSON语法有三种表示方法：" class="headerlink" title="javascript中JSON语法有三种表示方法："></a>javascript中JSON语法有三种表示方法：</h1><h3 id="简单值-“hello-json”"><a href="#简单值-“hello-json”" class="headerlink" title="简单值:      “hello json”"></a>简单值:      “hello json”</h3><h3 id="对象-“name”-”jack”"><a href="#对象-“name”-”jack”" class="headerlink" title="对象:        {“name”:”jack”}"></a>对象:        {“name”:”jack”}</h3><h3 id="数组-“aaa”-”bbb”-“ccc”-”ddd”"><a href="#数组-“aaa”-”bbb”-“ccc”-”ddd”" class="headerlink" title="数组:        [{“aaa”:”bbb”},{“ccc”:”ddd”}]"></a>数组:        [{“aaa”:”bbb”},{“ccc”:”ddd”}]</h3><h2 id="JSON常用的两个方法："><a href="#JSON常用的两个方法：" class="headerlink" title="JSON常用的两个方法："></a>JSON常用的两个方法：</h2><h2 id="stringify-和-parse"><a href="#stringify-和-parse" class="headerlink" title="stringify() 和 parse()"></a>stringify() 和 parse()</h2><h2 id="stringify用法："><a href="#stringify用法：" class="headerlink" title="*stringify用法："></a>*stringify用法：</h2><h4 id="用法一：-把javascript对象转化成JSON格式"><a href="#用法一：-把javascript对象转化成JSON格式" class="headerlink" title="用法一： 把javascript对象转化成JSON格式:"></a>用法一： 把javascript对象转化成JSON格式:</h4><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> demo = &#123;<br>  <span class="hljs-string">"name"</span>:<span class="hljs-string">"aaa"</span>,<br>  <span class="hljs-string">"type"</span>:<span class="hljs-string">"bbb"</span> <br>&#125;<br><span class="hljs-keyword">var</span> jsonDemo = <span class="hljs-built_in">JSON</span>.stringify(demo);<br><span class="hljs-built_in">console</span>.log(jsonDemo);<br></code></pre></td></tr></table></figure><ul><li>得到结果：</li></ul><figure class="hljs highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<span class="hljs-attr">"name"</span>:<span class="hljs-string">"aaa"</span>,<span class="hljs-attr">"type"</span>:<span class="hljs-string">"bbb"</span>&#125;<br></code></pre></td></tr></table></figure><h4 id="用法二：把javascript对象转化成JSON格式，增加过滤，只留想要的数据"><a href="#用法二：把javascript对象转化成JSON格式，增加过滤，只留想要的数据" class="headerlink" title="用法二：把javascript对象转化成JSON格式，增加过滤，只留想要的数据"></a>用法二：把javascript对象转化成JSON格式，增加过滤，只留想要的数据</h4><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> demo = &#123;<br><span class="hljs-string">"name"</span>:<span class="hljs-string">"aaa"</span>,<br><span class="hljs-string">"sex"</span>:<span class="hljs-string">"boy"</span>,<br><span class="hljs-string">"age"</span>: <span class="hljs-number">20</span><br>&#125;<br><span class="hljs-keyword">var</span> jsonDemo = <span class="hljs-built_in">JSON</span>.stringify(demo,[<span class="hljs-string">"name"</span>]);<br><span class="hljs-built_in">console</span>.log(jsonDemo);<br></code></pre></td></tr></table></figure><ul><li>得到结果：</li></ul><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs josn">&#123;&quot;name&quot;:&quot;aaa&quot;&#125;<br></code></pre></td></tr></table></figure><h4 id="用法三：把javascript对象转化成JSON格式，并改变原有的值"><a href="#用法三：把javascript对象转化成JSON格式，并改变原有的值" class="headerlink" title="用法三：把javascript对象转化成JSON格式，并改变原有的值"></a>用法三：把javascript对象转化成JSON格式，并改变原有的值</h4><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> demo = &#123;<br><span class="hljs-string">"name"</span>:<span class="hljs-string">"aaa"</span>,<br><span class="hljs-string">"sex"</span>:<span class="hljs-string">"bbb"</span>,<br><span class="hljs-string">"type"</span>:<span class="hljs-string">"ccc"</span><br>&#125;<br><span class="hljs-keyword">var</span> jsonDemo = <span class="hljs-built_in">JSON</span>.stringify(demo,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key, value</span>) </span>&#123;<br><span class="hljs-keyword">switch</span>(key)&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">"name"</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">"a"</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">"sex"</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">"b"</span>;<br><span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> value;<br>&#125;<br>&#125;);<br><span class="hljs-built_in">console</span>.log(jsonDemo);<br></code></pre></td></tr></table></figure><ul><li>得到结果：</li></ul><figure class="hljs highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<span class="hljs-attr">"name"</span>:<span class="hljs-string">"a"</span>,<span class="hljs-attr">"sex"</span>:<span class="hljs-string">"b"</span>,<span class="hljs-attr">"type"</span>:<span class="hljs-string">"ccc"</span>&#125;<br></code></pre></td></tr></table></figure><h4 id="用法四：把javascript对象转化成JSON格式，并控制缩进和空白符"><a href="#用法四：把javascript对象转化成JSON格式，并控制缩进和空白符" class="headerlink" title="用法四：把javascript对象转化成JSON格式，并控制缩进和空白符"></a>用法四：把javascript对象转化成JSON格式，并控制缩进和空白符</h4><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> book = &#123;<br><span class="hljs-string">"title"</span>: <span class="hljs-string">"aaa"</span>,<br><span class="hljs-string">"type"</span>: <span class="hljs-string">"bbb"</span>,<br><span class="hljs-string">"page"</span>: <span class="hljs-number">50</span><br>&#125;<br><span class="hljs-keyword">var</span> jsonBook = <span class="hljs-built_in">JSON</span>.stringify(book,<span class="hljs-literal">null</span>,<span class="hljs-string">"$$"</span>);<br><span class="hljs-built_in">console</span>.log(jsonBook)<br></code></pre></td></tr></table></figure><ul><li>得到结果：</li><li><figure class="hljs highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br><span class="hljs-attr">"title"</span>: <span class="hljs-string">"aaa"</span>,<br><span class="hljs-attr">"type"</span>: <span class="hljs-string">"bbb"</span>,<br><span class="hljs-attr">"page"</span>: <span class="hljs-number">50</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>－该方法第三个参数如果为数字，那么就是每个属性前面缩进的字符数。</p><h2 id="parse-方法"><a href="#parse-方法" class="headerlink" title="parse()方法"></a>parse()方法</h2><h4 id="用法一：把JSON转化成javascript格式-用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。"><a href="#用法一：把JSON转化成javascript格式-用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。" class="headerlink" title="用法一：把JSON转化成javascript格式, 用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。"></a>用法一：把JSON转化成javascript格式, 用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。</h4><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> book = <span class="hljs-string">'&#123;"title":"aaa", "type":"bbb", "page":"50"&#125;'</span>;<br>  <span class="hljs-keyword">var</span> demo = <span class="hljs-built_in">JSON</span>.parse(book);<br>  <span class="hljs-built_in">console</span>.log(demo);<br></code></pre></td></tr></table></figure><ul><li>得到结果：</li></ul><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<span class="hljs-attr">title</span>: <span class="hljs-string">"aaa"</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">"bbb"</span>, <span class="hljs-attr">page</span>: <span class="hljs-string">"50"</span>&#125;<br></code></pre></td></tr></table></figure><h4 id="用法二：把JSON转化为javascript过程中，改变原有的值"><a href="#用法二：把JSON转化为javascript过程中，改变原有的值" class="headerlink" title="用法二：把JSON转化为javascript过程中，改变原有的值"></a>用法二：把JSON转化为javascript过程中，改变原有的值</h4><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> book = <span class="hljs-string">'&#123;"title":"aaa", "type":"bbb", "page":50&#125;'</span>;<br>  <span class="hljs-keyword">var</span> demo = <span class="hljs-built_in">JSON</span>.stringify(book);<br>  <span class="hljs-keyword">var</span> javascriptDemo = <span class="hljs-built_in">JSON</span>.parse(demo, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key, value</span>) </span>&#123;<br> <span class="hljs-keyword">switch</span> (key) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">"title"</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">"bbbbbb"</span>;<br><span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> value;<br> &#125;<br>  &#125;);<br>  <span class="hljs-built_in">console</span>.log(javascriptDemo);<br></code></pre></td></tr></table></figure><ul><li>得到结果：<figure class="hljs highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<span class="hljs-attr">"title"</span>:<span class="hljs-string">"aaa"</span>, <span class="hljs-attr">"type"</span>:<span class="hljs-string">"bbb"</span>, <span class="hljs-attr">"page"</span>:<span class="hljs-number">50</span>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;javascript中JSON语法有三种表示方法：&quot;&gt;&lt;a href=&quot;#javascript中JSON语法有三种表示方法：&quot; class=&quot;headerlink&quot; title=&quot;javascript中JSON语法有三种表示方法：&quot;&gt;&lt;/a&gt;javascript中
      
    
    </summary>
    
      <category term="js学习" scheme="http://www.wanglichao.top/categories/js%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="javascript" scheme="http://www.wanglichao.top/tags/javascript/"/>
    
      <category term="json" scheme="http://www.wanglichao.top/tags/json/"/>
    
      <category term="js" scheme="http://www.wanglichao.top/tags/js/"/>
    
      <category term="js基础" scheme="http://www.wanglichao.top/tags/js%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>做过的案例</title>
    <link href="http://www.wanglichao.top/2018/02/15/case-demo-2/"/>
    <id>http://www.wanglichao.top/2018/02/15/case-demo-2/</id>
    <published>2018-02-15T02:37:24.000Z</published>
    <updated>2018-11-12T18:44:54.699Z</updated>
    
    <content type="html"><![CDATA[<h2 id="豆瓣电影案例"><a href="#豆瓣电影案例" class="headerlink" title="豆瓣电影案例"></a><a href="http://www.wanglichao.top/douban-movie/">豆瓣电影案例</a></h2><h2 id="备忘录案例"><a href="#备忘录案例" class="headerlink" title="备忘录案例"></a><a href="http://www.wanglichao.top/todo/">备忘录案例</a></h2><h2 id="弹力运动案例"><a href="#弹力运动案例" class="headerlink" title="弹力运动案例"></a><a href="http://flex.wanglichao.top/" target="_blank" rel="noopener">弹力运动案例</a></h2><h2 id="开屏导航栏"><a href="#开屏导航栏" class="headerlink" title="开屏导航栏"></a><a href="http://spread.wanglichao.top/" target="_blank" rel="noopener">开屏导航栏</a></h2><h2 id="微金所案例"><a href="#微金所案例" class="headerlink" title="微金所案例"></a><a href="http://wjs.wanglichao.top/" target="_blank" rel="noopener">微金所案例</a></h2><h2 id="电商平台案例"><a href="#电商平台案例" class="headerlink" title="电商平台案例"></a><a href="http://www.wanglichao.top/vue-project-01/">电商平台案例</a></h2><h2 id="未完成的读书器"><a href="#未完成的读书器" class="headerlink" title="未完成的读书器"></a><a href="http://www.wanglichao.top/case_FictionReader/">未完成的读书器</a></h2><h2 id="商城后台管理系统案例"><a href="#商城后台管理系统案例" class="headerlink" title="商城后台管理系统案例"></a><a href="https://github.com/wangwangwanglichao/admin-v2-fe/tree/tag-product-02" target="_blank" rel="noopener">商城后台管理系统案例</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;豆瓣电影案例&quot;&gt;&lt;a href=&quot;#豆瓣电影案例&quot; class=&quot;headerlink&quot; title=&quot;豆瓣电影案例&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://www.wanglichao.top/douban-movie/&quot;&gt;豆瓣电影案例&lt;/a&gt;&lt;/h2&gt;&lt;h2
      
    
    </summary>
    
      <category term="案例" scheme="http://www.wanglichao.top/categories/%E6%A1%88%E4%BE%8B/"/>
    
    
      <category term="案例" scheme="http://www.wanglichao.top/tags/%E6%A1%88%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>JS编码方式</title>
    <link href="http://www.wanglichao.top/2018/02/15/JS_base/"/>
    <id>http://www.wanglichao.top/2018/02/15/JS_base/</id>
    <published>2018-02-15T02:37:24.000Z</published>
    <updated>2018-11-12T18:44:47.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS的编码解码"><a href="#JS的编码解码" class="headerlink" title="JS的编码解码"></a>JS的编码解码</h2><ul><li>1.escape/unescape(一般只有js支持,前端网页之间的数据传递的时候进行的中文编码和解码);</li><li>2.encodeURI/decodeURI;所有的语言都支持;</li><li>3.encodeURIComponent/decodeURIComponent;同上面,这个可以编译一些特殊字符,上面的不行,最常用的是这个;</li></ul><h2 id="ajax的异步和同步问题"><a href="#ajax的异步和同步问题" class="headerlink" title="ajax的异步和同步问题"></a>ajax的异步和同步问题</h2><ul><li>ajax任务:发送请求到收到响应主体内容(完整的HTTP事物);</li><li>ajax任务开始时发送请求开始(xhr.send());</li><li>同步请求下,绑定监听状态的事件(onreadystatechange)放在open之前可以监听1,4的状态,不可以放在send之后,因为send执行就已经状态为4, 结束了;</li><li>异步请求下,绑定监听状态的事件(onreadystatechange)放在open之前可以监听1,2,3,4的状态,放在open之后可以监听2,3,4的状态,</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JS的编码解码&quot;&gt;&lt;a href=&quot;#JS的编码解码&quot; class=&quot;headerlink&quot; title=&quot;JS的编码解码&quot;&gt;&lt;/a&gt;JS的编码解码&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;1.escape/unescape(一般只有js支持,前端网页之间的数据传递的时候进行的
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>node学习笔记</title>
    <link href="http://www.wanglichao.top/2018/02/15/node_base/"/>
    <id>http://www.wanglichao.top/2018/02/15/node_base/</id>
    <published>2018-02-15T02:37:24.000Z</published>
    <updated>2018-11-12T18:44:46.431Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-node-能够解决什么问题"><a href="#1-node-能够解决什么问题" class="headerlink" title="1.node 能够解决什么问题?"></a>1.node 能够解决什么问题?</h2><blockquote><p>node的首要目标是提供一种简单的,用于创建高性能服务器的开发工具;<br>Web服务器的瓶颈在于并发的用户量,对比java和PHP的实现方式;</p></blockquote><h2 id="2-node是什么"><a href="#2-node是什么" class="headerlink" title="2.node是什么?"></a>2.node是什么?</h2><blockquote><p>node.js是一个基于Chrome V8 引擎的JavaScript运行环境,让JavaScript的执行效率与底端的C语言的执行效率相近;<br>node.js使用了一个事件驱动,非阻塞式I/O的模型,使其轻量又高效;<br>node.js的包管理器npm,是全球最大的开源库生态系统;</p></blockquote><h2 id="3-node特点"><a href="#3-node特点" class="headerlink" title="3.node特点"></a>3.node特点</h2><h3 id="3-1-为什么JavaScript是单线程"><a href="#3-1-为什么JavaScript是单线程" class="headerlink" title="3.1 为什么JavaScript是单线程?"></a>3.1 为什么JavaScript是单线程?</h3><blockquote><p>这是由JavaScript这门脚本语言的用途决定的;<br>Web Worker并没有改变JavaScript单线程的本质;</p></blockquote><h3 id="3-2-浏览器模型"><a href="#3-2-浏览器模型" class="headerlink" title="3.2 浏览器模型"></a>3.2 浏览器模型</h3><blockquote><p>用户界面:包括地址栏,前进后退按钮,书签菜单等;<br>浏览器引擎: 在用户界面和呈现引擎之间传送指令;<br>呈现引擎:又称渲染引擎,也被成为浏览器内核,在线程方面又称UI线程;<br>网络:用于网络调用,比如: HTTP请求;<br>用户界面后端:用于绘制基本的窗口小部件,UI线程和JS共用一个线程;<br>JavaScript解析器:用于解析和执行JavaScript代码;<br>数据存储:这是持久层;浏览器需要在硬盘上保存各种数据,例如Cookie;</p></blockquote><h3 id="3-3-除了JS线程和UI线程之外的其它线程"><a href="#3-3-除了JS线程和UI线程之外的其它线程" class="headerlink" title="3.3 除了JS线程和UI线程之外的其它线程"></a>3.3 除了JS线程和UI线程之外的其它线程</h3><blockquote><p>浏览器事件触发线程<br>定时触发器线程<br>异步HTTP请求线程</p></blockquote><h3 id="3-4-任务队列"><a href="#3-4-任务队列" class="headerlink" title="3.4 任务队列"></a>3.4 任务队列</h3><blockquote><p>1.所有同步任务都是在主线程上执行,形成一个执行栈;<br>2.主线程之外,还存在一个任务队列,只要异步任务有了运行结果,就在任务队列中放置一个事件;<br>3.一旦执行栈中的所有同步任务执行完毕,系统就会读取任务队列,看看里面有哪些事件,哪些对应的异步任务,于是结束等待状态,进入执行栈,开始执行;<br>4.主线程不断重复上面的第三步;</p></blockquote><h3 id="3-5-EventLoop"><a href="#3-5-EventLoop" class="headerlink" title="3.5 EventLoop"></a>3.5 EventLoop</h3><blockquote><p>主线程从任务队列中读取事件,这个过程是循环不断的,所以整个的这种运行机制又称为EventLoop(事件循环);</p></blockquote><h3 id="3-6-node-js的EventLoop"><a href="#3-6-node-js的EventLoop" class="headerlink" title="3.6 node.js的EventLoop"></a>3.6 node.js的EventLoop</h3><blockquote><p>1.V8引擎解析JavaScript脚本;<br>2.解析后的代码,调用node API;<br>3.libuv库负责node API的执行,将不用的任务分配给不同的线程,形成一个EventLoop(事件循环),以异步的方式将任务的执行结果返回个V8引擎;<br>4.V8引擎再将结果返回给 用户;</p></blockquote><h3 id="3-7-同步与异步"><a href="#3-7-同步与异步" class="headerlink" title="3.7 同步与异步"></a>3.7 同步与异步</h3><blockquote><p>同步和异步关注的是消息通知机制;<br><code>同步</code>就是发出调用后,没有得到结果之前,该调用不返回,一旦调用返回,就得到返回值了。简而言之就是调用者主动等待这个调用的结果;<br><code>异步</code>则相反,调用者在发出调用后这个调用就直接返回了,所以没有返回结果,即:当一个异步过程调用发出后,调用者不会立刻得到结果,而是调用发出后,被调用者通过状态、通知或回调函数处理这个调用;</p></blockquote><h3 id="3-8-阻塞与非阻塞"><a href="#3-8-阻塞与非阻塞" class="headerlink" title="3.8 阻塞与非阻塞"></a>3.8 阻塞与非阻塞</h3><blockquote><p>阻塞和非阻塞关注的是程序在等待调用结果(消息/返回值)时的状态;<br><code>阻塞</code>调用是指调用结果返回之前,当前线程会被挂起,只有在得到结果之后才会返回;<br><code>非阻塞</code>调用是指在不能立刻得到结果之前,该调用不会阻塞当前线程;</p></blockquote><h3 id="3-9-组合"><a href="#3-9-组合" class="headerlink" title="3.9 组合"></a>3.9 组合</h3><p><strong><code>同步异步取决于被调用者,阻塞非阻塞取决于调用者;</code></strong></p><blockquote><p>同步阻塞: A给B打电话商量事情,通话过程中B考虑了1分钟(同步),A等待了1分钟什么也没干(阻塞);<br>异步阻塞: A给B打电话商量事情,B挂断电话1分钟后回复A(异步),A等待了1分钟什么也没干(阻塞);<br>同步非阻塞: A给B打电话商量事情,通话过程中B考虑了1分钟(同步),A在这1分钟里干了别的事情(非阻塞)<br>异步非阻塞: A给B打电话商量事情,B挂断电话1分钟后回复A(异步),A在这1分钟里干了别的事情(非阻塞);</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-node-能够解决什么问题&quot;&gt;&lt;a href=&quot;#1-node-能够解决什么问题&quot; class=&quot;headerlink&quot; title=&quot;1.node 能够解决什么问题?&quot;&gt;&lt;/a&gt;1.node 能够解决什么问题?&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;nod
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="node" scheme="http://www.wanglichao.top/tags/node/"/>
    
  </entry>
  
</feed>
