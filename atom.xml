<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>勇往直前</title>
  
  <subtitle>心有远方</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wanglichao.top/"/>
  <updated>2018-11-14T19:15:55.503Z</updated>
  <id>http://www.wanglichao.top/</id>
  
  <author>
    <name>王立超</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue学习笔记之条件语句</title>
    <link href="http://www.wanglichao.top/2018/11/15/Vue-if/"/>
    <id>http://www.wanglichao.top/2018/11/15/Vue-if/</id>
    <published>2018-11-15T00:00:00.000Z</published>
    <updated>2018-11-14T19:15:55.503Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue-js条件语句"><a href="#Vue-js条件语句" class="headerlink" title="Vue.js条件语句"></a>Vue.js条件语句</h2><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断:"></a>条件判断:</h3><h4 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h4><blockquote><p>条件判断使用v-if指令:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>    &lt;button @click=&quot;isShow=!isShow&quot;&gt;显示或隐藏&lt;/button&gt;<br>    &lt;p v-if=&quot;isShow&quot;&gt;能看到我吗?&lt;/p&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>    new Vue(&#123;<br>        el: &quot;#app&quot;,<br>        data: &#123;<br>            isShow: true<br>        &#125;<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p></blockquote><h4 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a>v-else</h4><blockquote><p>可以用v-else指令给v-if添加一个else块:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>&lt;div v-if=&quot;Math.random() &gt; 0.5&quot;&gt;<br>  哈哈<br>&lt;/div&gt;<br>&lt;div v-else&gt;<br>  呵呵<br>&lt;/div&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>new Vue(&#123;<br>  el: &apos;#app&apos;<br>&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p></blockquote><h4 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a>v-else-if</h4><blockquote><p>v-else-if 在2.1.0中新增,用作v-if的else-if块,可以链式使用;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>    &lt;div v-if=&quot;type === &apos;A&apos;&quot;&gt;<br>      A<br>    &lt;/div&gt;<br>    &lt;div v-else-if=&quot;type === &apos;B&apos;&quot;&gt;<br>      B<br>    &lt;/div&gt;<br>    &lt;div v-else-if=&quot;type === &apos;C&apos;&quot;&gt;<br>      C<br>    &lt;/div&gt;<br>    &lt;div v-else&gt;<br>      Not A/B/C<br>    &lt;/div&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure></p><p>v-else v-else-if v-else 必须跟在v-if或者v-else之后; </p></blockquote><h4 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h4><p>根据true或者false来展示或者隐藏元素;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div v-show=&quot;true&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure></p><h4 id="v-if-和-v-show-的区别"><a href="#v-if-和-v-show-的区别" class="headerlink" title="v-if 和 v-show 的区别"></a>v-if 和 v-show 的区别</h4><blockquote><p>在切换 v-if 块时，Vue.js 有一个局部编译/卸载过程，因为 v-if 之中的模板也可能包括数据绑定或子组件。v-if 是真实的条件渲染，因为它会确保条件块在切换当中合适地销毁与重建条件块内的事件监听器和子组件。</p><p>v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——在条件第一次变为真时才开始局部编译（编译会被缓存起来）。</p><p>相比之下，v-show 简单得多——元素始终被编译并保留，只是简单地基于 CSS 切换。</p><p>一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。</p><p>v-if 是动态添加，当值为 false 时，是完全移除该元素，即 dom 树中不存在该元素。</p><p>v-show 仅是隐藏 / 显示，值为 false 时，该元素依旧存在于 dom 树中。若其原有样式设置了 display: none 则会导致其无法正常显示。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Vue-js条件语句&quot;&gt;&lt;a href=&quot;#Vue-js条件语句&quot; class=&quot;headerlink&quot; title=&quot;Vue.js条件语句&quot;&gt;&lt;/a&gt;Vue.js条件语句&lt;/h2&gt;&lt;h3 id=&quot;条件判断&quot;&gt;&lt;a href=&quot;#条件判断&quot; class=&quot;head
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
      <category term="vue" scheme="http://www.wanglichao.top/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue学习笔记之循环语句</title>
    <link href="http://www.wanglichao.top/2018/11/15/Vue-for/"/>
    <id>http://www.wanglichao.top/2018/11/15/Vue-for/</id>
    <published>2018-11-15T00:00:00.000Z</published>
    <updated>2018-11-14T22:02:29.325Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue-js-循环语句"><a href="#Vue-js-循环语句" class="headerlink" title="Vue.js 循环语句"></a>Vue.js 循环语句</h2><blockquote><p>循环使用v-for指令;<br>v-for指令需要以 list in lists 形式的特殊语法,lists是源数据数组并且list时数组元素迭代的别名;<br>v-for可以绑定数据到数组来渲染一个列表;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>    &lt;ul&gt;<br>        &lt;li v-for=&quot;(arr, index) in array&quot; :key=&quot;index&quot;&gt;&#123;&#123;arr&#125;&#125;&lt;/li&gt;<br>    &lt;/ul&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>    new Vue(&#123;<br>        el: &quot;#app&quot;,<br>        data: &#123;<br>            array: [&apos;google&apos;, &apos;baidu&apos;, &apos;taobao&apos;, &apos;facebook&apos;]<br>        &#125;<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><p>也可以在模板中使用<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>    &lt;ul&gt;<br>        &lt;template v-for=&quot;arr in array&quot;&gt;<br>            &lt;li&gt;&#123;&#123;arr&#125;&#125;&lt;/li&gt;<br>        &lt;/template&gt;<br>    &lt;/ul&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>    new Vue(&#123;<br>        el: &quot;#app&quot;,<br>        data: &#123;<br>            array: [&apos;google&apos;, &apos;baidu&apos;, &apos;taobao&apos;, &apos;facebook&apos;]<br>        &#125;<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p></blockquote><h4 id="v-for-迭代对象"><a href="#v-for-迭代对象" class="headerlink" title="v-for 迭代对象"></a>v-for 迭代对象</h4><blockquote><p>v-for 可以通过一个对象的属性来迭代数据:<br>第一个参数是value,第二个参数(可选)是key,第三个参数(可选)是index;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>    &lt;ul&gt;<br>        &lt;template v-for=&quot;(value,key,index) in object&quot;&gt;<br>            &lt;li&gt;&#123;&#123;index&#125;&#125;:&#123;&#123;key&#125;&#125;: &#123;&#123;value&#125;&#125;&lt;/li&gt;<br>        &lt;/template&gt;<br>    &lt;/ul&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>    new Vue(&#123;<br>        el: &quot;#app&quot;,<br>        data: &#123;<br>            object: &#123;<br>                site1:&apos;google&apos;,<br>                site2:&apos;baidu&apos;,<br>                site3:&apos;taobao&apos;,<br>                site4:&apos;facebook&apos;<br>            &#125;<br>        &#125;<br>    &#125;)<br></code></pre></td></tr></table></figure></p><p>v-for可以直接迭代整数<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>  &lt;ul&gt;<br>    &lt;li v-for=&quot;n in 10&quot;&gt;<br>     &#123;&#123; n &#125;&#125;<br>    &lt;/li&gt;<br>  &lt;/ul&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure></p><p>嵌套迭代对象<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>    &lt;ul&gt;<br>        &lt;li v-for=&quot;(value,key,index) in object&quot;&gt;<br>            &lt;p v-if=&quot;typeof value != &apos;object&apos;&quot;&gt;&#123;&#123;value&#125;&#125; ===&gt; &#123;&#123;key&#125;&#125;&lt;/p&gt;<br>            &lt;p v-else&gt;嵌套对象:&#123;&#123;value&#125;&#125;&lt;/p&gt;<br>            &lt;ul v-if=&quot;typeof value == &apos;object&apos;&quot;&gt;<br>                &lt;li v-for=&quot;(val, key, index) in value&quot;&gt;<br>                    &#123;&#123;val&#125;&#125; ===&gt; &#123;&#123;key&#125;&#125;<br>                &lt;/li&gt;<br>            &lt;/ul&gt;<br>        &lt;/li&gt;<br>    &lt;/ul&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>    new Vue(&#123;<br>        el: &quot;#app&quot;,<br>        data: &#123;<br>            object: &#123;<br>                site1: &apos;谷歌&apos;,<br>                site2: &apos;百度&apos;,<br>                site3: &apos;淘宝&apos;,<br>                object2: &#123;<br>                    name1: &quot;京东&quot;,<br>                    name2: &quot;天猫&quot;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><p>乘法表<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>    &lt;div v-for=&quot;n in 9&quot;&gt;<br>        &lt;b v-for=&quot;m in n&quot;&gt;<br>            &#123;&#123;m&#125;&#125;*&#123;&#123;n&#125;&#125;=&#123;&#123;m*n&#125;&#125;<br>        &lt;/b&gt;<br>    &lt;/div&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>    new Vue(&#123;<br>        el: &quot;#app&quot;<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Vue-js-循环语句&quot;&gt;&lt;a href=&quot;#Vue-js-循环语句&quot; class=&quot;headerlink&quot; title=&quot;Vue.js 循环语句&quot;&gt;&lt;/a&gt;Vue.js 循环语句&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;循环使用v-for指令;&lt;br&gt;v-for
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
      <category term="vue" scheme="http://www.wanglichao.top/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue学习笔记之计算属性</title>
    <link href="http://www.wanglichao.top/2018/11/15/Vue-Computed/"/>
    <id>http://www.wanglichao.top/2018/11/15/Vue-Computed/</id>
    <published>2018-11-15T00:00:00.000Z</published>
    <updated>2018-11-14T22:46:56.149Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue-js计算属性"><a href="#Vue-js计算属性" class="headerlink" title="Vue.js计算属性"></a>Vue.js计算属性</h2><blockquote><p>计算属性关键词: computed<br>计算属性在处理一些复杂逻辑的时候是非常有用的<br>如: 反转字符串实例的计算属性方式实现:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>    &lt;p&gt;反转之前的字符串:----&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;<br>    &lt;p&gt;反转之后的字符串:----&gt;&#123;&#123;reverseMessage&#125;&#125;&lt;/p&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>    new Vue(&#123;<br>        el: &quot;#app&quot;,<br>        data: &#123;<br>            message: &quot;Hello, World!!!&quot;<br>        &#125;,<br>        computed: &#123;<br>            reverseMessage() &#123;<br>                return this.message.split(&quot;&quot;).reverse().join(&apos;&apos;);<br>            &#125;<br>        &#125;<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><p>实例中声明了一个计算属性 reversedMessage ;<br>提供的函数将用作属性 vm.reversedMessage 的 getter ;<br>vm.reversedMessage 依赖于 vm.message;<br>在 vm.message 发生改变时，vm.reversedMessage 也会更新;</p></blockquote><h5 id="computed-对比-methods"><a href="#computed-对比-methods" class="headerlink" title="computed 对比 methods"></a>computed 对比 methods</h5><blockquote><p>我们可以使用 methods 来替代 computed，效果上两个都是一样的，&gt; 但是 computed 是基于它的依赖缓存，只有相关依赖发生改变时才会重新取值。<br>而使用 methods ，在重新渲染的时候，函数总会重新调用执行。<br>可以说使用 computed 性能会更好，但是如果不希望缓存，可以使用 methods 属性。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">methods: &#123;<br>  reversedMessage2: function () &#123;<br>    return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="computed-setter"><a href="#computed-setter" class="headerlink" title="computed setter"></a>computed setter</h3><blockquote><p>computed 属性默认只有getter,不过在需要时也可以提供一个setter;<br>在运行vm.site=”xxx”;的时候,setter会被调用,vm.name和vm.url也会被对应更新;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>    &lt;p&gt;&#123;&#123; site &#125;&#125;&lt;/p&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>    const vm = new Vue(&#123;<br>        el: &quot;#app&quot;,<br>        data: &#123;<br>            name: &quot;心有远方&quot;,<br>            url: &quot;http://www.wanglichao.top&quot;<br>        &#125;,<br>        computed: &#123;<br>            site: &#123;<br>                get() &#123;<br>                    return this.name + &quot; &quot; + this.url;<br>                &#125;,<br>                set(newValue) &#123;<br>                    let names = newValue.split(&quot; &quot;);<br>                    this.name = names[0];<br>                    this.url = names[names.length - 1]<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;);<br>    vm.site = &quot;勇往直前 www.wanglichao.top&quot;;<br>    document.write(&apos;name: &apos; + vm.name);<br>    document.write(&apos;&lt;br&gt;&apos;);<br>    document.write(&apos;url: &apos; + vm.url);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Vue-js计算属性&quot;&gt;&lt;a href=&quot;#Vue-js计算属性&quot; class=&quot;headerlink&quot; title=&quot;Vue.js计算属性&quot;&gt;&lt;/a&gt;Vue.js计算属性&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;计算属性关键词: computed&lt;br&gt;计算属性
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
      <category term="vue" scheme="http://www.wanglichao.top/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue-ModuleLanguage</title>
    <link href="http://www.wanglichao.top/2018/11/15/Vue-ModuleLanguage/"/>
    <id>http://www.wanglichao.top/2018/11/15/Vue-ModuleLanguage/</id>
    <published>2018-11-14T22:02:49.000Z</published>
    <updated>2018-11-14T14:02:49.419Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>React学习笔记之ajax</title>
    <link href="http://www.wanglichao.top/2018/11/15/React-ajax/"/>
    <id>http://www.wanglichao.top/2018/11/15/React-ajax/</id>
    <published>2018-11-14T21:28:01.000Z</published>
    <updated>2018-11-13T22:07:53.489Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-AJAX"><a href="#React-AJAX" class="headerlink" title="React AJAX"></a>React AJAX</h2><blockquote><p>React组件的数据可以通过componentDidMount方法中的ajax来获取,当从服务端获取数据时可以将数据存储在state中,再用this.setState()方法重新渲染UI.<br>当使用异步加载数据的时候,在组件卸载前使用componentWillUnmount来取消未完成的请求;<br>以下实例演示了获取 Github 用户最新 gist 共享描述:</p></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class UserGist extends React.Component &#123;<br>        constructor(props) &#123;<br>            super(props);<br>            this.state = &#123;<br>                username : &apos;&apos;,<br>                lastGistUrl: &apos;&apos;<br>            &#125;;<br>        &#125;<br><br>        componentDidMount() &#123;<br>            this.serverRequest = $.get(this.props.source, res =&gt; &#123;<br>                let lastGist = res[0];<br>                this.setState(&#123;<br>                    username: lastGist.owner.login,<br>                    lastGistUrl: lastGist.html_url<br>                &#125;);<br>            &#125;);<br>        &#125;<br><br>        componentWillUnmount() &#123;<br>            this.serverRequest.abort();<br>        &#125;<br><br>        render() &#123;<br>            return (<br>                &lt;div&gt;<br>                    &#123;this.state.username&#125; 用户最新的Gist共享地址:<br>                    &lt;a href=&#123;this.state.lastGistUrl&#125;&gt;&#123;this.state.lastGistUrl&#125;&lt;/a&gt;<br>                &lt;/div&gt;<br>            )<br>        &#125;<br>    &#125;<br><br>    ReactDOM.render(<br>        &lt;UserGist source=&quot;https://api.github.com/users/octocat/gists&quot; /&gt;,<br>        document.getElementById(&quot;example&quot;)<br>    )<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-AJAX&quot;&gt;&lt;a href=&quot;#React-AJAX&quot; class=&quot;headerlink&quot; title=&quot;React AJAX&quot;&gt;&lt;/a&gt;React AJAX&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;React组件的数据可以通过componentDi
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之表单与事件</title>
    <link href="http://www.wanglichao.top/2018/11/15/React-form-and-events/"/>
    <id>http://www.wanglichao.top/2018/11/15/React-form-and-events/</id>
    <published>2018-11-14T21:28:01.000Z</published>
    <updated>2018-11-13T22:07:47.291Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Reactor-表单与事件"><a href="#Reactor-表单与事件" class="headerlink" title="Reactor 表单与事件"></a>Reactor 表单与事件</h2><blockquote><p>HTML表单元素与Reactor中的其它DOM元素有所不同,因为表单元素生来就保留一些内部状态;<br>在HTML当中,像input,textarea和select这类表单元素会维持自身状态,并根据用户输入进行更新,但在React中,可变的状态通常保存在组件的状态属性中,并且只能用setState()方法进行更新;</p></blockquote><h5 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h5><blockquote><p>在实例中设置了输入框input的值value={this.state.data},在输入框的值发生变化时我们可以更新state,我们可以使用onChange事件来监听input的变化,并修改state;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class Content extends React.Component &#123;<br>        render() &#123;<br>            return (<br>                &lt;div&gt;<br>                    &lt;input type=&quot;text&quot;<br>                           value=&#123;this.props.myDataProp&#125;<br>                           onChange=&#123;this.props.updateStateProp&#125;<br>                    /&gt;<br>                    &lt;h4&gt;&#123;this.props.myDataProp&#125;&lt;/h4&gt;<br>                &lt;/div&gt;<br>            )<br>        &#125;<br>    &#125;<br>    class HelloMessage extends React.Component &#123;<br>        constructor(props) &#123;<br>            super(props);<br>            this.state = &#123;value: &quot;Hello, React!&quot;&#125;;<br>        &#125;<br>        handleChange(e) &#123;<br>            this.setState(&#123;value: e.target.value&#125;);<br>        &#125;<br>        render() &#123;<br>            let value = this.state.value;<br>            return (<br>                &lt;div&gt;<br>                    &lt;Content myDataProp=&#123;value&#125;<br>                             updateStateProp=&#123;(e)=&gt;this.handleChange(e)&#125;<br>                    /&gt;<br>                &lt;/div&gt;<br>            )<br>        &#125;<br>    &#125;<br>    ReactDOM.render(<br>        &lt;HelloMessage /&gt;,<br>        document.getElementById(&apos;example&apos;)<br>    )<br></code></pre></td></tr></table></figure></p><p>上面的代码将渲染出一个值为Hello React! 的input元素,并通过onChange事件影响更新用户输入的值</p></blockquote><h5 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h5><blockquote><p>在以下实例中,将演示如何在子组件上使用表单,onChange方法将触发state的更新,并将更新的值传递到子组件的输入框的value上来重新渲染界面;<br>需要在父组件通过创建事件句柄(handleChange),并作为prop(updateStateProp)传递到子组件上;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs undefined">// 创建一个Content组件:<br>    class Content extends React.Component &#123;<br>        render() &#123;<br>            return (<br>                &lt;div&gt;<br>                    &lt;input type=&quot;text&quot;<br>                           value=&#123;this.props.myDataProp&#125;<br>                           onChange=&#123;this.props.updateStateProp&#125;<br>                    /&gt;<br>                    &lt;h4&gt;&#123;this.props.myDataProp&#125;&lt;/h4&gt;<br>                &lt;/div&gt;<br>            )<br>        &#125;<br>    &#125;<br><br>    // 创建HelloMessage组件<br>    class HelloMessage extends React.Component &#123;<br>        constructor(props) &#123;<br>            super(props);<br>            this.state = &#123;<br>                value: &apos;Hello, React&apos;<br>            &#125;;<br>        &#125;<br><br>        handleChange(e) &#123;<br>            this.setState(&#123;<br>                value: e.target.value<br>            &#125;)<br>        &#125;<br><br>        render() &#123;<br>            let value = this.state.value;<br>            return (<br>                &lt;div&gt;<br>                    &lt;Content myDataProp=&#123;value&#125;<br>                             updateStateProp=&#123;e=&gt;this.handleChange(e)&#125;<br>                    /&gt;<br>                &lt;/div&gt;<br>            )<br>        &#125;<br>    &#125;<br><br>    ReactDOM.render(<br>        &lt;HelloMessage/&gt;,<br>        document.getElementById(&quot;example&quot;)<br>    )<br></code></pre></td></tr></table></figure></p></blockquote><h5 id="Select下拉菜单"><a href="#Select下拉菜单" class="headerlink" title="Select下拉菜单"></a>Select下拉菜单</h5><blockquote><p>在React中,不使用selected属性,而是在根select标签上用value属性来表示选中项;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class LikeForm extends React.Component &#123;<br>        constructor(props) &#123;<br>            super(props);<br>            this.state = &#123;<br>                value: &apos;coconut&apos;<br>            &#125;<br>        &#125;<br>        handleChange(e) &#123;<br>            this.setState(&#123;<br>                value: e.target.value<br>            &#125;)<br>        &#125;<br>        handleSubmit(e) &#123;<br>            alert(&quot;你最喜欢的网站是&quot; + this.state.value);<br>            e.preventDefault();<br>        &#125;<br>        render() &#123;<br>            return (<br>                &lt;form onSubmit=&#123;(e)=&gt;this.handleSubmit(e)&#125;&gt;<br>                    &lt;label&gt;<br>                        &lt;select value=&#123;this.state.value&#125;<br>                                onChange=&#123;e=&gt;this.handleChange(e)&#125;<br>                        &gt;<br>                            &lt;option value=&quot;谷歌&quot;&gt;Google&lt;/option&gt;<br>                            &lt;option value=&quot;脸书&quot;&gt;Facebook&lt;/option&gt;<br>                            &lt;option value=&quot;淘宝&quot;&gt;Taobao&lt;/option&gt;<br>                            &lt;option value=&quot;草榴&quot;&gt;Caoliu&lt;/option&gt;<br>                        &lt;/select&gt;<br>                    &lt;/label&gt;<br>                    &lt;input type=&quot;submit&quot; value=&apos;提交&apos;/&gt;<br>                &lt;/form&gt;<br>            )<br>        &#125;<br>    &#125;<br>    ReactDOM.render(<br>        &lt;LikeForm /&gt;,<br>        document.getElementById(&apos;example&apos;)<br>    )<br></code></pre></td></tr></table></figure></p></blockquote><h5 id="多个表单"><a href="#多个表单" class="headerlink" title="多个表单"></a>多个表单</h5><blockquote><p>当需要处理多个input元素时,可以通过给每个元素添加一个name属性,来让处理函数根据event.target.name的值来选择做什么:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class Reservation extends React.Component &#123;<br>        constructor(props) &#123;<br>            super(props);<br>            this.state = &#123;<br>                isGoing: true,<br>                numberOfGuests: 10<br>            &#125;;<br>        &#125;<br>        handleInputChange(e) &#123;<br>            const target = e.target;<br>            const value = target.type === &apos;checkbox&apos; ? target.checked : target.value;<br>            const name = target.name;<br>            this.setState(&#123;<br>                [name]: value<br>            &#125;)<br>        &#125;<br>        render() &#123;<br>            return (<br>                &lt;form&gt;<br>                    &lt;label&gt;<br>                        是或否:<br>                        &lt;input type=&quot;checkbox&quot;<br>                               name=&quot;isGoing&quot;<br>                               checked=&#123;this.state.isGoing&#125;<br>                               onChange=&#123;e=&gt;this.handleInputChange(e)&#125;<br>                        /&gt;<br>                    &lt;/label&gt;<br>                    &lt;br/&gt;<br>                    &lt;label&gt;<br>                        统计数:<br>                        &lt;input type=&quot;number&quot;<br>                               name=&quot;numberOfGuests&quot;<br>                               value=&#123;this.state.numberOfGuests&#125;<br>                               onChange=&#123;e=&gt;this.handleInputChange(e)&#125;<br>                        /&gt;<br>                    &lt;/label&gt;<br>                &lt;/form&gt;<br>            )<br>        &#125;<br>    &#125;<br>    ReactDOM.render(<br>        &lt;Reservation /&gt;,<br>        document.getElementById(&quot;example&quot;)<br>    )<br></code></pre></td></tr></table></figure></p></blockquote><h5 id="React事件"><a href="#React事件" class="headerlink" title="React事件"></a>React事件</h5><blockquote><p>通过onClick事件来修改数据:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class Message extends React.Component &#123;<br>        constructor(props) &#123;<br>            super(props);<br>            this.state = &#123;<br>                value: &quot;Hello, React!&quot;<br>            &#125;;<br>        &#125;<br>        handleChangeValue() &#123;<br>            this.setState(&#123;<br>                value: &quot;Hello, Vue!&quot;<br>            &#125;)<br>        &#125;<br>        render() &#123;<br>            return (<br>                &lt;div&gt;<br>                    &lt;button onClick=&#123;()=&gt;this.handleChangeValue()&#125;&gt;点我&lt;/button&gt;<br>                    &lt;h4&gt;&#123;this.state.value&#125;&lt;/h4&gt;<br>                &lt;/div&gt;<br>            )<br>        &#125;<br>    &#125;<br>    ReactDOM.render(<br>        &lt;Message /&gt;,<br>        document.getElementById(&quot;example&quot;)<br>    )<br></code></pre></td></tr></table></figure></p><p>当需要从子组件中更新父组件的state时,需要在父组件通过创建事件句柄(handleChange),并作为prop(updateStateProp)传递到子组件上;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class Content extends React.Component &#123;<br>        render() &#123;<br>            return(<br>                &lt;div&gt;<br>                    &lt;button onClick=&#123;this.props.updateStateProp&#125;&gt;button&lt;/button&gt;<br>                    &lt;h4&gt;&#123;this.props.myDataProp&#125;&lt;/h4&gt;<br>                &lt;/div&gt;<br>            )<br>        &#125;<br>    &#125;<br>    class Message extends React.Component &#123;<br>        constructor(props) &#123;<br>            super(props);<br>            this.state = &#123;<br>                value: &quot;Hello React!!!&quot;<br>            &#125;;<br>        &#125;<br>        handleChange() &#123;<br>            this.setState(&#123;<br>                value: &quot;My App is Success!!!&quot;<br>            &#125;)<br>        &#125;<br>        render() &#123;<br>            return (<br>                &lt;div&gt;<br>                    &lt;Content updateStateProp=&#123;()=&gt;this.handleChange()&#125;<br>                             myDataProp=&#123;this.state.value&#125;<br>                    /&gt;<br>                &lt;/div&gt;<br>            )<br>        &#125;<br>    &#125;<br>    ReactDOM.render(<br>        &lt;Message /&gt;,<br>        document.getElementById(&quot;example&quot;)<br>    )<br></code></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Reactor-表单与事件&quot;&gt;&lt;a href=&quot;#Reactor-表单与事件&quot; class=&quot;headerlink&quot; title=&quot;Reactor 表单与事件&quot;&gt;&lt;/a&gt;Reactor 表单与事件&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;HTML表单元素与Reac
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之渲染</title>
    <link href="http://www.wanglichao.top/2018/11/14/React-refs/"/>
    <id>http://www.wanglichao.top/2018/11/14/React-refs/</id>
    <published>2018-11-14T06:10:05.000Z</published>
    <updated>2018-11-13T22:18:10.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-Refs"><a href="#React-Refs" class="headerlink" title="React Refs"></a>React Refs</h2><blockquote><p>React支持一种非常特殊的属性 ref , 可以用来绑定到render()输出的任何组件上;<br>这个特殊的属性允许引用render()返回的相应的支撑实例(backing instance),这样就可以确保在任何时间都能拿到正确的实例;</p><h5 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h5><p>绑定一个ref属性到render的返回值上:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;input ref=&quot;myInput&quot;/&gt;<br></code></pre></td></tr></table></figure></p></blockquote><p>在其他代码中,通过this.refs获取支撑实例:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">let input = this.refs.myInput;<br>let inputValue = input.value;<br></code></pre></td></tr></table></figure></p><h4 id="完整实例"><a href="#完整实例" class="headerlink" title="完整实例"></a>完整实例</h4><blockquote><p>可以通过使用this来获取当前React组件,或使用ref来获取组件的引用;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class MyComponent extends React.Component &#123;<br>  handleClick() &#123;<br>    // 使用原生的DOM API获取焦点<br>    this.refs.myInput.focus();<br>  &#125;<br>  render() &#123;<br>    // 当组件插入到DOM后，ref属性添加一个组件的引用于到this.refs<br>    return (<br>      &lt;div&gt;<br>        &lt;input type=&quot;text&quot; ref=&quot;myInput&quot; /&gt;<br>        &lt;input<br>          type=&quot;button&quot;<br>          value=&quot;点我输入框获取焦点&quot;<br>          onClick=&#123;this.handleClick.bind(this)&#125;<br>        /&gt;<br>      &lt;/div&gt;<br>    );<br>  &#125;<br>&#125;<br> <br>ReactDOM.render(<br>  &lt;MyComponent /&gt;,<br>  document.getElementById(&apos;example&apos;)<br>);<br></code></pre></td></tr></table></figure></p><p>也可以使用getDOMNode()方法获取DOM元素;</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-Refs&quot;&gt;&lt;a href=&quot;#React-Refs&quot; class=&quot;headerlink&quot; title=&quot;React Refs&quot;&gt;&lt;/a&gt;React Refs&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;React支持一种非常特殊的属性 ref , 可以
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之组件API</title>
    <link href="http://www.wanglichao.top/2018/11/14/React-component-API/"/>
    <id>http://www.wanglichao.top/2018/11/14/React-component-API/</id>
    <published>2018-11-13T21:28:01.000Z</published>
    <updated>2018-11-13T22:08:05.749Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-组件-API"><a href="#React-组件-API" class="headerlink" title="React 组件 API"></a>React 组件 API</h2><blockquote><p>React 组件API的7个方法:</p><ul><li>设置状态:setState</li><li>替换状态: replaceState</li><li>设置属性: setProps</li><li>替换属性: replaceState</li><li>强制更新: forceUpdate</li><li>获取DOM节点: findDOMNode</li><li>判断组件挂在状态： isMounted</li></ul></blockquote><h3 id="设置状态-setState"><a href="#设置状态-setState" class="headerlink" title="设置状态: setState"></a>设置状态: setState</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">setState(object nextState[, function callback])<br></code></pre></td></tr></table></figure><h5 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h5><pre><code>&gt; * nextState 将要设置新的状态,该状态会和当前的state合并;&gt; * callback 可选参数,回调函数,该函数会在setState设置成功,且组件重新渲染后调用;</code></pre><blockquote><p>合并nextState和当前state,并重新渲染组件,setState是React事件处理函数中和请求回调函数中触发UI更新的主要方法;</p></blockquote><h5 id="关于setState"><a href="#关于setState" class="headerlink" title="关于setState"></a>关于setState</h5><blockquote><p>不能在组件内部通过this.state修改状态,因为该状态会在调用setState()后被替换;<br>setState()并不会立即改变this.state,而是创建一个即将处理的state;<br>setState()并不一定是同步的,为了提升性能React会批量执行state和DOM渲染;<br>setState()总是会触发一次组件重绘,除非在shouldComponentUpdate()中实现了一些条件渲染逻辑;<br>点击计数器:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class Counter extends React.Component &#123;<br>        constructor(props) &#123;<br>            super(props);<br>            this.state = &#123;<br>                clickCount: 0<br>            &#125;;<br>            this.handleClick = this.handleClick.bind(this);<br>        &#125;<br><br>        handleClick() &#123;<br>            this.setState(function (state) &#123;<br>                return &#123;clickCount: state.clickCount + 1&#125;;<br>            &#125;)<br>        &#125;<br><br>        render() &#123;<br>            return(<br>                &lt;div&gt;<br>                    &lt;button onClick=&#123;this.handleClick&#125;&gt;点我&lt;/button&gt;<br>                    &lt;h3&gt;点击次数为&#123;this.state.clickCount&#125;&lt;/h3&gt;<br>                &lt;/div&gt;<br>            )<br>        &#125;<br>    &#125;<br><br>    ReactDOM.render(<br>        &lt;Counter /&gt;,<br>        document.getElementById(&quot;example&quot;)<br>    )<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="替换状态-replaceState"><a href="#替换状态-replaceState" class="headerlink" title="替换状态: replaceState"></a>替换状态: replaceState</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">replaceState(object nextState[, function callback])<br></code></pre></td></tr></table></figure><blockquote><p>replaceState() 方法与setState() 类似,但是方法只会保留nextState中的状态,原state不在nextState中的状态都会被删除</p></blockquote><h3 id="设置属性-setProps"><a href="#设置属性-setProps" class="headerlink" title="设置属性: setProps"></a>设置属性: setProps</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">setProps(object nextProps[, function callback])<br></code></pre></td></tr></table></figure><pre><code>&gt; * nextProps 将要设置的新属性,该状态会和当前的props合并;&gt; * callback 可选参数,回调函数,该函数会在setProps设置成功,且组件重新渲染后调用;</code></pre><blockquote><p>props相当于组件的数据流,它总是会从父组件向下传递至所有的子组件中.<br>当和一个外部的javascript应用集成时,我们可能需要向组件传递数据或者通知React.render() 组件需要重新渲染,可以使用setProps();<br>更新组件,我可以在节点上再次调用React.render(),也可以通过setProps() 方法改变组件属性,触发组件重新渲染;</p></blockquote><h3 id="替换属性-replaceProps"><a href="#替换属性-replaceProps" class="headerlink" title="替换属性: replaceProps"></a>替换属性: replaceProps</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">replaceProps(object nextProps[, function callback])<br></code></pre></td></tr></table></figure><blockquote><p>replaceProps()方法与setProps()方法类似,但是它会删除原有的props;</p></blockquote><h3 id="强制更新-forceUpdate"><a href="#强制更新-forceUpdate" class="headerlink" title="强制更新: forceUpdate"></a>强制更新: forceUpdate</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">forceUpdate([function callback])<br></code></pre></td></tr></table></figure><blockquote><ul><li>callback 可选参数,回调函数,该函数会在组件render()方法调用后调用;<br>forceUpdate()方法会使组件调用自身的render() 方法重新渲染组件,组件的子组件也会调用自己的render() ,但是,组件重新渲染时,依然会读取this.props和this.state,如果状态没有改变,那么React只会更新DOM;<br>forceUpdate()方式适用于this.props和this.state之外的组件重绘(如:修改了this.state后), 通过该方法通知React需要调用render();<br>一般来说,应该尽量避免使用forceUpdate(),而仅从this.props和this.state中读取状态并由React触发render调用;</li></ul></blockquote><h3 id="获取DOM节点-findDOMNode"><a href="#获取DOM节点-findDOMNode" class="headerlink" title="获取DOM节点: findDOMNode"></a>获取DOM节点: findDOMNode</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">DOMElement findDOMNode<br></code></pre></td></tr></table></figure><blockquote><ul><li>返回值: DOM元素DOMElement<br>如果组件已经挂载到DOM中,该方法返回对应的本地浏览器DOM元素<br>当render()返回null或false时,this.findDOMNode()也会返回null.<br>从DOM中读取值得时候，该方法很有用，如：获取表单字段的值和做一些DOM操作；</li></ul></blockquote><h3 id="判断组件挂载状态：-isMounted"><a href="#判断组件挂载状态：-isMounted" class="headerlink" title="判断组件挂载状态： isMounted"></a>判断组件挂载状态： isMounted</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">bool isMounted()<br></code></pre></td></tr></table></figure><blockquote><ul><li>返回值： true或false，表示组件是否已经挂载到DOM中<br>isMounted()方法用于判断组件是否已挂在到DOM中<br>可以使用该方法保证来setState（）和forceUpdate（）在异步场景下的调用不会出错。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-组件-API&quot;&gt;&lt;a href=&quot;#React-组件-API&quot; class=&quot;headerlink&quot; title=&quot;React 组件 API&quot;&gt;&lt;/a&gt;React 组件 API&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;React 组件API的7个方法:
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之列表和keys</title>
    <link href="http://www.wanglichao.top/2018/11/14/React-list/"/>
    <id>http://www.wanglichao.top/2018/11/14/React-list/</id>
    <published>2018-11-13T21:28:01.000Z</published>
    <updated>2018-11-13T22:08:14.160Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-列表-和-keys"><a href="#React-列表-和-keys" class="headerlink" title="React 列表 和 keys"></a>React 列表 和 keys</h2><blockquote><p>我们可以使用javascript的map()方法来创建数字列表:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">const numbers = [1, 2, 3, 4, 5];<br>    const listItem = numbers.map(number =&gt;<br>        &lt;li&gt;&#123;number&#125;&lt;/li&gt;<br>    );<br>    ReactDOM.render(<br>        &lt;ul&gt;<br>            &#123;listItem&#125;<br>        &lt;/ul&gt;,<br>        document.getElementById(&quot;example&quot;)<br>    )<br></code></pre></td></tr></table></figure></p><p>我们可以将以上实例重构成一个组件,组件接收数组参数,每个列表元素分配一个key,不然会出现警告<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs undefined">let numbers = [1, 2, 3, 4, 5];<br><br>   function NumberList(props) &#123;<br>       const numbers = props.numbers;<br>       const listItems = numbers.map(number =&gt;<br>           &lt;li key=&#123;number&#125;&gt;&#123;number&#125;&lt;/li&gt;<br>       );<br>       return (<br>           &lt;ul&gt;<br>               &#123;listItems&#125;<br>           &lt;/ul&gt;<br>       )<br>   &#125;<br><br>   ReactDOM.render(<br>       &lt;NumberList numbers=&#123;numbers&#125;/&gt;,<br>       document.getElementById(&quot;example&quot;)<br>   )<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a>Keys</h3><blockquote><p>keys可以在DOM中的某些元素被增加或删除的时候,帮助React识别哪些元素发生了变化,因此应当给数组中每一个元素赋予一个确定的标识.<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;li key=&#123;number.toString()&#125;&gt;<br></code></pre></td></tr></table></figure></p><p>一个元素的key最好是这个元素在列表中拥有的独一无二的字符串,通常,我们使用来自数据的ID作为元素的key;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">const todoItems = todos.map(todo =&gt;<br>&lt;li key=&#123;todo.id&#125;&gt;<br>&#123;todo.text&#125;<br>&lt;/li&gt;<br>);<br></code></pre></td></tr></table></figure></p><p>当元素没有确定的id时,可以使用它的序列号索引index作为它的key<br> <figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">const todoItems = todos.map((todo, index) =&gt;<br>&lt;li key=&#123;index&#125;&gt;<br>&#123;todo.text&#125;<br>&lt;/li&gt;<br>);<br></code></pre></td></tr></table></figure></p><p>如果列表可以重新排序,我们不建议使用索引来进行排序,因为这回导致渲染变得很慢</p></blockquote><h3 id="用Keys-提取组件"><a href="#用Keys-提取组件" class="headerlink" title="用Keys 提取组件"></a>用Keys 提取组件</h3><blockquote><p>元素的key只有在它和它的兄弟节点对比时才有意义;<br>比方说,如果需要提取一个ListItem组件,你应该把key保存在数组中的<listitem>元素上,而不是放在ListItem组件中的li元素上<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs undefined">function ListItem(props) &#123;<br>  // 这里不需要指定key<br>  return &lt;li&gt;&#123;props.value&#125;&lt;/li&gt;;<br>&#125;<br>function NumberList(props) &#123;<br>  const numbers = props.numbers;<br>  const listItems = numbers.map((number) =&gt;<br>    // 建议将key指定在这里,数组的上下文里;<br>    &lt;ListItem key=&#123;number.toString()&#125;<br>              value=&#123;number&#125; /&gt;<br>  );<br>  return (<br>    &lt;ul&gt;<br>      &#123;listItems&#125;<br>    &lt;/ul&gt;<br>  );<br>&#125;<br>const numbers = [1, 2, 3, 4, 5];<br>ReactDOM.render(<br>  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,<br>  document.getElementById(&apos;example&apos;)<br>);<br></code></pre></td></tr></table></figure></listitem></p><p>在map()方法的内部调用元素时,最好随时记得为每一个元素加上独一无二的key;</p></blockquote><h3 id="元素的key在它与它的兄弟元素之间应该是唯一"><a href="#元素的key在它与它的兄弟元素之间应该是唯一" class="headerlink" title="元素的key在它与它的兄弟元素之间应该是唯一"></a>元素的key在它与它的兄弟元素之间应该是唯一</h3><blockquote><p>数组元素中使用的key在其兄弟之间应该是独一无二的,然而,它们不需要是全局唯一的,当生成两个不同的数组时,可以使用相同的key;<br>key会作为给React的提示,但不会传递给你的组件.如果你的组件中需要使用和key相同的值,请将其作为属性传递;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">const content = posts.map((post) =&gt; <br>&lt;Post key=&#123;post.id&#125;<br>  id=&#123;post.id&#125;<br>  title=&#123;post.title&#125; /&gt;<br>);<br></code></pre></td></tr></table></figure></p><p>上面例子中,Post组件可以读出props.id,但是不能读出props.key;</p></blockquote><h3 id="在JSX中嵌入map"><a href="#在JSX中嵌入map" class="headerlink" title="在JSX中嵌入map()"></a>在JSX中嵌入map()</h3><blockquote><p>JSX允许在大括号中嵌入任何表达式,所以我们可以在map()中这样使用:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">function NumberList(props)&#123;<br> const nubers = props.numbers;<br>reutnr (<br>&lt;ul&gt;<br>&#123;numbers.map(number) =&gt;<br>&lt;ListItem key=&#123;number.toString()&#125; value=&#123;number&#125; /&gt;<br>&lt;/ul&gt;<br>)<br> &#125;<br></code></pre></td></tr></table></figure></p><p>这么做有时可以使你的代码更清晰,但有时这种风格会被滥用,就像在javascript中一样,何时需要为了可读性提取出一个变量,这完全取决于你自己,但请记住,如果一个map() 嵌套了太多层级,那你就可以提取出组件;</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-列表-和-keys&quot;&gt;&lt;a href=&quot;#React-列表-和-keys&quot; class=&quot;headerlink&quot; title=&quot;React 列表 和 keys&quot;&gt;&lt;/a&gt;React 列表 和 keys&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;我们可以使
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之生命周期</title>
    <link href="http://www.wanglichao.top/2018/11/14/React-life/"/>
    <id>http://www.wanglichao.top/2018/11/14/React-life/</id>
    <published>2018-11-13T21:28:01.000Z</published>
    <updated>2018-11-13T22:08:00.075Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-生命周期"><a href="#React-生命周期" class="headerlink" title="React 生命周期"></a>React 生命周期</h2><blockquote><p>组件的生命周期可分成三个状态:</p><ul><li>Mounting: 已插入真实DOM;</li><li>Updating: 正在被重新渲染;</li><li>Unmounting: 已移出真实DOM;</li></ul></blockquote><p><strong>生命周期的方法有</strong>：</p><blockquote><ul><li>componentWillComponent 在渲染前调用,在客户端也在服务端;</li><li>componentDidMount 在第一次渲染后调用,只在客户端.  之后已经生成了对应的DOM结构,可以通过this.getDOMNode()来进行访问,如果你想和其他javascript框架一起使用,可以在这个方法中调用setTimeout,setInterval或者发送ajax请求等操作(防止异步操作阻塞UI);</li><li>componentWillReceiveProps 在组件接收到一个新的prop(更新后)时被调用,这个方法在初始化render时不会被调用;</li><li>shouldComponentUpdate 返回一个布尔值,在组件接收到新的props或者state时被调用,在初始化时或者使用forceUpdate时不被调用;<br>componentWillUpdate 在组件接收到新的props或者state,但还没有render时调用,在初始化时不会被调用;</li><li>componentDidUpdate 在组件完成更新后立即调用,在初始化时不会被调用;</li><li>componentWillUnmount 在组件从DOM中移除之前立刻被调用;<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs undefined">componentWillMount() &#123;<br>            console.log(&apos;Component Will Mount&apos;);<br>        &#125;<br>        componentDidMount() &#123;<br>            console.log(&apos;Component Did Mount&apos;);<br>        &#125;<br>        componentWillReceiveProps(newProps) &#123;<br>            console.log(&apos;Component Will Receive Props&apos;);<br>        &#125;<br>        shouldComponentUpdate(newProps, newState) &#123;<br>            console.log(&apos;Should Component Update&apos;);<br>            return true;<br>        &#125;<br>        componentWillUpdate(nextProps, nextState) &#123;<br>            console.log(&apos;Component Will Update&apos;);<br>        &#125;<br>        componentDidUpdate(prevProps, prevState) &#123;<br>            console.log(&apos;Component Did Update&apos;);<br>        &#125;<br>        componentWillUnmount() &#123;<br>            console.log(&apos;Component Will Unmount&apos;);<br>        &#125;<br></code></pre></td></tr></table></figure></li></ul></blockquote><p><img src="/2018/11/14/React-life/React-life1.png" alt="生命周期1"><br><img src="/2018/11/14/React-life/React-life2.jpg" alt="生命周期2"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-生命周期&quot;&gt;&lt;a href=&quot;#React-生命周期&quot; class=&quot;headerlink&quot; title=&quot;React 生命周期&quot;&gt;&lt;/a&gt;React 生命周期&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;组件的生命周期可分成三个状态:&lt;/p&gt;
&lt;ul&gt;

      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之this相关</title>
    <link href="http://www.wanglichao.top/2018/11/13/React-This/"/>
    <id>http://www.wanglichao.top/2018/11/13/React-This/</id>
    <published>2018-11-12T21:28:01.000Z</published>
    <updated>2018-11-12T19:49:32.557Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在JavaScript中，this对象是运行时基于函数的执行环境（也就是上下文）绑定的。</p><p>从 react 中的 demo 说起<br>Facebook一次更新react时，将es6中的class加入了组件的创建方式当中。Facebook也推荐组件创建使用通过定义一个继承自 React.Component 的class来定义一个组件类。官方的demo：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class LikeButton extends React.Component &#123;<br>  constructor() &#123;<br>    super();<br>    this.state = &#123;<br>      liked: false<br>    &#125;;<br>    this.handleClick = this.handleClick.bind(this);<br>  &#125;<br>  handleClick() &#123;<br>    this.setState(&#123;liked: !this.state.liked&#125;);<br>  &#125;<br>  render() &#123;<br>    const text = this.state.liked ? &apos;liked&apos; : &apos;haven\&apos;t liked&apos;;<br>    return (<br>      &lt;div onClick=&#123;this.handleClick&#125;&gt;<br>        You &#123;text&#125; this. Click to toggle.<br>      &lt;/div&gt;<br>    );<br>  &#125;<br>&#125;<br>ReactDOM.render(<br>  &lt;LikeButton /&gt;,<br>  document.getElementById(&apos;example&apos;)<br>);<br></code></pre></td></tr></table></figure></p><p>上面的demo中有大量this的使用，在 class LikeButton extends React.Component 中我们是声明该class，因为this具体是由其上下文决定的，因此在类定义中我们无法得知this用法。<br>相当于是new了上面定义的类，首先调用 constructor() 函数， this.state 的this上下文就是该实例对象；<br>同理，render() 函数中 this.state.liked 的this上下文也是该对象。<br>问题在于 onClick={this.handleClick} ，获取该函数引用是没有问题，这里的this上下文就是该对象。</p><p>这时问题来了，在原来 React.createClass 中， handleClick() 在onClick事件触发的时候，会自动绑定到LikeButton实例上，这时候该函数的this的上下文就是该实例。<br>不过在ES6的class的写法中，Facebook取消了自动绑定，实例化LikeButton后，handleClick()的上下文是div的支撑实例（ backing instance ），而 handleClick() 原本要绑定的上下文是LikeButton的实例。<br>对于该问题，我们有多种解决方案。<br><strong>使用 bind() 函数改变 this 的上下文</strong><br>可以在class声明中的constructor()函数中使用：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">this.handleClick = this.handleClick.bind(this);<br></code></pre></td></tr></table></figure></p><p>该方法是一个bind()绑定，多次使用。在该方法中，我们在声明该实例后，可以在该实例任何地方使用 handleClick() 函数，并且该 handleClick() 函数的this的上下文都是LikeButton实例对象。<br>除此我们也可以在具体使用该函数的地方绑定this的上下文到LikeButton实例对象，代码如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div onClick=&#123;this.handleClick.bind(this)&#125;&gt;<br>   Click to toggle.<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure></p><p>这种方法需要我们每次使用bind()函数绑定到组件对象上。<br><strong>es6的箭头函数</strong><br>es6中新加入了箭头函数=&gt;，箭头函数除了方便之外还有而一个特征就是将函数的this绑定到其定义时所在的上下文。这个特征也可以帮助我们解决这个问题。使用如下代码：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div onClick=&#123;() =&gt; this.handleClick()&#125;&gt;<br>  Click to toggle.<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure></p></blockquote><p>这样该 this.handleClick() 的上下文就会被绑定到 LikeButton 的实例对象上。</p><blockquote><p><strong>this的总结</strong><br>this 的本质就是：this跟作用域无关的，只跟执行上下文有关。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在JavaScript中，this对象是运行时基于函数的执行环境（也就是上下文）绑定的。&lt;/p&gt;
&lt;p&gt;从 react 中的 demo 说起&lt;br&gt;Facebook一次更新react时，将es6中的class加入了组件的创建方式当中。Faceboo
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之条件渲染</title>
    <link href="http://www.wanglichao.top/2018/11/13/React-condition-render/"/>
    <id>http://www.wanglichao.top/2018/11/13/React-condition-render/</id>
    <published>2018-11-12T21:28:01.000Z</published>
    <updated>2018-11-12T21:28:17.363Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-条件渲染"><a href="#React-条件渲染" class="headerlink" title="React 条件渲染"></a>React 条件渲染</h2><blockquote><p>在React中，你可以创建不同的组件来封装你需要的各种行为，然后还可以根据应用的状态变化仅渲染其中的一部分。<br>React中的条件渲染和JavaScript中的一致，使用JavaScript操作符if或条件运算符来创建表示当前状态的元素，然后让React根据它们来更新UI。<br>一个根据用户是否登录来显示其中之一的组件：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs undefined">function UserGreeting() &#123;<br>        return &lt;h1&gt;欢迎登录&lt;/h1&gt;<br>    &#125;<br><br>    function GuestGreeting() &#123;<br>        return &lt;h1&gt;请先注册&lt;/h1&gt;<br>    &#125;<br><br>    function Greeting(props) &#123;<br>        const isLoggedIn = props.isLoggedIn;<br>        if (isLoggedIn) &#123;<br>            return &lt;UserGreeting /&gt;<br>        &#125;<br>        return &lt;GuestGreeting /&gt;<br>    &#125;<br><br>    ReactDOM.render(<br>        // true or false<br>        &lt;Greeting isLoggedIn=&#123;false&#125;/&gt;,<br>        document.getElementById(&apos;example&apos;)<br>    )<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="元素变量"><a href="#元素变量" class="headerlink" title="元素变量"></a>元素变量</h3><blockquote><p>你可以使用变量来储存元素，它可以帮助你有条件的渲染组件中的一部分，而其他的部分不会更改。<br>创建一个LoginControl的有状态的组件，根据当前的状态来渲染<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class LoginControl extends React.Component &#123;<br>        constructor(props) &#123;<br>            super(props);<br>            this.state = &#123;<br>                isLoggedIn: false<br>            &#125;;<br>            this.handleLoginClick = this.handleLoginClick.bind(this);<br>            this.handleLogoutClick = this.handleLogoutClick.bind(this);<br>        &#125;<br>        handleLoginClick() &#123;<br>            this.setState(&#123;<br>                isLoggedIn: true<br>            &#125;)<br>        &#125;<br>        handleLogoutClick() &#123;<br>            this.setState(&#123;<br>                isLoggedIn: false<br>            &#125;)<br>        &#125;<br>        render() &#123;<br>            const isLoggedIn = this.state.isLoggedIn;<br>            let button = null;<br>            if (isLoggedIn) &#123;<br>                button = &lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125;/&gt;<br>            &#125; else &#123;<br>                button = &lt;LoginButton onClick=&#123;this.handleLoginClick&#125;/&gt;<br>            &#125;<br>            return (<br>                &lt;div&gt;<br>                    &lt;Greeting isLoggedIn=&#123;isLoggedIn&#125;/&gt;<br>                    &#123;button&#125;<br>                &lt;/div&gt;<br>            )<br>        &#125;<br>    &#125;<br><br>    function UserGreeting() &#123;<br>        return &lt;h1&gt;欢迎登录&lt;/h1&gt;<br>    &#125;<br><br>    function GuestGreeting() &#123;<br>        return &lt;h1&gt;请先登录或者注册&lt;/h1&gt;<br>    &#125;<br><br>    function Greeting(props) &#123;<br>        const isLoggedIn = props.isLoggedIn;<br>        if (isLoggedIn) &#123;<br>            return &lt;UserGreeting /&gt;<br>        &#125;<br>        return &lt;GuestGreeting /&gt;<br>    &#125;<br><br>    function LoginButton(props) &#123;<br>        return (<br>            &lt;button onClick=&#123;props.onClick&#125;&gt;登录&lt;/button&gt;<br>        )<br>    &#125;<br><br>    function LogoutButton(props) &#123;<br>        return (<br>            &lt;button onClick=&#123;props.onClick&#125;&gt;退出&lt;/button&gt;<br>        )<br>    &#125;<br><br>    ReactDOM.render(<br>        &lt;LoginControl /&gt;,<br>        document.getElementById(&quot;example&quot;)<br>    )<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="与运算符-amp-amp"><a href="#与运算符-amp-amp" class="headerlink" title="与运算符 &amp;&amp;"></a>与运算符 &amp;&amp;</h3><blockquote><p>你可以通过花括号包裹代码在JSX中嵌入任何表达式，也包括JavaScript的逻辑与&amp;&amp;，它可以方便的条件渲染一个元素<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs undefined">function Mailbox(props) &#123;<br>        const unreadMessages = props.unreadMessages;<br>        return (<br>            &lt;div&gt;<br>                &lt;h1&gt;Hello!&lt;/h1&gt;<br>                &#123;unreadMessages.length &gt; 0 &amp;&amp;<br>                    &lt;h2&gt;<br>                        您有&#123;unreadMessages.length&#125;条未读消息<br>                    &lt;/h2&gt;<br>                &#125;<br>            &lt;/div&gt;<br>        )<br>    &#125;<br><br>    const messages = [&apos;react&apos;, &apos;vue&apos;, &apos;javascript&apos;];<br>    ReactDOM.render(<br>        &lt;Mailbox unreadMessages=&#123;messages&#125;/&gt;,<br>        document.getElementById(&quot;example&quot;)<br>    )<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h3><p>条件渲染的另一种方法是使用JavaScript的条件运算符。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">something ? true : false<br></code></pre></td></tr></table></figure></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">render() &#123;<br>  const isLoggedIn = this.state.isLoggedIn;<br>  return (<br>    &lt;div&gt;<br>      &#123;isLoggedIn ? (<br>        &lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125; /&gt;<br>      ) : (<br>        &lt;LoginButton onClick=&#123;this.handleLoginClick&#125; /&gt;<br>      )&#125;<br>    &lt;/div&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在极少数情况下，你可能希望隐藏组件，即使它被其他组件渲染。让 render 方法返回 null 而不是它的渲染结果即可实现。<br>组件的 render 方法返回 null 并不会影响该组件生命周期方法的回调。例如，componentWillUpdate 和 componentDidUpdate 依然可以被调用。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-条件渲染&quot;&gt;&lt;a href=&quot;#React-条件渲染&quot; class=&quot;headerlink&quot; title=&quot;React 条件渲染&quot;&gt;&lt;/a&gt;React 条件渲染&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在React中，你可以创建不同的组件来封装你需要的
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之安装</title>
    <link href="http://www.wanglichao.top/2018/11/13/React-install/"/>
    <id>http://www.wanglichao.top/2018/11/13/React-install/</id>
    <published>2018-11-12T21:28:01.000Z</published>
    <updated>2018-11-13T14:08:41.095Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-安装"><a href="#React-安装" class="headerlink" title="React 安装"></a>React 安装</h2><h3 id="React-可以直接下载使用-也可以使用CDN"><a href="#React-可以直接下载使用-也可以使用CDN" class="headerlink" title="React 可以直接下载使用,也可以使用CDN;"></a>React 可以直接下载使用,也可以使用CDN;</h3><blockquote><p>Staticfile CDN 的 React CDN 库:</p></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;script src=&quot;https://cdn.staticfile.org/react/16.4.0/umd/react.development.js&quot;&gt;&lt;/script&gt;<br>&lt;script src=&quot;https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js&quot;&gt;&lt;/script&gt;<br>&lt;!-- 生产环境中不建议使用 --&gt;<br>&lt;script src=&quot;https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js&quot;&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><blockquote><p>官方提供的DCN地址:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;script src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt;<br>&lt;script src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt;<br>&lt;!-- 生产环境中不建议使用 --&gt;<br>&lt;script src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><p>输出Hello,React!的实例<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;meta charset=&quot;UTF-8&quot; /&gt;<br>&lt;title&gt;Hello React!&lt;/title&gt;<br>&lt;script src=&quot;https://cdn.staticfile.org/react/16.4.0/umd/react.development.js&quot;&gt;&lt;/script&gt;<br>&lt;script src=&quot;https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js&quot;&gt;&lt;/script&gt;<br>&lt;script src=&quot;https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js&quot;&gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br> <br>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;<br>&lt;script type=&quot;text/babel&quot;&gt;<br>ReactDOM.render(<br>    &lt;h1&gt;Hello,React!&lt;/h1&gt;,<br>    document.getElementById(&apos;app&apos;)<br>);<br>&lt;/script&gt;<br> <br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure></p><p>实例中需要3个库 react / react-DOM / babel</p><ul><li>react -&gt; React的核心库</li><li>react-dom -&gt; 提供与DOM相关的功能</li><li>babel -&gt;babel可以将ES6代码转为ES5代码,这就可以在不支持ES6的浏览器上执行React代码,babel内嵌了对JSX的支持<br>注意:如果需要使用JSX,则script标签的type属性需要设置为text/babel</li></ul></blockquote><h3 id="通过npm使用React"><a href="#通过npm使用React" class="headerlink" title="通过npm使用React"></a>通过npm使用React</h3><p>国内简易使用cnpm代替npm安装package;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">$ npm install -g cnpm --registry=https://registry.npm.taobao.org<br>$ npm config set registry https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure></p><blockquote><p>这样就可以使用cnpm命令来安装模块了<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">$ cnpm install [packagename]<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="使用create-react-app-快速构建React开发环境"><a href="#使用create-react-app-快速构建React开发环境" class="headerlink" title="使用create-react-app 快速构建React开发环境"></a>使用create-react-app 快速构建React开发环境</h3><blockquote><p>create-react-app 是来自于facebook，通过该命令我们无需配置就能快速构建React开发环境。<br>create-react-app 自动创建的项目是基于Webpack + ES6.<br>执行以下命令创建项目：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">$ cnpm install -g create-react-app<br>$ create-react-app [my-app]<br>$ cd [my-app]<br>$ npm start<br></code></pre></td></tr></table></figure></p><p>在浏览器中打开<a href="http://localhost:3000，就会呈现项目页面" target="_blank" rel="noopener">http://localhost:3000，就会呈现项目页面</a></p></blockquote><p>React 代码的书写格式和以前的 JS 有很大的不同，下面通过对这段代码进行分析了解一下他。</p><p>以前使用JS 定义一个变量使用 var 现在用 const：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">const div = document.createElement(&apos;div&apos;);<br></code></pre></td></tr></table></figure><p>ReactDOM.render(…) 是渲染方法，所有的 js,html 都可通过它进行渲染绘制，他又两个参数，内容和渲染目标 js 对象。</p><p>内容就是要在渲染目标中显示的东西，可以是一个React 部件，也可以是一段HTML或TEXT文本。渲染目标JS对象，就是一个DIV或TABEL,或TD 等HTML的节点对象。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">ReactDOM.render(&lt;App /&gt;, div);<br></code></pre></td></tr></table></figure><p>unmountComponentAtNode() 这个方法是解除渲染挂载，作用和 render 刚好相反，也就清空一个渲染目标中的 React 部件或 html 内容。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">ReactDOM.unmountComponentAtNode(div);<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-安装&quot;&gt;&lt;a href=&quot;#React-安装&quot; class=&quot;headerlink&quot; title=&quot;React 安装&quot;&gt;&lt;/a&gt;React 安装&lt;/h2&gt;&lt;h3 id=&quot;React-可以直接下载使用-也可以使用CDN&quot;&gt;&lt;a href=&quot;#React-
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之介绍</title>
    <link href="http://www.wanglichao.top/2018/11/13/React-anzhuang/"/>
    <id>http://www.wanglichao.top/2018/11/13/React-anzhuang/</id>
    <published>2018-11-12T21:28:01.000Z</published>
    <updated>2018-11-12T18:44:36.212Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React介绍"><a href="#React介绍" class="headerlink" title="React介绍"></a>React介绍</h2><blockquote><p>React是一个 用于构建用户界面的javascript库<br>React主要用于构建UI,很多人认为React是MVC中的V(视图)<br>React起源于Facebook的内部项目,用来架设Instagram的网站,并于2013年开源<br>React拥有较高的性能,代码逻辑非常简单,越来越多的人开始关注和使用它</p></blockquote><h3 id="React特点"><a href="#React特点" class="headerlink" title="React特点"></a>React特点</h3><blockquote><p>1.声明式设计 - React采用声明范式,可以轻松描述应用<br>2.高效  - React通过对DOM的模拟,最大限度的减少与DOM的交互<br>3.灵活 - React可以与已知的库或框架很好的配合<br>4.JSX - JSX是JavaScript语法的扩展,React开发不一定使用JSX,但建议使用它<br>5.组件 - 通过React构建组件,使得代码更加容易得到复用,能够很好的应用在大项目的开发中<br>6.单向响应的数据流 - React实现了单向响应的数据流,从而减少了重复代码,这也是它为什么比传统数据绑定更简单</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React介绍&quot;&gt;&lt;a href=&quot;#React介绍&quot; class=&quot;headerlink&quot; title=&quot;React介绍&quot;&gt;&lt;/a&gt;React介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;React是一个 用于构建用户界面的javascript库&lt;br&gt;Reac
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之组件</title>
    <link href="http://www.wanglichao.top/2018/11/13/React-component/"/>
    <id>http://www.wanglichao.top/2018/11/13/React-component/</id>
    <published>2018-11-12T21:28:01.000Z</published>
    <updated>2018-11-12T18:44:37.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-组件"><a href="#React-组件" class="headerlink" title="React 组件"></a>React 组件</h2><blockquote><p>封装一个组件:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">// 使用函数定义一个组件<br>function Message(props) &#123;<br>    return &lt;h1&gt;Hello React!&lt;/h1&gt;;<br>&#125;<br> <br>const element = &lt;Message /&gt;;<br> <br>ReactDOM.render(<br>    element,<br>    document.getElementById(&apos;example&apos;)<br>);<br></code></pre></td></tr></table></figure></p><p>也可以使用ES6 class来定义一个组件<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class Welcome extends React.Component &#123;<br>  render() &#123;<br>    return &lt;h1&gt;Hello React!&lt;/h1&gt;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>const element = <hellomessage> 为用户自定义的组件。<br>注意，原生 HTML 元素名以小写字母开头，而自定义的 React 类名以大写字母开头，比如 HelloMessage 不能写成 helloMessage。除此之外还需要注意组件类只能包含一个顶层标签，否则也会报错。</hellomessage></p><p>如果需要向组件传递参数，可以使用 this.props 对象<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;script type=&quot;text/babel&quot;&gt;<br>        function HelloMessage(props) &#123;<br>            return &lt;h1&gt;Hello, &#123;props.name&#125;!&lt;/h1&gt;<br>        &#125;<br>        const element = &lt;HelloMessage name=&apos;React&apos; /&gt;;<br>        ReactDOM.render(<br>            element,<br>            document.getElementById(&apos;box&apos;)<br>        )<br>    &lt;/script&gt;<br></code></pre></td></tr></table></figure></p><p>以上实例中name属性通过proops.name来获取<br><code>注意，在添加属性时， class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字。</code></p></blockquote><h3 id="复合组件"><a href="#复合组件" class="headerlink" title="复合组件"></a>复合组件</h3><blockquote><p>我们可以通过创建多个组件来合成一个组件，即把组件的不同功能点进行分离。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs undefined">function Name(props) &#123;<br>            return &lt;h1&gt;网站名称: &#123;props.name&#125;&lt;/h1&gt;<br>        &#125;<br>        function Url(props) &#123;<br>            return &lt;h1&gt;网站地址: &#123;props.url&#125;&lt;/h1&gt;<br>        &#125;<br>        function Nickname(props) &#123;<br>            return &lt;h1&gt;网站小名: &#123;props.nickname&#125;&lt;/h1&gt;<br>        &#125;<br>        function App() &#123;<br>            return (<br>                &lt;div&gt;<br>                    &lt;Name name=&apos;勇往直前&apos;/&gt;<br>                    &lt;Url url=&quot;http://www.wanglichao.top&quot;/&gt;<br>                    &lt;Nickname nickname=&quot;心有远方&quot;/&gt;<br>                &lt;/div&gt;<br>            )<br>        &#125;<br>        ReactDOM.render(<br>            &lt;App /&gt;,<br>            document.getElementById(&apos;box&apos;)<br>        )<br></code></pre></td></tr></table></figure></p><p>实例中 App 组件使用了 Name、Url 和 Nickname 组件来输出对应的信息。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-组件&quot;&gt;&lt;a href=&quot;#React-组件&quot; class=&quot;headerlink&quot; title=&quot;React 组件&quot;&gt;&lt;/a&gt;React 组件&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;封装一个组件:&lt;br&gt;&lt;figure class=&quot;hljs hi
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之JSX</title>
    <link href="http://www.wanglichao.top/2018/11/13/React-JSX/"/>
    <id>http://www.wanglichao.top/2018/11/13/React-JSX/</id>
    <published>2018-11-12T21:28:01.000Z</published>
    <updated>2018-11-12T18:44:41.021Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-JSX"><a href="#React-JSX" class="headerlink" title="React JSX"></a>React JSX</h2><blockquote><p>React 使用JSX来替代常规的JavaScript;<br>JSX是一个看起来像XML的JavaScript语法扩展;<br>我们不需要一定使用JSX,但它有以下优点:</p><ul><li>JSX执行更快,因为它在编译为JavaScript代码后进行了优化;</li><li>它是安全类型的,在编译过程中就能发现错误;</li><li>使用JSX编写模板更加简单快速</li></ul></blockquote><h3 id="使用JSX"><a href="#使用JSX" class="headerlink" title="使用JSX"></a>使用JSX</h3><blockquote><p>JSX使用起来类似HTML;<br>JSX代码可以放在一个独立的文件上,例如:创建一个js文件,然后在HTML中引入该js文件;<br> <figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined"> ReactDOM.render(<br>    &lt;h1&gt;Hello React!&lt;/h1&gt;,<br>    document.getElementById(&quot;box&quot;)<br>);<br></code></pre></td></tr></table></figure></p></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;body&gt;<br>    &lt;!--创建一个JS文件引入--&gt;<br>    &lt;div id=&quot;box&quot;&gt;&lt;/div&gt;<br>    &lt;script type=&quot;text/babel&quot; src=&quot;hello_react.js&quot;&gt;&lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h3 id="JavaScript表达式"><a href="#JavaScript表达式" class="headerlink" title="JavaScript表达式"></a>JavaScript表达式</h3><blockquote><p>我们可以在 JSX 中使用 JavaScript 表达式。表达式写在花括号 {} 中<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">let i = 1;<br>ReactDOM.render(<br>    &lt;h1&gt;&#123;i == 1 ? &apos;True&apos; : &apos;False&apos;&#125;&lt;/h1&gt;,<br>    document.getElementById(&quot;box&quot;)<br>);<br></code></pre></td></tr></table></figure></p><p>在 JSX 中不能使用 if else 语句，但可以使用 conditional (三元运算) 表达式来替代。以下实例中如果变量 i 等于 1 浏览器将输出 true, 如果修改 i 的值，则会输出 false.</p></blockquote><h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><blockquote><p>React 推荐使用内联样式。我们可以使用 camelCase 语法来设置内联样式. React 会在指定元素数字后自动添加 px<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">let myStyle = &#123;<br>    fontSize: 50,<br>    color: &apos;#ff0000&apos;<br>&#125;;<br><br>ReactDOM.render(<br>    &lt;h1 style=&#123;myStyle&#125;&gt;我是菜鸟&lt;/h1&gt;,<br>    document.getElementById(&quot;box&quot;)<br>);<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><blockquote><p>注释需要写在花括号中<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">ReactDOM.render(<br>    &lt;div&gt;<br>    &lt;h1&gt;哈哈哈&lt;/h1&gt;<br>    &#123;/*注释...*/&#125;<br>     &lt;/div&gt;,<br>    document.getElementById(&apos;example&apos;)<br>);<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>JSX 允许在模板中插入数组，数组会自动展开所有成员：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">let arr = [<br>    &lt;h1&gt;我是菜鸟&lt;/h1&gt;,<br>    &lt;h2&gt;正在学习&lt;/h2&gt;,<br>    &lt;h3&gt;不仅技术&lt;/h3&gt;,<br>    &lt;h4&gt;更是梦想&lt;/h4&gt;<br>];<br><br>ReactDOM.render(<br>    &lt;h1&gt;&#123;arr&#125;&lt;/h1&gt;,<br>    document.getElementById(&quot;box&quot;)<br>);<br></code></pre></td></tr></table></figure></p><h3 id="HTML标签-VS-React组件"><a href="#HTML标签-VS-React组件" class="headerlink" title="HTML标签 VS React组件"></a>HTML标签 VS React组件</h3><blockquote><p>React 可以渲染 HTML 标签 (strings) 或 React 组件 (classes)。<br>要渲染 HTML 标签，只需在 JSX 里使用小写字母的标签名。<br>React 的 JSX 使用大、小写的约定来区分本地组件的类和 HTML 标签。<br>要渲染 React 组件，只需创建一个大写字母开头的本地变量。</p><p>注意:<br>由于 JSX 就是 JavaScript，一些标识符像 class 和 for 不建议作为 XML 属性名。作为替代，React DOM 使用 className 和 htmlFor 来做对应的属性。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-JSX&quot;&gt;&lt;a href=&quot;#React-JSX&quot; class=&quot;headerlink&quot; title=&quot;React JSX&quot;&gt;&lt;/a&gt;React JSX&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;React 使用JSX来替代常规的JavaScript;&lt;
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之State</title>
    <link href="http://www.wanglichao.top/2018/11/13/React-State/"/>
    <id>http://www.wanglichao.top/2018/11/13/React-State/</id>
    <published>2018-11-12T21:28:01.000Z</published>
    <updated>2018-11-12T18:44:38.821Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-State"><a href="#React-State" class="headerlink" title="React State"></a>React State</h2><blockquote><p>React 把组件看成是一个状态机(StateMachines).通过与用户的交互,实现不同的状态,然后渲染UI,让用户界面和数据保持一致;<br>React里,只需更新组件的state,然后根据新的state重新渲染用户界面,而不需要去操作DOM;</p></blockquote><h3 id="将生命周期方法添加到类中"><a href="#将生命周期方法添加到类中" class="headerlink" title="将生命周期方法添加到类中"></a>将生命周期方法添加到类中</h3><blockquote><p>在具有许多组件的应用程序中,在销毁时释放组件所占用的资源非常重要;<br>每当组件第一次加载到DOM中的时候,在React中被称为挂载;<br>当这个组件生成的DOM被移除的时候,在React中被称为卸载;</p></blockquote><h3 id="数据自顶向下流动"><a href="#数据自顶向下流动" class="headerlink" title="数据自顶向下流动"></a>数据自顶向下流动</h3><blockquote><p>父组件或子组件都不能知道某个组件是有状态还是无状态，并且它们不应该关心某组件是被定义为一个函数还是一个类。</p><p>这就是为什么状态通常被称为局部或封装。 除了拥有并设置它的组件外，其它组件不可访问。</p><p>通常被称为自顶向下或单向数据流。 任何状态始终由某些特定组件所有，并且从该状态导出的任何数据或 UI 只能影响树中下方的组件;</p><p>在 React 应用程序中，组件是有状态还是无状态被认为是可能随时间而变化的组件的实现细节。</p><p>我们可以在有状态组件中使用无状态组件，也可以在无状态组件中使用有状态组件。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-State&quot;&gt;&lt;a href=&quot;#React-State&quot; class=&quot;headerlink&quot; title=&quot;React State&quot;&gt;&lt;/a&gt;React State&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;React 把组件看成是一个状态机(Sta
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之JSX</title>
    <link href="http://www.wanglichao.top/2018/11/13/Vue-Start/"/>
    <id>http://www.wanglichao.top/2018/11/13/Vue-Start/</id>
    <published>2018-11-12T21:28:01.000Z</published>
    <updated>2018-11-14T13:32:17.567Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之事件处理</title>
    <link href="http://www.wanglichao.top/2018/11/13/React-Events/"/>
    <id>http://www.wanglichao.top/2018/11/13/React-Events/</id>
    <published>2018-11-12T21:28:01.000Z</published>
    <updated>2018-11-12T19:41:39.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-事件处理"><a href="#React-事件处理" class="headerlink" title="React 事件处理"></a>React 事件处理</h2><blockquote><p>React 元素的事件处理和DOM元素类似，但是语法上有有点不同；</p><ul><li>React 事件绑定属性的命名采用驼峰式写法，而不是小写；</li><li>如果采用JSX的语法你需要传入一个函数作为事件处理函数，而不是一个字符串（DOM元素的写法）；<br>HTML写法：<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;button onclick=&quot;todoSomething()&quot;&gt;button&lt;/button&gt;<br></code></pre></td></tr></table></figure></li></ul><p>React写法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;button onClick=&quot;todoSomething&quot;&gt;button&lt;/button&gt;<br></code></pre></td></tr></table></figure></p><p>在React中另一个不同是不能使用返回false的方式阻止默认行为，而必须<br>明确的使用preventDefault；<br>使用React的时候通常不需要使用addEventListener为一个已创建的DOM元素添加监视器，仅仅需要在这个元素渲染的时候提供一个监视器；<br>当使用ES6 class语法来定义一个组件的时候，事件处理器会成为类的一个方法。例如：Toggle组件渲染一个让用户切换开关状态的按钮：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class Toggle extends React.Component &#123;<br>        constructor(props) &#123;<br>            super(props);<br>            this.state = &#123;<br>                isToggle: true<br>            &#125;;<br>            this.handleClick = this.handleClick.bind(this);<br>        &#125;<br><br>        handleClick() &#123;<br>            this.setState(prevState =&gt; (&#123;<br>                isToggle: !prevState.isToggle<br>            &#125;))<br>        &#125;<br><br>        render() &#123;<br>            return (<br>                &lt;button onClick=&#123;this.handleClick&#125;&gt;<br>                    &#123;this.state.isToggle ? &apos;ON&apos; : &apos;OFF&apos;&#125;<br>                &lt;/button&gt;<br>            )<br>        &#125;<br>    &#125;<br><br>    ReactDOM.render(<br>        &lt;Toggle /&gt;,<br>        document.getElementById(&quot;example&quot;)<br>    )<br></code></pre></td></tr></table></figure></p><p>必须谨慎对待JSX回调函数中的this， 类的方法默认是不会绑定this的<br>如果忘记绑定this.handleClick并把它传入onClick，当调用这个函数的时候this的值会是undefined。<br>这不是React的特殊行为，它是函数如何在javaScript中运行的一部分。通常情况下，如果没有在方法后面添加（），例如：onClick={this.handleClick},应该为这个方法绑定this。<br>如果使用bind觉得有点烦，可以有两种解决方法：</p><ul><li><p>如果你正在使用实验性的属性初始化器语法，你可以使用属性初始化器来正确的绑定回调函数：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class LoggingButton extends React.Component &#123;<br>  // 这个语法确保了 `this` 绑定在  handleClick 中<br>  handleClick = () =&gt; &#123;<br>    console.log(&apos;this is:&apos;, this);<br>  &#125;<br> <br>  render() &#123;<br>    return (<br>      &lt;button onClick=&#123;this.handleClick&#125;&gt;<br>        Click me<br>      &lt;/button&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如果你没有使用属性初始化器语法，你可以在回调函数中使用 箭头函数：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class LoggingButton extends React.Component &#123;<br>  handleClick() &#123;<br>    console.log(&apos;this is:&apos;, this);<br>  &#125;<br> <br>  render() &#123;<br>    //  这个语法确保了 `this` 绑定在  handleClick 中<br>    return (<br>      &lt;button onClick=&#123;(e) =&gt; this.handleClick(e)&#125;&gt;<br>        Click me<br>      &lt;/button&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>这个语法有个问题就是么次LoggingButton渲染的时候都会创建一个不同的回调函数。在大多数情况下，这没有问题。然而如果这个回调函数作为一个属性值传入低阶组件，这些组件可能会进行额外的重新渲染。通常建议在构造函数中绑定或使用属性初始化器语法来避免这类性能问题。</p></blockquote><h3 id="向事件处理程序传递参数"><a href="#向事件处理程序传递参数" class="headerlink" title="向事件处理程序传递参数"></a>向事件处理程序传递参数</h3><blockquote><p>通常我们会为事件处理程序传递额外的参数。例如，如果是id是要删除的那一行的id，以下两种方式都可以向事件处理程序传递参数：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;button onClick=&#123;(e) =&gt; this.deleteSome(id, e)&#125;&gt;Delete&lt;/button&gt;<br>&lt;button onClick=&#123;this.deleteSome.bind(this, id)&#125;&gt;Delete&lt;/button&gt;<br></code></pre></td></tr></table></figure></p><p>这两种方式是等价的。<br>参数e作为React事件对象将会被作为第二个参数进行传递。<br>通过箭头函数的方式，事件对象必须显式的进行传递。<br>通过bind的方式，事件对象以及更多的参数将会被隐式的进行传递。<br>值得注意的是,通过bind方式向监听函数传参，在类组件中定义的监听函数，事件对象e要排在所传递参数的后面。例如：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class Popper extends React.Component &#123;<br>    constructor(props) &#123;<br>        super(props);<br>        this.state = &#123;<br>            name: &apos;Hello, React&apos;<br>        &#125;<br>    &#125;<br>    preventPop(name, e) &#123;<br>        e.preventDefault();<br>        console.log(name);<br>    &#125;<br>    render() &#123;<br>        return (<br>            &lt;div&gt;<br>                &lt;p&gt;hello&lt;/p&gt;<br>                &#123;/*通过bind()方法传递参数*/&#125;<br>                &lt;a href=&quot;http://www.wanglichao.top&quot;<br>                    onClick=&#123;this.preventPop.bind(this, this.state.name)&#125;<br>                &gt;Click&lt;/a&gt;<br>            &lt;/div&gt;<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-事件处理&quot;&gt;&lt;a href=&quot;#React-事件处理&quot; class=&quot;headerlink&quot; title=&quot;React 事件处理&quot;&gt;&lt;/a&gt;React 事件处理&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;React 元素的事件处理和DOM元素类似，但是语
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之Props</title>
    <link href="http://www.wanglichao.top/2018/11/13/React-Props/"/>
    <id>http://www.wanglichao.top/2018/11/13/React-Props/</id>
    <published>2018-11-12T21:28:01.000Z</published>
    <updated>2018-11-12T18:44:43.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-Props"><a href="#React-Props" class="headerlink" title="React Props"></a>React Props</h2><blockquote><p>state 和 props 主要的区别在于props是不可变的,而state可以根据与用户交互来改变;<br>这就是为什么有些容器组件需要定义state来更新和修改数据;<br>而子组件只能通过props来传递数据;<br>演示如何在组件中使用props:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">function Message(props) &#123;<br>            return &lt;h1&gt;Hello, &#123;props.name&#125;!&lt;/h1&gt;<br>        &#125;<br>        const element = &lt;Message name=&quot;React&quot;/&gt;;<br>        ReactDOM.render(<br>            element,<br>            document.getElementById(&quot;box&quot;)<br>        )<br></code></pre></td></tr></table></figure></p><p>实例中name属性通过props.name来获取;</p></blockquote><h3 id="默认Props"><a href="#默认Props" class="headerlink" title="默认Props"></a>默认Props</h3><blockquote><p>你可以通过组件类的defaultProps属性为Props设置默认值:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class Message extends React.Component &#123;<br>            constructor() &#123;<br>                super()<br>            &#125;<br>            render() &#123;<br>                return (<br>                    &lt;h1&gt;Hello, &#123;this.props.name&#125;!&lt;/h1&gt;<br>                )<br>            &#125;<br>        &#125;<br>        Message.defaultProps = &#123;<br>            name: &apos;React&apos;<br>        &#125;;<br>        const element = &lt;Message /&gt;;<br>        ReactDOM.render(<br>            element,<br>            document.getElementById(&apos;box&apos;)<br>        )<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="State-和-Props"><a href="#State-和-Props" class="headerlink" title="State 和 Props"></a>State 和 Props</h3><p>以下实例演示了如何在应用中组合使用state和props, 我们可以在父组件中设置state,并通过在子组件上使用props将其传递到子组件上,在render函数中,我们设置name和site来获取父组件传递过来的数据;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class WebSite extends React.Component &#123;<br>            constructor () &#123;<br>                super();<br>                this.state = &#123;<br>                    name: &quot;勇往直前&quot;,<br>                    site: &quot;http://www.wanglichao.top&quot;<br>                &#125;<br>            &#125;<br>            render() &#123;<br>                return (<br>                    &lt;div&gt;<br>                        &lt;Name name=&#123;this.state.name&#125;/&gt;<br>                        &lt;Link site=&#123;this.state.site&#125;/&gt;<br>                    &lt;/div&gt;<br>                )<br>            &#125;<br>        &#125;<br><br>        class Name extends React.Component &#123;<br>            render() &#123;<br>                return (<br>                    &lt;h1&gt;&#123;this.props.name&#125;&lt;/h1&gt;<br>                )<br>            &#125;<br>        &#125;<br><br>        class Link extends React.Component &#123;<br>            render() &#123;<br>                return (<br>                    &lt;a href=&#123;this.props.site&#125;&gt;<br>                        &#123;this.props.site&#125;<br>                    &lt;/a&gt;<br>                )<br>            &#125;<br>        &#125;<br><br>        ReactDOM.render(<br>            &lt;WebSite /&gt;,<br>            document.getElementById(&quot;box&quot;)<br>        )<br></code></pre></td></tr></table></figure></p><h3 id="Props-验证"><a href="#Props-验证" class="headerlink" title="Props 验证"></a>Props 验证</h3><blockquote><p><code>React.PropTypes 在 React v15.5 版本后已经移动到prop-types库.</code><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;script src=&quot;https://cdn.bootcss.com/prop-types/15.6.1/prop-types.js&quot;&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><p>Props验证使用propTypes,它可以保证我们的应用组件被正确的使用,React.PropTypes 提供很多验证器(validator)来验证传入数据是否有效;<br>当向props传入无效数据时,JavaScript控制台会抛出警告.<br>以下实例创建一个MyTitle组件,属性title是必须的且是字符串,非字符串类型会自动转换为字符串.<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs undefined">// React 16.4 实例<br>let title = &quot;勇往直前&quot;;<br>        // title = 123;<br>        // Failed prop type: Invalid prop `title` of type `number` supplied to `MyTitle`, expected `string`.<br>    in MyTitle<br>        class MyTitle extends React.Component &#123;<br>            render() &#123;<br>                return (<br>                    &lt;h1&gt;Hello, &#123;this.props.title&#125;&lt;/h1&gt;<br>                )<br>            &#125;<br>        &#125;<br><br>        MyTitle.propTypes = &#123;<br>            title: PropTypes.string<br>        &#125;;<br><br>        ReactDOM.render(<br>            &lt;MyTitle title=&#123;title&#125; /&gt;,<br>            document.getElementById(&quot;box&quot;)<br>        )<br></code></pre></td></tr></table></figure></p></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs undefined">// React 15.4 实例<br>let title = &quot;勇往直前&quot;;<br>    // title = 123;<br>    const MyTitle = React.createClass(&#123;<br>        propTypes: &#123;<br>            title: React.PropTypes.string.isRequired<br>        &#125;,<br>        render: function() &#123;<br>            return &lt;h1&gt;&#123;this.props.title&#125;&lt;/h1&gt;<br>        &#125;<br>    &#125;);<br>    ReactDOM.render(<br>        &lt;MyTitle title=&#123;title&#125; /&gt;,<br>        document.getElementById(&apos;example&apos;)<br>    );<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-Props&quot;&gt;&lt;a href=&quot;#React-Props&quot; class=&quot;headerlink&quot; title=&quot;React Props&quot;&gt;&lt;/a&gt;React Props&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;state 和 props 主要的区别在于
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
  </entry>
  
</feed>
