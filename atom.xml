<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>勇往直前</title>
  
  <subtitle>心有远方</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wanglichao.top/"/>
  <updated>2018-11-13T22:07:53.489Z</updated>
  <id>http://www.wanglichao.top/</id>
  
  <author>
    <name>王立超</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React学习笔记之ajax</title>
    <link href="http://www.wanglichao.top/2018/11/15/React-ajax/"/>
    <id>http://www.wanglichao.top/2018/11/15/React-ajax/</id>
    <published>2018-11-14T21:28:01.000Z</published>
    <updated>2018-11-13T22:07:53.489Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-AJAX"><a href="#React-AJAX" class="headerlink" title="React AJAX"></a>React AJAX</h2><blockquote><p>React组件的数据可以通过componentDidMount方法中的ajax来获取,当从服务端获取数据时可以将数据存储在state中,再用this.setState()方法重新渲染UI.<br>当使用异步加载数据的时候,在组件卸载前使用componentWillUnmount来取消未完成的请求;<br>以下实例演示了获取 Github 用户最新 gist 共享描述:</p></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class UserGist extends React.Component &#123;<br>        constructor(props) &#123;<br>            super(props);<br>            this.state = &#123;<br>                username : &apos;&apos;,<br>                lastGistUrl: &apos;&apos;<br>            &#125;;<br>        &#125;<br><br>        componentDidMount() &#123;<br>            this.serverRequest = $.get(this.props.source, res =&gt; &#123;<br>                let lastGist = res[0];<br>                this.setState(&#123;<br>                    username: lastGist.owner.login,<br>                    lastGistUrl: lastGist.html_url<br>                &#125;);<br>            &#125;);<br>        &#125;<br><br>        componentWillUnmount() &#123;<br>            this.serverRequest.abort();<br>        &#125;<br><br>        render() &#123;<br>            return (<br>                &lt;div&gt;<br>                    &#123;this.state.username&#125; 用户最新的Gist共享地址:<br>                    &lt;a href=&#123;this.state.lastGistUrl&#125;&gt;&#123;this.state.lastGistUrl&#125;&lt;/a&gt;<br>                &lt;/div&gt;<br>            )<br>        &#125;<br>    &#125;<br><br>    ReactDOM.render(<br>        &lt;UserGist source=&quot;https://api.github.com/users/octocat/gists&quot; /&gt;,<br>        document.getElementById(&quot;example&quot;)<br>    )<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-AJAX&quot;&gt;&lt;a href=&quot;#React-AJAX&quot; class=&quot;headerlink&quot; title=&quot;React AJAX&quot;&gt;&lt;/a&gt;React AJAX&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;React组件的数据可以通过componentDi
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之表单与事件</title>
    <link href="http://www.wanglichao.top/2018/11/15/React-form-and-events/"/>
    <id>http://www.wanglichao.top/2018/11/15/React-form-and-events/</id>
    <published>2018-11-14T21:28:01.000Z</published>
    <updated>2018-11-13T22:07:47.291Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Reactor-表单与事件"><a href="#Reactor-表单与事件" class="headerlink" title="Reactor 表单与事件"></a>Reactor 表单与事件</h2><blockquote><p>HTML表单元素与Reactor中的其它DOM元素有所不同,因为表单元素生来就保留一些内部状态;<br>在HTML当中,像input,textarea和select这类表单元素会维持自身状态,并根据用户输入进行更新,但在React中,可变的状态通常保存在组件的状态属性中,并且只能用setState()方法进行更新;</p></blockquote><h5 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h5><blockquote><p>在实例中设置了输入框input的值value={this.state.data},在输入框的值发生变化时我们可以更新state,我们可以使用onChange事件来监听input的变化,并修改state;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class Content extends React.Component &#123;<br>        render() &#123;<br>            return (<br>                &lt;div&gt;<br>                    &lt;input type=&quot;text&quot;<br>                           value=&#123;this.props.myDataProp&#125;<br>                           onChange=&#123;this.props.updateStateProp&#125;<br>                    /&gt;<br>                    &lt;h4&gt;&#123;this.props.myDataProp&#125;&lt;/h4&gt;<br>                &lt;/div&gt;<br>            )<br>        &#125;<br>    &#125;<br>    class HelloMessage extends React.Component &#123;<br>        constructor(props) &#123;<br>            super(props);<br>            this.state = &#123;value: &quot;Hello, React!&quot;&#125;;<br>        &#125;<br>        handleChange(e) &#123;<br>            this.setState(&#123;value: e.target.value&#125;);<br>        &#125;<br>        render() &#123;<br>            let value = this.state.value;<br>            return (<br>                &lt;div&gt;<br>                    &lt;Content myDataProp=&#123;value&#125;<br>                             updateStateProp=&#123;(e)=&gt;this.handleChange(e)&#125;<br>                    /&gt;<br>                &lt;/div&gt;<br>            )<br>        &#125;<br>    &#125;<br>    ReactDOM.render(<br>        &lt;HelloMessage /&gt;,<br>        document.getElementById(&apos;example&apos;)<br>    )<br></code></pre></td></tr></table></figure></p><p>上面的代码将渲染出一个值为Hello React! 的input元素,并通过onChange事件影响更新用户输入的值</p></blockquote><h5 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h5><blockquote><p>在以下实例中,将演示如何在子组件上使用表单,onChange方法将触发state的更新,并将更新的值传递到子组件的输入框的value上来重新渲染界面;<br>需要在父组件通过创建事件句柄(handleChange),并作为prop(updateStateProp)传递到子组件上;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs undefined">// 创建一个Content组件:<br>    class Content extends React.Component &#123;<br>        render() &#123;<br>            return (<br>                &lt;div&gt;<br>                    &lt;input type=&quot;text&quot;<br>                           value=&#123;this.props.myDataProp&#125;<br>                           onChange=&#123;this.props.updateStateProp&#125;<br>                    /&gt;<br>                    &lt;h4&gt;&#123;this.props.myDataProp&#125;&lt;/h4&gt;<br>                &lt;/div&gt;<br>            )<br>        &#125;<br>    &#125;<br><br>    // 创建HelloMessage组件<br>    class HelloMessage extends React.Component &#123;<br>        constructor(props) &#123;<br>            super(props);<br>            this.state = &#123;<br>                value: &apos;Hello, React&apos;<br>            &#125;;<br>        &#125;<br><br>        handleChange(e) &#123;<br>            this.setState(&#123;<br>                value: e.target.value<br>            &#125;)<br>        &#125;<br><br>        render() &#123;<br>            let value = this.state.value;<br>            return (<br>                &lt;div&gt;<br>                    &lt;Content myDataProp=&#123;value&#125;<br>                             updateStateProp=&#123;e=&gt;this.handleChange(e)&#125;<br>                    /&gt;<br>                &lt;/div&gt;<br>            )<br>        &#125;<br>    &#125;<br><br>    ReactDOM.render(<br>        &lt;HelloMessage/&gt;,<br>        document.getElementById(&quot;example&quot;)<br>    )<br></code></pre></td></tr></table></figure></p></blockquote><h5 id="Select下拉菜单"><a href="#Select下拉菜单" class="headerlink" title="Select下拉菜单"></a>Select下拉菜单</h5><blockquote><p>在React中,不使用selected属性,而是在根select标签上用value属性来表示选中项;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class LikeForm extends React.Component &#123;<br>        constructor(props) &#123;<br>            super(props);<br>            this.state = &#123;<br>                value: &apos;coconut&apos;<br>            &#125;<br>        &#125;<br>        handleChange(e) &#123;<br>            this.setState(&#123;<br>                value: e.target.value<br>            &#125;)<br>        &#125;<br>        handleSubmit(e) &#123;<br>            alert(&quot;你最喜欢的网站是&quot; + this.state.value);<br>            e.preventDefault();<br>        &#125;<br>        render() &#123;<br>            return (<br>                &lt;form onSubmit=&#123;(e)=&gt;this.handleSubmit(e)&#125;&gt;<br>                    &lt;label&gt;<br>                        &lt;select value=&#123;this.state.value&#125;<br>                                onChange=&#123;e=&gt;this.handleChange(e)&#125;<br>                        &gt;<br>                            &lt;option value=&quot;谷歌&quot;&gt;Google&lt;/option&gt;<br>                            &lt;option value=&quot;脸书&quot;&gt;Facebook&lt;/option&gt;<br>                            &lt;option value=&quot;淘宝&quot;&gt;Taobao&lt;/option&gt;<br>                            &lt;option value=&quot;草榴&quot;&gt;Caoliu&lt;/option&gt;<br>                        &lt;/select&gt;<br>                    &lt;/label&gt;<br>                    &lt;input type=&quot;submit&quot; value=&apos;提交&apos;/&gt;<br>                &lt;/form&gt;<br>            )<br>        &#125;<br>    &#125;<br>    ReactDOM.render(<br>        &lt;LikeForm /&gt;,<br>        document.getElementById(&apos;example&apos;)<br>    )<br></code></pre></td></tr></table></figure></p></blockquote><h5 id="多个表单"><a href="#多个表单" class="headerlink" title="多个表单"></a>多个表单</h5><blockquote><p>当需要处理多个input元素时,可以通过给每个元素添加一个name属性,来让处理函数根据event.target.name的值来选择做什么:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class Reservation extends React.Component &#123;<br>        constructor(props) &#123;<br>            super(props);<br>            this.state = &#123;<br>                isGoing: true,<br>                numberOfGuests: 10<br>            &#125;;<br>        &#125;<br>        handleInputChange(e) &#123;<br>            const target = e.target;<br>            const value = target.type === &apos;checkbox&apos; ? target.checked : target.value;<br>            const name = target.name;<br>            this.setState(&#123;<br>                [name]: value<br>            &#125;)<br>        &#125;<br>        render() &#123;<br>            return (<br>                &lt;form&gt;<br>                    &lt;label&gt;<br>                        是或否:<br>                        &lt;input type=&quot;checkbox&quot;<br>                               name=&quot;isGoing&quot;<br>                               checked=&#123;this.state.isGoing&#125;<br>                               onChange=&#123;e=&gt;this.handleInputChange(e)&#125;<br>                        /&gt;<br>                    &lt;/label&gt;<br>                    &lt;br/&gt;<br>                    &lt;label&gt;<br>                        统计数:<br>                        &lt;input type=&quot;number&quot;<br>                               name=&quot;numberOfGuests&quot;<br>                               value=&#123;this.state.numberOfGuests&#125;<br>                               onChange=&#123;e=&gt;this.handleInputChange(e)&#125;<br>                        /&gt;<br>                    &lt;/label&gt;<br>                &lt;/form&gt;<br>            )<br>        &#125;<br>    &#125;<br>    ReactDOM.render(<br>        &lt;Reservation /&gt;,<br>        document.getElementById(&quot;example&quot;)<br>    )<br></code></pre></td></tr></table></figure></p></blockquote><h5 id="React事件"><a href="#React事件" class="headerlink" title="React事件"></a>React事件</h5><blockquote><p>通过onClick事件来修改数据:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class Message extends React.Component &#123;<br>        constructor(props) &#123;<br>            super(props);<br>            this.state = &#123;<br>                value: &quot;Hello, React!&quot;<br>            &#125;;<br>        &#125;<br>        handleChangeValue() &#123;<br>            this.setState(&#123;<br>                value: &quot;Hello, Vue!&quot;<br>            &#125;)<br>        &#125;<br>        render() &#123;<br>            return (<br>                &lt;div&gt;<br>                    &lt;button onClick=&#123;()=&gt;this.handleChangeValue()&#125;&gt;点我&lt;/button&gt;<br>                    &lt;h4&gt;&#123;this.state.value&#125;&lt;/h4&gt;<br>                &lt;/div&gt;<br>            )<br>        &#125;<br>    &#125;<br>    ReactDOM.render(<br>        &lt;Message /&gt;,<br>        document.getElementById(&quot;example&quot;)<br>    )<br></code></pre></td></tr></table></figure></p><p>当需要从子组件中更新父组件的state时,需要在父组件通过创建事件句柄(handleChange),并作为prop(updateStateProp)传递到子组件上;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class Content extends React.Component &#123;<br>        render() &#123;<br>            return(<br>                &lt;div&gt;<br>                    &lt;button onClick=&#123;this.props.updateStateProp&#125;&gt;button&lt;/button&gt;<br>                    &lt;h4&gt;&#123;this.props.myDataProp&#125;&lt;/h4&gt;<br>                &lt;/div&gt;<br>            )<br>        &#125;<br>    &#125;<br>    class Message extends React.Component &#123;<br>        constructor(props) &#123;<br>            super(props);<br>            this.state = &#123;<br>                value: &quot;Hello React!!!&quot;<br>            &#125;;<br>        &#125;<br>        handleChange() &#123;<br>            this.setState(&#123;<br>                value: &quot;My App is Success!!!&quot;<br>            &#125;)<br>        &#125;<br>        render() &#123;<br>            return (<br>                &lt;div&gt;<br>                    &lt;Content updateStateProp=&#123;()=&gt;this.handleChange()&#125;<br>                             myDataProp=&#123;this.state.value&#125;<br>                    /&gt;<br>                &lt;/div&gt;<br>            )<br>        &#125;<br>    &#125;<br>    ReactDOM.render(<br>        &lt;Message /&gt;,<br>        document.getElementById(&quot;example&quot;)<br>    )<br></code></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Reactor-表单与事件&quot;&gt;&lt;a href=&quot;#Reactor-表单与事件&quot; class=&quot;headerlink&quot; title=&quot;Reactor 表单与事件&quot;&gt;&lt;/a&gt;Reactor 表单与事件&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;HTML表单元素与Reac
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之渲染</title>
    <link href="http://www.wanglichao.top/2018/11/14/React-refs/"/>
    <id>http://www.wanglichao.top/2018/11/14/React-refs/</id>
    <published>2018-11-14T06:10:05.000Z</published>
    <updated>2018-11-13T22:18:10.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-Refs"><a href="#React-Refs" class="headerlink" title="React Refs"></a>React Refs</h2><blockquote><p>React支持一种非常特殊的属性 ref , 可以用来绑定到render()输出的任何组件上;<br>这个特殊的属性允许引用render()返回的相应的支撑实例(backing instance),这样就可以确保在任何时间都能拿到正确的实例;</p><h5 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h5><p>绑定一个ref属性到render的返回值上:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;input ref=&quot;myInput&quot;/&gt;<br></code></pre></td></tr></table></figure></p></blockquote><p>在其他代码中,通过this.refs获取支撑实例:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">let input = this.refs.myInput;<br>let inputValue = input.value;<br></code></pre></td></tr></table></figure></p><h4 id="完整实例"><a href="#完整实例" class="headerlink" title="完整实例"></a>完整实例</h4><blockquote><p>可以通过使用this来获取当前React组件,或使用ref来获取组件的引用;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class MyComponent extends React.Component &#123;<br>  handleClick() &#123;<br>    // 使用原生的DOM API获取焦点<br>    this.refs.myInput.focus();<br>  &#125;<br>  render() &#123;<br>    // 当组件插入到DOM后，ref属性添加一个组件的引用于到this.refs<br>    return (<br>      &lt;div&gt;<br>        &lt;input type=&quot;text&quot; ref=&quot;myInput&quot; /&gt;<br>        &lt;input<br>          type=&quot;button&quot;<br>          value=&quot;点我输入框获取焦点&quot;<br>          onClick=&#123;this.handleClick.bind(this)&#125;<br>        /&gt;<br>      &lt;/div&gt;<br>    );<br>  &#125;<br>&#125;<br> <br>ReactDOM.render(<br>  &lt;MyComponent /&gt;,<br>  document.getElementById(&apos;example&apos;)<br>);<br></code></pre></td></tr></table></figure></p><p>也可以使用getDOMNode()方法获取DOM元素;</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-Refs&quot;&gt;&lt;a href=&quot;#React-Refs&quot; class=&quot;headerlink&quot; title=&quot;React Refs&quot;&gt;&lt;/a&gt;React Refs&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;React支持一种非常特殊的属性 ref , 可以
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之组件API</title>
    <link href="http://www.wanglichao.top/2018/11/14/React-component-API/"/>
    <id>http://www.wanglichao.top/2018/11/14/React-component-API/</id>
    <published>2018-11-13T21:28:01.000Z</published>
    <updated>2018-11-13T22:08:05.749Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-组件-API"><a href="#React-组件-API" class="headerlink" title="React 组件 API"></a>React 组件 API</h2><blockquote><p>React 组件API的7个方法:</p><ul><li>设置状态:setState</li><li>替换状态: replaceState</li><li>设置属性: setProps</li><li>替换属性: replaceState</li><li>强制更新: forceUpdate</li><li>获取DOM节点: findDOMNode</li><li>判断组件挂在状态： isMounted</li></ul></blockquote><h3 id="设置状态-setState"><a href="#设置状态-setState" class="headerlink" title="设置状态: setState"></a>设置状态: setState</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">setState(object nextState[, function callback])<br></code></pre></td></tr></table></figure><h5 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h5><pre><code>&gt; * nextState 将要设置新的状态,该状态会和当前的state合并;&gt; * callback 可选参数,回调函数,该函数会在setState设置成功,且组件重新渲染后调用;</code></pre><blockquote><p>合并nextState和当前state,并重新渲染组件,setState是React事件处理函数中和请求回调函数中触发UI更新的主要方法;</p></blockquote><h5 id="关于setState"><a href="#关于setState" class="headerlink" title="关于setState"></a>关于setState</h5><blockquote><p>不能在组件内部通过this.state修改状态,因为该状态会在调用setState()后被替换;<br>setState()并不会立即改变this.state,而是创建一个即将处理的state;<br>setState()并不一定是同步的,为了提升性能React会批量执行state和DOM渲染;<br>setState()总是会触发一次组件重绘,除非在shouldComponentUpdate()中实现了一些条件渲染逻辑;<br>点击计数器:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class Counter extends React.Component &#123;<br>        constructor(props) &#123;<br>            super(props);<br>            this.state = &#123;<br>                clickCount: 0<br>            &#125;;<br>            this.handleClick = this.handleClick.bind(this);<br>        &#125;<br><br>        handleClick() &#123;<br>            this.setState(function (state) &#123;<br>                return &#123;clickCount: state.clickCount + 1&#125;;<br>            &#125;)<br>        &#125;<br><br>        render() &#123;<br>            return(<br>                &lt;div&gt;<br>                    &lt;button onClick=&#123;this.handleClick&#125;&gt;点我&lt;/button&gt;<br>                    &lt;h3&gt;点击次数为&#123;this.state.clickCount&#125;&lt;/h3&gt;<br>                &lt;/div&gt;<br>            )<br>        &#125;<br>    &#125;<br><br>    ReactDOM.render(<br>        &lt;Counter /&gt;,<br>        document.getElementById(&quot;example&quot;)<br>    )<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="替换状态-replaceState"><a href="#替换状态-replaceState" class="headerlink" title="替换状态: replaceState"></a>替换状态: replaceState</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">replaceState(object nextState[, function callback])<br></code></pre></td></tr></table></figure><blockquote><p>replaceState() 方法与setState() 类似,但是方法只会保留nextState中的状态,原state不在nextState中的状态都会被删除</p></blockquote><h3 id="设置属性-setProps"><a href="#设置属性-setProps" class="headerlink" title="设置属性: setProps"></a>设置属性: setProps</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">setProps(object nextProps[, function callback])<br></code></pre></td></tr></table></figure><pre><code>&gt; * nextProps 将要设置的新属性,该状态会和当前的props合并;&gt; * callback 可选参数,回调函数,该函数会在setProps设置成功,且组件重新渲染后调用;</code></pre><blockquote><p>props相当于组件的数据流,它总是会从父组件向下传递至所有的子组件中.<br>当和一个外部的javascript应用集成时,我们可能需要向组件传递数据或者通知React.render() 组件需要重新渲染,可以使用setProps();<br>更新组件,我可以在节点上再次调用React.render(),也可以通过setProps() 方法改变组件属性,触发组件重新渲染;</p></blockquote><h3 id="替换属性-replaceProps"><a href="#替换属性-replaceProps" class="headerlink" title="替换属性: replaceProps"></a>替换属性: replaceProps</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">replaceProps(object nextProps[, function callback])<br></code></pre></td></tr></table></figure><blockquote><p>replaceProps()方法与setProps()方法类似,但是它会删除原有的props;</p></blockquote><h3 id="强制更新-forceUpdate"><a href="#强制更新-forceUpdate" class="headerlink" title="强制更新: forceUpdate"></a>强制更新: forceUpdate</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">forceUpdate([function callback])<br></code></pre></td></tr></table></figure><blockquote><ul><li>callback 可选参数,回调函数,该函数会在组件render()方法调用后调用;<br>forceUpdate()方法会使组件调用自身的render() 方法重新渲染组件,组件的子组件也会调用自己的render() ,但是,组件重新渲染时,依然会读取this.props和this.state,如果状态没有改变,那么React只会更新DOM;<br>forceUpdate()方式适用于this.props和this.state之外的组件重绘(如:修改了this.state后), 通过该方法通知React需要调用render();<br>一般来说,应该尽量避免使用forceUpdate(),而仅从this.props和this.state中读取状态并由React触发render调用;</li></ul></blockquote><h3 id="获取DOM节点-findDOMNode"><a href="#获取DOM节点-findDOMNode" class="headerlink" title="获取DOM节点: findDOMNode"></a>获取DOM节点: findDOMNode</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">DOMElement findDOMNode<br></code></pre></td></tr></table></figure><blockquote><ul><li>返回值: DOM元素DOMElement<br>如果组件已经挂载到DOM中,该方法返回对应的本地浏览器DOM元素<br>当render()返回null或false时,this.findDOMNode()也会返回null.<br>从DOM中读取值得时候，该方法很有用，如：获取表单字段的值和做一些DOM操作；</li></ul></blockquote><h3 id="判断组件挂载状态：-isMounted"><a href="#判断组件挂载状态：-isMounted" class="headerlink" title="判断组件挂载状态： isMounted"></a>判断组件挂载状态： isMounted</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">bool isMounted()<br></code></pre></td></tr></table></figure><blockquote><ul><li>返回值： true或false，表示组件是否已经挂载到DOM中<br>isMounted()方法用于判断组件是否已挂在到DOM中<br>可以使用该方法保证来setState（）和forceUpdate（）在异步场景下的调用不会出错。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-组件-API&quot;&gt;&lt;a href=&quot;#React-组件-API&quot; class=&quot;headerlink&quot; title=&quot;React 组件 API&quot;&gt;&lt;/a&gt;React 组件 API&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;React 组件API的7个方法:
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之列表和keys</title>
    <link href="http://www.wanglichao.top/2018/11/14/React-list/"/>
    <id>http://www.wanglichao.top/2018/11/14/React-list/</id>
    <published>2018-11-13T21:28:01.000Z</published>
    <updated>2018-11-13T22:08:14.160Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-列表-和-keys"><a href="#React-列表-和-keys" class="headerlink" title="React 列表 和 keys"></a>React 列表 和 keys</h2><blockquote><p>我们可以使用javascript的map()方法来创建数字列表:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">const numbers = [1, 2, 3, 4, 5];<br>    const listItem = numbers.map(number =&gt;<br>        &lt;li&gt;&#123;number&#125;&lt;/li&gt;<br>    );<br>    ReactDOM.render(<br>        &lt;ul&gt;<br>            &#123;listItem&#125;<br>        &lt;/ul&gt;,<br>        document.getElementById(&quot;example&quot;)<br>    )<br></code></pre></td></tr></table></figure></p><p>我们可以将以上实例重构成一个组件,组件接收数组参数,每个列表元素分配一个key,不然会出现警告<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs undefined">let numbers = [1, 2, 3, 4, 5];<br><br>   function NumberList(props) &#123;<br>       const numbers = props.numbers;<br>       const listItems = numbers.map(number =&gt;<br>           &lt;li key=&#123;number&#125;&gt;&#123;number&#125;&lt;/li&gt;<br>       );<br>       return (<br>           &lt;ul&gt;<br>               &#123;listItems&#125;<br>           &lt;/ul&gt;<br>       )<br>   &#125;<br><br>   ReactDOM.render(<br>       &lt;NumberList numbers=&#123;numbers&#125;/&gt;,<br>       document.getElementById(&quot;example&quot;)<br>   )<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a>Keys</h3><blockquote><p>keys可以在DOM中的某些元素被增加或删除的时候,帮助React识别哪些元素发生了变化,因此应当给数组中每一个元素赋予一个确定的标识.<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;li key=&#123;number.toString()&#125;&gt;<br></code></pre></td></tr></table></figure></p><p>一个元素的key最好是这个元素在列表中拥有的独一无二的字符串,通常,我们使用来自数据的ID作为元素的key;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">const todoItems = todos.map(todo =&gt;<br>&lt;li key=&#123;todo.id&#125;&gt;<br>&#123;todo.text&#125;<br>&lt;/li&gt;<br>);<br></code></pre></td></tr></table></figure></p><p>当元素没有确定的id时,可以使用它的序列号索引index作为它的key<br> <figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">const todoItems = todos.map((todo, index) =&gt;<br>&lt;li key=&#123;index&#125;&gt;<br>&#123;todo.text&#125;<br>&lt;/li&gt;<br>);<br></code></pre></td></tr></table></figure></p><p>如果列表可以重新排序,我们不建议使用索引来进行排序,因为这回导致渲染变得很慢</p></blockquote><h3 id="用Keys-提取组件"><a href="#用Keys-提取组件" class="headerlink" title="用Keys 提取组件"></a>用Keys 提取组件</h3><blockquote><p>元素的key只有在它和它的兄弟节点对比时才有意义;<br>比方说,如果需要提取一个ListItem组件,你应该把key保存在数组中的<listitem>元素上,而不是放在ListItem组件中的li元素上<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs undefined">function ListItem(props) &#123;<br>  // 这里不需要指定key<br>  return &lt;li&gt;&#123;props.value&#125;&lt;/li&gt;;<br>&#125;<br>function NumberList(props) &#123;<br>  const numbers = props.numbers;<br>  const listItems = numbers.map((number) =&gt;<br>    // 建议将key指定在这里,数组的上下文里;<br>    &lt;ListItem key=&#123;number.toString()&#125;<br>              value=&#123;number&#125; /&gt;<br>  );<br>  return (<br>    &lt;ul&gt;<br>      &#123;listItems&#125;<br>    &lt;/ul&gt;<br>  );<br>&#125;<br>const numbers = [1, 2, 3, 4, 5];<br>ReactDOM.render(<br>  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,<br>  document.getElementById(&apos;example&apos;)<br>);<br></code></pre></td></tr></table></figure></listitem></p><p>在map()方法的内部调用元素时,最好随时记得为每一个元素加上独一无二的key;</p></blockquote><h3 id="元素的key在它与它的兄弟元素之间应该是唯一"><a href="#元素的key在它与它的兄弟元素之间应该是唯一" class="headerlink" title="元素的key在它与它的兄弟元素之间应该是唯一"></a>元素的key在它与它的兄弟元素之间应该是唯一</h3><blockquote><p>数组元素中使用的key在其兄弟之间应该是独一无二的,然而,它们不需要是全局唯一的,当生成两个不同的数组时,可以使用相同的key;<br>key会作为给React的提示,但不会传递给你的组件.如果你的组件中需要使用和key相同的值,请将其作为属性传递;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">const content = posts.map((post) =&gt; <br>&lt;Post key=&#123;post.id&#125;<br>  id=&#123;post.id&#125;<br>  title=&#123;post.title&#125; /&gt;<br>);<br></code></pre></td></tr></table></figure></p><p>上面例子中,Post组件可以读出props.id,但是不能读出props.key;</p></blockquote><h3 id="在JSX中嵌入map"><a href="#在JSX中嵌入map" class="headerlink" title="在JSX中嵌入map()"></a>在JSX中嵌入map()</h3><blockquote><p>JSX允许在大括号中嵌入任何表达式,所以我们可以在map()中这样使用:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">function NumberList(props)&#123;<br> const nubers = props.numbers;<br>reutnr (<br>&lt;ul&gt;<br>&#123;numbers.map(number) =&gt;<br>&lt;ListItem key=&#123;number.toString()&#125; value=&#123;number&#125; /&gt;<br>&lt;/ul&gt;<br>)<br> &#125;<br></code></pre></td></tr></table></figure></p><p>这么做有时可以使你的代码更清晰,但有时这种风格会被滥用,就像在javascript中一样,何时需要为了可读性提取出一个变量,这完全取决于你自己,但请记住,如果一个map() 嵌套了太多层级,那你就可以提取出组件;</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-列表-和-keys&quot;&gt;&lt;a href=&quot;#React-列表-和-keys&quot; class=&quot;headerlink&quot; title=&quot;React 列表 和 keys&quot;&gt;&lt;/a&gt;React 列表 和 keys&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;我们可以使
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之生命周期</title>
    <link href="http://www.wanglichao.top/2018/11/14/React-life/"/>
    <id>http://www.wanglichao.top/2018/11/14/React-life/</id>
    <published>2018-11-13T21:28:01.000Z</published>
    <updated>2018-11-13T22:08:00.075Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-生命周期"><a href="#React-生命周期" class="headerlink" title="React 生命周期"></a>React 生命周期</h2><blockquote><p>组件的生命周期可分成三个状态:</p><ul><li>Mounting: 已插入真实DOM;</li><li>Updating: 正在被重新渲染;</li><li>Unmounting: 已移出真实DOM;</li></ul></blockquote><p><strong>生命周期的方法有</strong>：</p><blockquote><ul><li>componentWillComponent 在渲染前调用,在客户端也在服务端;</li><li>componentDidMount 在第一次渲染后调用,只在客户端.  之后已经生成了对应的DOM结构,可以通过this.getDOMNode()来进行访问,如果你想和其他javascript框架一起使用,可以在这个方法中调用setTimeout,setInterval或者发送ajax请求等操作(防止异步操作阻塞UI);</li><li>componentWillReceiveProps 在组件接收到一个新的prop(更新后)时被调用,这个方法在初始化render时不会被调用;</li><li>shouldComponentUpdate 返回一个布尔值,在组件接收到新的props或者state时被调用,在初始化时或者使用forceUpdate时不被调用;<br>componentWillUpdate 在组件接收到新的props或者state,但还没有render时调用,在初始化时不会被调用;</li><li>componentDidUpdate 在组件完成更新后立即调用,在初始化时不会被调用;</li><li>componentWillUnmount 在组件从DOM中移除之前立刻被调用;<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs undefined">componentWillMount() &#123;<br>            console.log(&apos;Component Will Mount&apos;);<br>        &#125;<br>        componentDidMount() &#123;<br>            console.log(&apos;Component Did Mount&apos;);<br>        &#125;<br>        componentWillReceiveProps(newProps) &#123;<br>            console.log(&apos;Component Will Receive Props&apos;);<br>        &#125;<br>        shouldComponentUpdate(newProps, newState) &#123;<br>            console.log(&apos;Should Component Update&apos;);<br>            return true;<br>        &#125;<br>        componentWillUpdate(nextProps, nextState) &#123;<br>            console.log(&apos;Component Will Update&apos;);<br>        &#125;<br>        componentDidUpdate(prevProps, prevState) &#123;<br>            console.log(&apos;Component Did Update&apos;);<br>        &#125;<br>        componentWillUnmount() &#123;<br>            console.log(&apos;Component Will Unmount&apos;);<br>        &#125;<br></code></pre></td></tr></table></figure></li></ul></blockquote><p><img src="/2018/11/14/React-life/React-life1.png" alt="生命周期1"><br><img src="/2018/11/14/React-life/React-life2.jpg" alt="生命周期2"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-生命周期&quot;&gt;&lt;a href=&quot;#React-生命周期&quot; class=&quot;headerlink&quot; title=&quot;React 生命周期&quot;&gt;&lt;/a&gt;React 生命周期&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;组件的生命周期可分成三个状态:&lt;/p&gt;
&lt;ul&gt;

      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之State</title>
    <link href="http://www.wanglichao.top/2018/11/13/React-State/"/>
    <id>http://www.wanglichao.top/2018/11/13/React-State/</id>
    <published>2018-11-12T21:28:01.000Z</published>
    <updated>2018-11-12T18:44:38.821Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-State"><a href="#React-State" class="headerlink" title="React State"></a>React State</h2><blockquote><p>React 把组件看成是一个状态机(StateMachines).通过与用户的交互,实现不同的状态,然后渲染UI,让用户界面和数据保持一致;<br>React里,只需更新组件的state,然后根据新的state重新渲染用户界面,而不需要去操作DOM;</p></blockquote><h3 id="将生命周期方法添加到类中"><a href="#将生命周期方法添加到类中" class="headerlink" title="将生命周期方法添加到类中"></a>将生命周期方法添加到类中</h3><blockquote><p>在具有许多组件的应用程序中,在销毁时释放组件所占用的资源非常重要;<br>每当组件第一次加载到DOM中的时候,在React中被称为挂载;<br>当这个组件生成的DOM被移除的时候,在React中被称为卸载;</p></blockquote><h3 id="数据自顶向下流动"><a href="#数据自顶向下流动" class="headerlink" title="数据自顶向下流动"></a>数据自顶向下流动</h3><blockquote><p>父组件或子组件都不能知道某个组件是有状态还是无状态，并且它们不应该关心某组件是被定义为一个函数还是一个类。</p><p>这就是为什么状态通常被称为局部或封装。 除了拥有并设置它的组件外，其它组件不可访问。</p><p>通常被称为自顶向下或单向数据流。 任何状态始终由某些特定组件所有，并且从该状态导出的任何数据或 UI 只能影响树中下方的组件;</p><p>在 React 应用程序中，组件是有状态还是无状态被认为是可能随时间而变化的组件的实现细节。</p><p>我们可以在有状态组件中使用无状态组件，也可以在无状态组件中使用有状态组件。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-State&quot;&gt;&lt;a href=&quot;#React-State&quot; class=&quot;headerlink&quot; title=&quot;React State&quot;&gt;&lt;/a&gt;React State&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;React 把组件看成是一个状态机(Sta
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之this相关</title>
    <link href="http://www.wanglichao.top/2018/11/13/React-This/"/>
    <id>http://www.wanglichao.top/2018/11/13/React-This/</id>
    <published>2018-11-12T21:28:01.000Z</published>
    <updated>2018-11-12T19:49:32.557Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在JavaScript中，this对象是运行时基于函数的执行环境（也就是上下文）绑定的。</p><p>从 react 中的 demo 说起<br>Facebook一次更新react时，将es6中的class加入了组件的创建方式当中。Facebook也推荐组件创建使用通过定义一个继承自 React.Component 的class来定义一个组件类。官方的demo：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class LikeButton extends React.Component &#123;<br>  constructor() &#123;<br>    super();<br>    this.state = &#123;<br>      liked: false<br>    &#125;;<br>    this.handleClick = this.handleClick.bind(this);<br>  &#125;<br>  handleClick() &#123;<br>    this.setState(&#123;liked: !this.state.liked&#125;);<br>  &#125;<br>  render() &#123;<br>    const text = this.state.liked ? &apos;liked&apos; : &apos;haven\&apos;t liked&apos;;<br>    return (<br>      &lt;div onClick=&#123;this.handleClick&#125;&gt;<br>        You &#123;text&#125; this. Click to toggle.<br>      &lt;/div&gt;<br>    );<br>  &#125;<br>&#125;<br>ReactDOM.render(<br>  &lt;LikeButton /&gt;,<br>  document.getElementById(&apos;example&apos;)<br>);<br></code></pre></td></tr></table></figure></p><p>上面的demo中有大量this的使用，在 class LikeButton extends React.Component 中我们是声明该class，因为this具体是由其上下文决定的，因此在类定义中我们无法得知this用法。<br>相当于是new了上面定义的类，首先调用 constructor() 函数， this.state 的this上下文就是该实例对象；<br>同理，render() 函数中 this.state.liked 的this上下文也是该对象。<br>问题在于 onClick={this.handleClick} ，获取该函数引用是没有问题，这里的this上下文就是该对象。</p><p>这时问题来了，在原来 React.createClass 中， handleClick() 在onClick事件触发的时候，会自动绑定到LikeButton实例上，这时候该函数的this的上下文就是该实例。<br>不过在ES6的class的写法中，Facebook取消了自动绑定，实例化LikeButton后，handleClick()的上下文是div的支撑实例（ backing instance ），而 handleClick() 原本要绑定的上下文是LikeButton的实例。<br>对于该问题，我们有多种解决方案。<br><strong>使用 bind() 函数改变 this 的上下文</strong><br>可以在class声明中的constructor()函数中使用：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">this.handleClick = this.handleClick.bind(this);<br></code></pre></td></tr></table></figure></p><p>该方法是一个bind()绑定，多次使用。在该方法中，我们在声明该实例后，可以在该实例任何地方使用 handleClick() 函数，并且该 handleClick() 函数的this的上下文都是LikeButton实例对象。<br>除此我们也可以在具体使用该函数的地方绑定this的上下文到LikeButton实例对象，代码如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div onClick=&#123;this.handleClick.bind(this)&#125;&gt;<br>   Click to toggle.<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure></p><p>这种方法需要我们每次使用bind()函数绑定到组件对象上。<br><strong>es6的箭头函数</strong><br>es6中新加入了箭头函数=&gt;，箭头函数除了方便之外还有而一个特征就是将函数的this绑定到其定义时所在的上下文。这个特征也可以帮助我们解决这个问题。使用如下代码：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div onClick=&#123;() =&gt; this.handleClick()&#125;&gt;<br>  Click to toggle.<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure></p></blockquote><p>这样该 this.handleClick() 的上下文就会被绑定到 LikeButton 的实例对象上。</p><blockquote><p><strong>this的总结</strong><br>this 的本质就是：this跟作用域无关的，只跟执行上下文有关。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在JavaScript中，this对象是运行时基于函数的执行环境（也就是上下文）绑定的。&lt;/p&gt;
&lt;p&gt;从 react 中的 demo 说起&lt;br&gt;Facebook一次更新react时，将es6中的class加入了组件的创建方式当中。Faceboo
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之介绍</title>
    <link href="http://www.wanglichao.top/2018/11/13/React-anzhuang/"/>
    <id>http://www.wanglichao.top/2018/11/13/React-anzhuang/</id>
    <published>2018-11-12T21:28:01.000Z</published>
    <updated>2018-11-12T18:44:36.212Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React介绍"><a href="#React介绍" class="headerlink" title="React介绍"></a>React介绍</h2><blockquote><p>React是一个 用于构建用户界面的javascript库<br>React主要用于构建UI,很多人认为React是MVC中的V(视图)<br>React起源于Facebook的内部项目,用来架设Instagram的网站,并于2013年开源<br>React拥有较高的性能,代码逻辑非常简单,越来越多的人开始关注和使用它</p></blockquote><h3 id="React特点"><a href="#React特点" class="headerlink" title="React特点"></a>React特点</h3><blockquote><p>1.声明式设计 - React采用声明范式,可以轻松描述应用<br>2.高效  - React通过对DOM的模拟,最大限度的减少与DOM的交互<br>3.灵活 - React可以与已知的库或框架很好的配合<br>4.JSX - JSX是JavaScript语法的扩展,React开发不一定使用JSX,但建议使用它<br>5.组件 - 通过React构建组件,使得代码更加容易得到复用,能够很好的应用在大项目的开发中<br>6.单向响应的数据流 - React实现了单向响应的数据流,从而减少了重复代码,这也是它为什么比传统数据绑定更简单</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React介绍&quot;&gt;&lt;a href=&quot;#React介绍&quot; class=&quot;headerlink&quot; title=&quot;React介绍&quot;&gt;&lt;/a&gt;React介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;React是一个 用于构建用户界面的javascript库&lt;br&gt;Reac
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之事件处理</title>
    <link href="http://www.wanglichao.top/2018/11/13/React-Events/"/>
    <id>http://www.wanglichao.top/2018/11/13/React-Events/</id>
    <published>2018-11-12T21:28:01.000Z</published>
    <updated>2018-11-12T19:41:39.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-事件处理"><a href="#React-事件处理" class="headerlink" title="React 事件处理"></a>React 事件处理</h2><blockquote><p>React 元素的事件处理和DOM元素类似，但是语法上有有点不同；</p><ul><li>React 事件绑定属性的命名采用驼峰式写法，而不是小写；</li><li>如果采用JSX的语法你需要传入一个函数作为事件处理函数，而不是一个字符串（DOM元素的写法）；<br>HTML写法：<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;button onclick=&quot;todoSomething()&quot;&gt;button&lt;/button&gt;<br></code></pre></td></tr></table></figure></li></ul><p>React写法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;button onClick=&quot;todoSomething&quot;&gt;button&lt;/button&gt;<br></code></pre></td></tr></table></figure></p><p>在React中另一个不同是不能使用返回false的方式阻止默认行为，而必须<br>明确的使用preventDefault；<br>使用React的时候通常不需要使用addEventListener为一个已创建的DOM元素添加监视器，仅仅需要在这个元素渲染的时候提供一个监视器；<br>当使用ES6 class语法来定义一个组件的时候，事件处理器会成为类的一个方法。例如：Toggle组件渲染一个让用户切换开关状态的按钮：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class Toggle extends React.Component &#123;<br>        constructor(props) &#123;<br>            super(props);<br>            this.state = &#123;<br>                isToggle: true<br>            &#125;;<br>            this.handleClick = this.handleClick.bind(this);<br>        &#125;<br><br>        handleClick() &#123;<br>            this.setState(prevState =&gt; (&#123;<br>                isToggle: !prevState.isToggle<br>            &#125;))<br>        &#125;<br><br>        render() &#123;<br>            return (<br>                &lt;button onClick=&#123;this.handleClick&#125;&gt;<br>                    &#123;this.state.isToggle ? &apos;ON&apos; : &apos;OFF&apos;&#125;<br>                &lt;/button&gt;<br>            )<br>        &#125;<br>    &#125;<br><br>    ReactDOM.render(<br>        &lt;Toggle /&gt;,<br>        document.getElementById(&quot;example&quot;)<br>    )<br></code></pre></td></tr></table></figure></p><p>必须谨慎对待JSX回调函数中的this， 类的方法默认是不会绑定this的<br>如果忘记绑定this.handleClick并把它传入onClick，当调用这个函数的时候this的值会是undefined。<br>这不是React的特殊行为，它是函数如何在javaScript中运行的一部分。通常情况下，如果没有在方法后面添加（），例如：onClick={this.handleClick},应该为这个方法绑定this。<br>如果使用bind觉得有点烦，可以有两种解决方法：</p><ul><li><p>如果你正在使用实验性的属性初始化器语法，你可以使用属性初始化器来正确的绑定回调函数：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class LoggingButton extends React.Component &#123;<br>  // 这个语法确保了 `this` 绑定在  handleClick 中<br>  handleClick = () =&gt; &#123;<br>    console.log(&apos;this is:&apos;, this);<br>  &#125;<br> <br>  render() &#123;<br>    return (<br>      &lt;button onClick=&#123;this.handleClick&#125;&gt;<br>        Click me<br>      &lt;/button&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如果你没有使用属性初始化器语法，你可以在回调函数中使用 箭头函数：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class LoggingButton extends React.Component &#123;<br>  handleClick() &#123;<br>    console.log(&apos;this is:&apos;, this);<br>  &#125;<br> <br>  render() &#123;<br>    //  这个语法确保了 `this` 绑定在  handleClick 中<br>    return (<br>      &lt;button onClick=&#123;(e) =&gt; this.handleClick(e)&#125;&gt;<br>        Click me<br>      &lt;/button&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>这个语法有个问题就是么次LoggingButton渲染的时候都会创建一个不同的回调函数。在大多数情况下，这没有问题。然而如果这个回调函数作为一个属性值传入低阶组件，这些组件可能会进行额外的重新渲染。通常建议在构造函数中绑定或使用属性初始化器语法来避免这类性能问题。</p></blockquote><h3 id="向事件处理程序传递参数"><a href="#向事件处理程序传递参数" class="headerlink" title="向事件处理程序传递参数"></a>向事件处理程序传递参数</h3><blockquote><p>通常我们会为事件处理程序传递额外的参数。例如，如果是id是要删除的那一行的id，以下两种方式都可以向事件处理程序传递参数：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;button onClick=&#123;(e) =&gt; this.deleteSome(id, e)&#125;&gt;Delete&lt;/button&gt;<br>&lt;button onClick=&#123;this.deleteSome.bind(this, id)&#125;&gt;Delete&lt;/button&gt;<br></code></pre></td></tr></table></figure></p><p>这两种方式是等价的。<br>参数e作为React事件对象将会被作为第二个参数进行传递。<br>通过箭头函数的方式，事件对象必须显式的进行传递。<br>通过bind的方式，事件对象以及更多的参数将会被隐式的进行传递。<br>值得注意的是,通过bind方式向监听函数传参，在类组件中定义的监听函数，事件对象e要排在所传递参数的后面。例如：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class Popper extends React.Component &#123;<br>    constructor(props) &#123;<br>        super(props);<br>        this.state = &#123;<br>            name: &apos;Hello, React&apos;<br>        &#125;<br>    &#125;<br>    preventPop(name, e) &#123;<br>        e.preventDefault();<br>        console.log(name);<br>    &#125;<br>    render() &#123;<br>        return (<br>            &lt;div&gt;<br>                &lt;p&gt;hello&lt;/p&gt;<br>                &#123;/*通过bind()方法传递参数*/&#125;<br>                &lt;a href=&quot;http://www.wanglichao.top&quot;<br>                    onClick=&#123;this.preventPop.bind(this, this.state.name)&#125;<br>                &gt;Click&lt;/a&gt;<br>            &lt;/div&gt;<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-事件处理&quot;&gt;&lt;a href=&quot;#React-事件处理&quot; class=&quot;headerlink&quot; title=&quot;React 事件处理&quot;&gt;&lt;/a&gt;React 事件处理&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;React 元素的事件处理和DOM元素类似，但是语
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之JSX</title>
    <link href="http://www.wanglichao.top/2018/11/13/React-JSX/"/>
    <id>http://www.wanglichao.top/2018/11/13/React-JSX/</id>
    <published>2018-11-12T21:28:01.000Z</published>
    <updated>2018-11-12T18:44:41.021Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-JSX"><a href="#React-JSX" class="headerlink" title="React JSX"></a>React JSX</h2><blockquote><p>React 使用JSX来替代常规的JavaScript;<br>JSX是一个看起来像XML的JavaScript语法扩展;<br>我们不需要一定使用JSX,但它有以下优点:</p><ul><li>JSX执行更快,因为它在编译为JavaScript代码后进行了优化;</li><li>它是安全类型的,在编译过程中就能发现错误;</li><li>使用JSX编写模板更加简单快速</li></ul></blockquote><h3 id="使用JSX"><a href="#使用JSX" class="headerlink" title="使用JSX"></a>使用JSX</h3><blockquote><p>JSX使用起来类似HTML;<br>JSX代码可以放在一个独立的文件上,例如:创建一个js文件,然后在HTML中引入该js文件;<br> <figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined"> ReactDOM.render(<br>    &lt;h1&gt;Hello React!&lt;/h1&gt;,<br>    document.getElementById(&quot;box&quot;)<br>);<br></code></pre></td></tr></table></figure></p></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;body&gt;<br>    &lt;!--创建一个JS文件引入--&gt;<br>    &lt;div id=&quot;box&quot;&gt;&lt;/div&gt;<br>    &lt;script type=&quot;text/babel&quot; src=&quot;hello_react.js&quot;&gt;&lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h3 id="JavaScript表达式"><a href="#JavaScript表达式" class="headerlink" title="JavaScript表达式"></a>JavaScript表达式</h3><blockquote><p>我们可以在 JSX 中使用 JavaScript 表达式。表达式写在花括号 {} 中<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">let i = 1;<br>ReactDOM.render(<br>    &lt;h1&gt;&#123;i == 1 ? &apos;True&apos; : &apos;False&apos;&#125;&lt;/h1&gt;,<br>    document.getElementById(&quot;box&quot;)<br>);<br></code></pre></td></tr></table></figure></p><p>在 JSX 中不能使用 if else 语句，但可以使用 conditional (三元运算) 表达式来替代。以下实例中如果变量 i 等于 1 浏览器将输出 true, 如果修改 i 的值，则会输出 false.</p></blockquote><h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><blockquote><p>React 推荐使用内联样式。我们可以使用 camelCase 语法来设置内联样式. React 会在指定元素数字后自动添加 px<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">let myStyle = &#123;<br>    fontSize: 50,<br>    color: &apos;#ff0000&apos;<br>&#125;;<br><br>ReactDOM.render(<br>    &lt;h1 style=&#123;myStyle&#125;&gt;我是菜鸟&lt;/h1&gt;,<br>    document.getElementById(&quot;box&quot;)<br>);<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><blockquote><p>注释需要写在花括号中<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">ReactDOM.render(<br>    &lt;div&gt;<br>    &lt;h1&gt;哈哈哈&lt;/h1&gt;<br>    &#123;/*注释...*/&#125;<br>     &lt;/div&gt;,<br>    document.getElementById(&apos;example&apos;)<br>);<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>JSX 允许在模板中插入数组，数组会自动展开所有成员：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">let arr = [<br>    &lt;h1&gt;我是菜鸟&lt;/h1&gt;,<br>    &lt;h2&gt;正在学习&lt;/h2&gt;,<br>    &lt;h3&gt;不仅技术&lt;/h3&gt;,<br>    &lt;h4&gt;更是梦想&lt;/h4&gt;<br>];<br><br>ReactDOM.render(<br>    &lt;h1&gt;&#123;arr&#125;&lt;/h1&gt;,<br>    document.getElementById(&quot;box&quot;)<br>);<br></code></pre></td></tr></table></figure></p><h3 id="HTML标签-VS-React组件"><a href="#HTML标签-VS-React组件" class="headerlink" title="HTML标签 VS React组件"></a>HTML标签 VS React组件</h3><blockquote><p>React 可以渲染 HTML 标签 (strings) 或 React 组件 (classes)。<br>要渲染 HTML 标签，只需在 JSX 里使用小写字母的标签名。<br>React 的 JSX 使用大、小写的约定来区分本地组件的类和 HTML 标签。<br>要渲染 React 组件，只需创建一个大写字母开头的本地变量。</p><p>注意:<br>由于 JSX 就是 JavaScript，一些标识符像 class 和 for 不建议作为 XML 属性名。作为替代，React DOM 使用 className 和 htmlFor 来做对应的属性。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-JSX&quot;&gt;&lt;a href=&quot;#React-JSX&quot; class=&quot;headerlink&quot; title=&quot;React JSX&quot;&gt;&lt;/a&gt;React JSX&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;React 使用JSX来替代常规的JavaScript;&lt;
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之组件</title>
    <link href="http://www.wanglichao.top/2018/11/13/React-component/"/>
    <id>http://www.wanglichao.top/2018/11/13/React-component/</id>
    <published>2018-11-12T21:28:01.000Z</published>
    <updated>2018-11-12T18:44:37.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-组件"><a href="#React-组件" class="headerlink" title="React 组件"></a>React 组件</h2><blockquote><p>封装一个组件:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">// 使用函数定义一个组件<br>function Message(props) &#123;<br>    return &lt;h1&gt;Hello React!&lt;/h1&gt;;<br>&#125;<br> <br>const element = &lt;Message /&gt;;<br> <br>ReactDOM.render(<br>    element,<br>    document.getElementById(&apos;example&apos;)<br>);<br></code></pre></td></tr></table></figure></p><p>也可以使用ES6 class来定义一个组件<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class Welcome extends React.Component &#123;<br>  render() &#123;<br>    return &lt;h1&gt;Hello React!&lt;/h1&gt;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>const element = <hellomessage> 为用户自定义的组件。<br>注意，原生 HTML 元素名以小写字母开头，而自定义的 React 类名以大写字母开头，比如 HelloMessage 不能写成 helloMessage。除此之外还需要注意组件类只能包含一个顶层标签，否则也会报错。</hellomessage></p><p>如果需要向组件传递参数，可以使用 this.props 对象<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;script type=&quot;text/babel&quot;&gt;<br>        function HelloMessage(props) &#123;<br>            return &lt;h1&gt;Hello, &#123;props.name&#125;!&lt;/h1&gt;<br>        &#125;<br>        const element = &lt;HelloMessage name=&apos;React&apos; /&gt;;<br>        ReactDOM.render(<br>            element,<br>            document.getElementById(&apos;box&apos;)<br>        )<br>    &lt;/script&gt;<br></code></pre></td></tr></table></figure></p><p>以上实例中name属性通过proops.name来获取<br><code>注意，在添加属性时， class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字。</code></p></blockquote><h3 id="复合组件"><a href="#复合组件" class="headerlink" title="复合组件"></a>复合组件</h3><blockquote><p>我们可以通过创建多个组件来合成一个组件，即把组件的不同功能点进行分离。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs undefined">function Name(props) &#123;<br>            return &lt;h1&gt;网站名称: &#123;props.name&#125;&lt;/h1&gt;<br>        &#125;<br>        function Url(props) &#123;<br>            return &lt;h1&gt;网站地址: &#123;props.url&#125;&lt;/h1&gt;<br>        &#125;<br>        function Nickname(props) &#123;<br>            return &lt;h1&gt;网站小名: &#123;props.nickname&#125;&lt;/h1&gt;<br>        &#125;<br>        function App() &#123;<br>            return (<br>                &lt;div&gt;<br>                    &lt;Name name=&apos;勇往直前&apos;/&gt;<br>                    &lt;Url url=&quot;http://www.wanglichao.top&quot;/&gt;<br>                    &lt;Nickname nickname=&quot;心有远方&quot;/&gt;<br>                &lt;/div&gt;<br>            )<br>        &#125;<br>        ReactDOM.render(<br>            &lt;App /&gt;,<br>            document.getElementById(&apos;box&apos;)<br>        )<br></code></pre></td></tr></table></figure></p><p>实例中 App 组件使用了 Name、Url 和 Nickname 组件来输出对应的信息。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-组件&quot;&gt;&lt;a href=&quot;#React-组件&quot; class=&quot;headerlink&quot; title=&quot;React 组件&quot;&gt;&lt;/a&gt;React 组件&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;封装一个组件:&lt;br&gt;&lt;figure class=&quot;hljs hi
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之条件渲染</title>
    <link href="http://www.wanglichao.top/2018/11/13/React-condition-render/"/>
    <id>http://www.wanglichao.top/2018/11/13/React-condition-render/</id>
    <published>2018-11-12T21:28:01.000Z</published>
    <updated>2018-11-12T21:28:17.363Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-条件渲染"><a href="#React-条件渲染" class="headerlink" title="React 条件渲染"></a>React 条件渲染</h2><blockquote><p>在React中，你可以创建不同的组件来封装你需要的各种行为，然后还可以根据应用的状态变化仅渲染其中的一部分。<br>React中的条件渲染和JavaScript中的一致，使用JavaScript操作符if或条件运算符来创建表示当前状态的元素，然后让React根据它们来更新UI。<br>一个根据用户是否登录来显示其中之一的组件：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs undefined">function UserGreeting() &#123;<br>        return &lt;h1&gt;欢迎登录&lt;/h1&gt;<br>    &#125;<br><br>    function GuestGreeting() &#123;<br>        return &lt;h1&gt;请先注册&lt;/h1&gt;<br>    &#125;<br><br>    function Greeting(props) &#123;<br>        const isLoggedIn = props.isLoggedIn;<br>        if (isLoggedIn) &#123;<br>            return &lt;UserGreeting /&gt;<br>        &#125;<br>        return &lt;GuestGreeting /&gt;<br>    &#125;<br><br>    ReactDOM.render(<br>        // true or false<br>        &lt;Greeting isLoggedIn=&#123;false&#125;/&gt;,<br>        document.getElementById(&apos;example&apos;)<br>    )<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="元素变量"><a href="#元素变量" class="headerlink" title="元素变量"></a>元素变量</h3><blockquote><p>你可以使用变量来储存元素，它可以帮助你有条件的渲染组件中的一部分，而其他的部分不会更改。<br>创建一个LoginControl的有状态的组件，根据当前的状态来渲染<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class LoginControl extends React.Component &#123;<br>        constructor(props) &#123;<br>            super(props);<br>            this.state = &#123;<br>                isLoggedIn: false<br>            &#125;;<br>            this.handleLoginClick = this.handleLoginClick.bind(this);<br>            this.handleLogoutClick = this.handleLogoutClick.bind(this);<br>        &#125;<br>        handleLoginClick() &#123;<br>            this.setState(&#123;<br>                isLoggedIn: true<br>            &#125;)<br>        &#125;<br>        handleLogoutClick() &#123;<br>            this.setState(&#123;<br>                isLoggedIn: false<br>            &#125;)<br>        &#125;<br>        render() &#123;<br>            const isLoggedIn = this.state.isLoggedIn;<br>            let button = null;<br>            if (isLoggedIn) &#123;<br>                button = &lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125;/&gt;<br>            &#125; else &#123;<br>                button = &lt;LoginButton onClick=&#123;this.handleLoginClick&#125;/&gt;<br>            &#125;<br>            return (<br>                &lt;div&gt;<br>                    &lt;Greeting isLoggedIn=&#123;isLoggedIn&#125;/&gt;<br>                    &#123;button&#125;<br>                &lt;/div&gt;<br>            )<br>        &#125;<br>    &#125;<br><br>    function UserGreeting() &#123;<br>        return &lt;h1&gt;欢迎登录&lt;/h1&gt;<br>    &#125;<br><br>    function GuestGreeting() &#123;<br>        return &lt;h1&gt;请先登录或者注册&lt;/h1&gt;<br>    &#125;<br><br>    function Greeting(props) &#123;<br>        const isLoggedIn = props.isLoggedIn;<br>        if (isLoggedIn) &#123;<br>            return &lt;UserGreeting /&gt;<br>        &#125;<br>        return &lt;GuestGreeting /&gt;<br>    &#125;<br><br>    function LoginButton(props) &#123;<br>        return (<br>            &lt;button onClick=&#123;props.onClick&#125;&gt;登录&lt;/button&gt;<br>        )<br>    &#125;<br><br>    function LogoutButton(props) &#123;<br>        return (<br>            &lt;button onClick=&#123;props.onClick&#125;&gt;退出&lt;/button&gt;<br>        )<br>    &#125;<br><br>    ReactDOM.render(<br>        &lt;LoginControl /&gt;,<br>        document.getElementById(&quot;example&quot;)<br>    )<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="与运算符-amp-amp"><a href="#与运算符-amp-amp" class="headerlink" title="与运算符 &amp;&amp;"></a>与运算符 &amp;&amp;</h3><blockquote><p>你可以通过花括号包裹代码在JSX中嵌入任何表达式，也包括JavaScript的逻辑与&amp;&amp;，它可以方便的条件渲染一个元素<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs undefined">function Mailbox(props) &#123;<br>        const unreadMessages = props.unreadMessages;<br>        return (<br>            &lt;div&gt;<br>                &lt;h1&gt;Hello!&lt;/h1&gt;<br>                &#123;unreadMessages.length &gt; 0 &amp;&amp;<br>                    &lt;h2&gt;<br>                        您有&#123;unreadMessages.length&#125;条未读消息<br>                    &lt;/h2&gt;<br>                &#125;<br>            &lt;/div&gt;<br>        )<br>    &#125;<br><br>    const messages = [&apos;react&apos;, &apos;vue&apos;, &apos;javascript&apos;];<br>    ReactDOM.render(<br>        &lt;Mailbox unreadMessages=&#123;messages&#125;/&gt;,<br>        document.getElementById(&quot;example&quot;)<br>    )<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h3><p>条件渲染的另一种方法是使用JavaScript的条件运算符。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">something ? true : false<br></code></pre></td></tr></table></figure></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">render() &#123;<br>  const isLoggedIn = this.state.isLoggedIn;<br>  return (<br>    &lt;div&gt;<br>      &#123;isLoggedIn ? (<br>        &lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125; /&gt;<br>      ) : (<br>        &lt;LoginButton onClick=&#123;this.handleLoginClick&#125; /&gt;<br>      )&#125;<br>    &lt;/div&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在极少数情况下，你可能希望隐藏组件，即使它被其他组件渲染。让 render 方法返回 null 而不是它的渲染结果即可实现。<br>组件的 render 方法返回 null 并不会影响该组件生命周期方法的回调。例如，componentWillUpdate 和 componentDidUpdate 依然可以被调用。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-条件渲染&quot;&gt;&lt;a href=&quot;#React-条件渲染&quot; class=&quot;headerlink&quot; title=&quot;React 条件渲染&quot;&gt;&lt;/a&gt;React 条件渲染&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在React中，你可以创建不同的组件来封装你需要的
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之渲染</title>
    <link href="http://www.wanglichao.top/2018/11/13/React-render/"/>
    <id>http://www.wanglichao.top/2018/11/13/React-render/</id>
    <published>2018-11-12T21:28:01.000Z</published>
    <updated>2018-11-12T18:44:33.696Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React元素渲染"><a href="#React元素渲染" class="headerlink" title="React元素渲染"></a>React元素渲染</h2><blockquote><p>元素是构成React应用的最小单位，它用于描述屏幕上输出的内容。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">const element = &lt;h1&gt;Hello,React!&lt;/h1&gt;;<br></code></pre></td></tr></table></figure></p><p>与浏览器的DOM元素不同，React当中的元素事实上是普通的对象， React DOM可以确保浏览器DOM的数据内容与React元素保持一致。</p></blockquote><h3 id="将元素渲染到DOM中"><a href="#将元素渲染到DOM中" class="headerlink" title="将元素渲染到DOM中"></a>将元素渲染到DOM中</h3><blockquote><p>首先，在一个html页面中添加一个id=“example”的div<br>在此div中的所有内容都将由React DOM来管理，所以我们将其称之为“根”DOM节点<br>用React开发应用时一般只会定义一个根节点，但如果是在一个已有的项目中引入React的话，可能会需要在不同部分单独定义React根节点。</p></blockquote><h3 id="更新元素渲染"><a href="#更新元素渲染" class="headerlink" title="更新元素渲染"></a>更新元素渲染</h3><blockquote><p>React 元素都是不可变的，当元素被创建之后，是无法改变其内容或属性的。<br>目前更新界面的唯一办法就是创建一个新的元素，然后将它传入React DOM.render()方法；</p></blockquote><h3 id="React-只会更新必要的部分"><a href="#React-只会更新必要的部分" class="headerlink" title="React 只会更新必要的部分"></a>React 只会更新必要的部分</h3><blockquote><p>值得注意的是，React　DOM首先会比较元素内容先后的不同，而在渲染过程中只会更新改变了的部分。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React元素渲染&quot;&gt;&lt;a href=&quot;#React元素渲染&quot; class=&quot;headerlink&quot; title=&quot;React元素渲染&quot;&gt;&lt;/a&gt;React元素渲染&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;元素是构成React应用的最小单位，它用于描述屏幕上输出的
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之Props</title>
    <link href="http://www.wanglichao.top/2018/11/13/React-Props/"/>
    <id>http://www.wanglichao.top/2018/11/13/React-Props/</id>
    <published>2018-11-12T21:28:01.000Z</published>
    <updated>2018-11-12T18:44:43.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-Props"><a href="#React-Props" class="headerlink" title="React Props"></a>React Props</h2><blockquote><p>state 和 props 主要的区别在于props是不可变的,而state可以根据与用户交互来改变;<br>这就是为什么有些容器组件需要定义state来更新和修改数据;<br>而子组件只能通过props来传递数据;<br>演示如何在组件中使用props:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">function Message(props) &#123;<br>            return &lt;h1&gt;Hello, &#123;props.name&#125;!&lt;/h1&gt;<br>        &#125;<br>        const element = &lt;Message name=&quot;React&quot;/&gt;;<br>        ReactDOM.render(<br>            element,<br>            document.getElementById(&quot;box&quot;)<br>        )<br></code></pre></td></tr></table></figure></p><p>实例中name属性通过props.name来获取;</p></blockquote><h3 id="默认Props"><a href="#默认Props" class="headerlink" title="默认Props"></a>默认Props</h3><blockquote><p>你可以通过组件类的defaultProps属性为Props设置默认值:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class Message extends React.Component &#123;<br>            constructor() &#123;<br>                super()<br>            &#125;<br>            render() &#123;<br>                return (<br>                    &lt;h1&gt;Hello, &#123;this.props.name&#125;!&lt;/h1&gt;<br>                )<br>            &#125;<br>        &#125;<br>        Message.defaultProps = &#123;<br>            name: &apos;React&apos;<br>        &#125;;<br>        const element = &lt;Message /&gt;;<br>        ReactDOM.render(<br>            element,<br>            document.getElementById(&apos;box&apos;)<br>        )<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="State-和-Props"><a href="#State-和-Props" class="headerlink" title="State 和 Props"></a>State 和 Props</h3><p>以下实例演示了如何在应用中组合使用state和props, 我们可以在父组件中设置state,并通过在子组件上使用props将其传递到子组件上,在render函数中,我们设置name和site来获取父组件传递过来的数据;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class WebSite extends React.Component &#123;<br>            constructor () &#123;<br>                super();<br>                this.state = &#123;<br>                    name: &quot;勇往直前&quot;,<br>                    site: &quot;http://www.wanglichao.top&quot;<br>                &#125;<br>            &#125;<br>            render() &#123;<br>                return (<br>                    &lt;div&gt;<br>                        &lt;Name name=&#123;this.state.name&#125;/&gt;<br>                        &lt;Link site=&#123;this.state.site&#125;/&gt;<br>                    &lt;/div&gt;<br>                )<br>            &#125;<br>        &#125;<br><br>        class Name extends React.Component &#123;<br>            render() &#123;<br>                return (<br>                    &lt;h1&gt;&#123;this.props.name&#125;&lt;/h1&gt;<br>                )<br>            &#125;<br>        &#125;<br><br>        class Link extends React.Component &#123;<br>            render() &#123;<br>                return (<br>                    &lt;a href=&#123;this.props.site&#125;&gt;<br>                        &#123;this.props.site&#125;<br>                    &lt;/a&gt;<br>                )<br>            &#125;<br>        &#125;<br><br>        ReactDOM.render(<br>            &lt;WebSite /&gt;,<br>            document.getElementById(&quot;box&quot;)<br>        )<br></code></pre></td></tr></table></figure></p><h3 id="Props-验证"><a href="#Props-验证" class="headerlink" title="Props 验证"></a>Props 验证</h3><blockquote><p><code>React.PropTypes 在 React v15.5 版本后已经移动到prop-types库.</code><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;script src=&quot;https://cdn.bootcss.com/prop-types/15.6.1/prop-types.js&quot;&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><p>Props验证使用propTypes,它可以保证我们的应用组件被正确的使用,React.PropTypes 提供很多验证器(validator)来验证传入数据是否有效;<br>当向props传入无效数据时,JavaScript控制台会抛出警告.<br>以下实例创建一个MyTitle组件,属性title是必须的且是字符串,非字符串类型会自动转换为字符串.<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs undefined">// React 16.4 实例<br>let title = &quot;勇往直前&quot;;<br>        // title = 123;<br>        // Failed prop type: Invalid prop `title` of type `number` supplied to `MyTitle`, expected `string`.<br>    in MyTitle<br>        class MyTitle extends React.Component &#123;<br>            render() &#123;<br>                return (<br>                    &lt;h1&gt;Hello, &#123;this.props.title&#125;&lt;/h1&gt;<br>                )<br>            &#125;<br>        &#125;<br><br>        MyTitle.propTypes = &#123;<br>            title: PropTypes.string<br>        &#125;;<br><br>        ReactDOM.render(<br>            &lt;MyTitle title=&#123;title&#125; /&gt;,<br>            document.getElementById(&quot;box&quot;)<br>        )<br></code></pre></td></tr></table></figure></p></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs undefined">// React 15.4 实例<br>let title = &quot;勇往直前&quot;;<br>    // title = 123;<br>    const MyTitle = React.createClass(&#123;<br>        propTypes: &#123;<br>            title: React.PropTypes.string.isRequired<br>        &#125;,<br>        render: function() &#123;<br>            return &lt;h1&gt;&#123;this.props.title&#125;&lt;/h1&gt;<br>        &#125;<br>    &#125;);<br>    ReactDOM.render(<br>        &lt;MyTitle title=&#123;title&#125; /&gt;,<br>        document.getElementById(&apos;example&apos;)<br>    );<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-Props&quot;&gt;&lt;a href=&quot;#React-Props&quot; class=&quot;headerlink&quot; title=&quot;React Props&quot;&gt;&lt;/a&gt;React Props&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;state 和 props 主要的区别在于
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记之安装</title>
    <link href="http://www.wanglichao.top/2018/11/13/React-install/"/>
    <id>http://www.wanglichao.top/2018/11/13/React-install/</id>
    <published>2018-11-12T21:28:01.000Z</published>
    <updated>2018-11-13T14:08:41.095Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-安装"><a href="#React-安装" class="headerlink" title="React 安装"></a>React 安装</h2><h3 id="React-可以直接下载使用-也可以使用CDN"><a href="#React-可以直接下载使用-也可以使用CDN" class="headerlink" title="React 可以直接下载使用,也可以使用CDN;"></a>React 可以直接下载使用,也可以使用CDN;</h3><blockquote><p>Staticfile CDN 的 React CDN 库:</p></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;script src=&quot;https://cdn.staticfile.org/react/16.4.0/umd/react.development.js&quot;&gt;&lt;/script&gt;<br>&lt;script src=&quot;https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js&quot;&gt;&lt;/script&gt;<br>&lt;!-- 生产环境中不建议使用 --&gt;<br>&lt;script src=&quot;https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js&quot;&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><blockquote><p>官方提供的DCN地址:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;script src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt;<br>&lt;script src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt;<br>&lt;!-- 生产环境中不建议使用 --&gt;<br>&lt;script src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><p>输出Hello,React!的实例<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;meta charset=&quot;UTF-8&quot; /&gt;<br>&lt;title&gt;Hello React!&lt;/title&gt;<br>&lt;script src=&quot;https://cdn.staticfile.org/react/16.4.0/umd/react.development.js&quot;&gt;&lt;/script&gt;<br>&lt;script src=&quot;https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js&quot;&gt;&lt;/script&gt;<br>&lt;script src=&quot;https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js&quot;&gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br> <br>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;<br>&lt;script type=&quot;text/babel&quot;&gt;<br>ReactDOM.render(<br>    &lt;h1&gt;Hello,React!&lt;/h1&gt;,<br>    document.getElementById(&apos;app&apos;)<br>);<br>&lt;/script&gt;<br> <br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure></p><p>实例中需要3个库 react / react-DOM / babel</p><ul><li>react -&gt; React的核心库</li><li>react-dom -&gt; 提供与DOM相关的功能</li><li>babel -&gt;babel可以将ES6代码转为ES5代码,这就可以在不支持ES6的浏览器上执行React代码,babel内嵌了对JSX的支持<br>注意:如果需要使用JSX,则script标签的type属性需要设置为text/babel</li></ul></blockquote><h3 id="通过npm使用React"><a href="#通过npm使用React" class="headerlink" title="通过npm使用React"></a>通过npm使用React</h3><p>国内简易使用cnpm代替npm安装package;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">$ npm install -g cnpm --registry=https://registry.npm.taobao.org<br>$ npm config set registry https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure></p><blockquote><p>这样就可以使用cnpm命令来安装模块了<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">$ cnpm install [packagename]<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="使用create-react-app-快速构建React开发环境"><a href="#使用create-react-app-快速构建React开发环境" class="headerlink" title="使用create-react-app 快速构建React开发环境"></a>使用create-react-app 快速构建React开发环境</h3><blockquote><p>create-react-app 是来自于facebook，通过该命令我们无需配置就能快速构建React开发环境。<br>create-react-app 自动创建的项目是基于Webpack + ES6.<br>执行以下命令创建项目：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">$ cnpm install -g create-react-app<br>$ create-react-app [my-app]<br>$ cd [my-app]<br>$ npm start<br></code></pre></td></tr></table></figure></p><p>在浏览器中打开<a href="http://localhost:3000，就会呈现项目页面" target="_blank" rel="noopener">http://localhost:3000，就会呈现项目页面</a></p></blockquote><p>React 代码的书写格式和以前的 JS 有很大的不同，下面通过对这段代码进行分析了解一下他。</p><p>以前使用JS 定义一个变量使用 var 现在用 const：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">const div = document.createElement(&apos;div&apos;);<br></code></pre></td></tr></table></figure><p>ReactDOM.render(…) 是渲染方法，所有的 js,html 都可通过它进行渲染绘制，他又两个参数，内容和渲染目标 js 对象。</p><p>内容就是要在渲染目标中显示的东西，可以是一个React 部件，也可以是一段HTML或TEXT文本。渲染目标JS对象，就是一个DIV或TABEL,或TD 等HTML的节点对象。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">ReactDOM.render(&lt;App /&gt;, div);<br></code></pre></td></tr></table></figure><p>unmountComponentAtNode() 这个方法是解除渲染挂载，作用和 render 刚好相反，也就清空一个渲染目标中的 React 部件或 html 内容。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">ReactDOM.unmountComponentAtNode(div);<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-安装&quot;&gt;&lt;a href=&quot;#React-安装&quot; class=&quot;headerlink&quot; title=&quot;React 安装&quot;&gt;&lt;/a&gt;React 安装&lt;/h2&gt;&lt;h3 id=&quot;React-可以直接下载使用-也可以使用CDN&quot;&gt;&lt;a href=&quot;#React-
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://www.wanglichao.top/tags/JS/"/>
    
      <category term="react" scheme="http://www.wanglichao.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>关于项目打包时的优化</title>
    <link href="http://www.wanglichao.top/2018/11/11/project_webpack_optimize/"/>
    <id>http://www.wanglichao.top/2018/11/11/project_webpack_optimize/</id>
    <published>2018-11-10T22:37:24.000Z</published>
    <updated>2018-11-12T18:44:44.358Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前端-JavaScript-项目优化"><a href="#前端-JavaScript-项目优化" class="headerlink" title="前端 JavaScript 项目优化"></a>前端 JavaScript 项目优化</h2><h3 id="1-CSS抽离"><a href="#1-CSS抽离" class="headerlink" title="1.CSS抽离"></a>1.CSS抽离</h3><blockquote><p>将css文件从js文件中抽离出来;<br>分开加载,代码有改动时css/JS不用全部去加载;</p></blockquote><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 抽离css文件的插件:</span><br><span class="hljs-keyword">const</span> ExtractTextPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">"extract-text-webpack-plugin"</span>);<br><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-attr">module</span>: &#123;<br>        <span class="hljs-attr">rules</span>: [<br>            test: <span class="hljs-regexp">/\.css$/</span>,<br>            <span class="hljs-attr">use</span>: ExtracTextPlugin.extrac(&#123;<br>                <span class="hljs-attr">fallback</span>: <span class="hljs-string">"style-loader"</span>,<br>                <span class="hljs-attr">use</span>: <span class="hljs-string">"css-loader"</span><br>            &#125;)<br>        ]<br>    &#125;,<br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-keyword">new</span> ExtractTextPlugin(<span class="hljs-string">"styles.css"</span>)<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-哈希值"><a href="#2-哈希值" class="headerlink" title="2.哈希值"></a>2.哈希值</h3><blockquote><p>辨识文件是否改动;</p></blockquote><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">output: &#123;<br>   <span class="hljs-attr">path</span>: path.join(__dirname, <span class="hljs-string">'dist'</span>),<br>   <span class="hljs-comment">// js文件的哈希</span><br>   filename: <span class="hljs-string">"[name].[chunkhash:6].js"</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">plugins: [<br>       <span class="hljs-comment">// css文件的哈希</span><br>       <span class="hljs-keyword">new</span> ExtractTextPlugin(<span class="hljs-string">"[name].[contenthash:6].css"</span>)<br>   ]<br></code></pre></td></tr></table></figure><h3 id="3-第三方包抽离"><a href="#3-第三方包抽离" class="headerlink" title="3.第三方包抽离"></a>3.第三方包抽离</h3><blockquote><p>辨识部分文件改动;</p></blockquote><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 此插件依赖webpack</span><br><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>);<br><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-attr">entry</span>: &#123;<br>         <span class="hljs-attr">main</span>: <span class="hljs-string">"./src/main.js"</span>,<br>        <span class="hljs-comment">// 再加一个入口,将第三方包从main.js中分离出来</span><br>        vendors: [<span class="hljs-string">"vue"</span>,<span class="hljs-string">"vue-router"</span>,<span class="hljs-string">"moment"</span>,<span class="hljs-string">"axios"</span>,<span class="hljs-string">"vue-preview"</span>]<br>    &#125;,<br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-comment">// webpack中抽离第三方包的插件:</span><br>        <span class="hljs-keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;<br>            <span class="hljs-comment">// manifest用来记录使用者和第三方包的依赖关系</span><br>            names: [<span class="hljs-string">"vendors"</span>, <span class="hljs-string">"manifest"</span>]<br>        &#125;)<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-代码压缩混淆"><a href="#4-代码压缩混淆" class="headerlink" title="4.代码压缩混淆"></a>4.代码压缩混淆</h3><blockquote><p>很大程度的压缩代码体积</p></blockquote><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 压缩混淆代码的插件,需要 npm i -D uglifyjs-webpack-plugin 下载</span><br><span class="hljs-keyword">const</span> UglifyJSPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">"uglifyjs-webpack-plugin"</span>);<br><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-keyword">new</span> UglifyJSPlugin()<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-main-ui的按需引入"><a href="#5-main-ui的按需引入" class="headerlink" title="5.main-ui的按需引入"></a>5.main-ui的按需引入</h3><blockquote><p>进一步减小代码体积</p></blockquote><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 全部引入的用法:</span><br><span class="hljs-comment">// import Mint from 'mint-ui'</span><br><span class="hljs-comment">// import 'mint-ui/lib/style.css'</span><br><span class="hljs-comment">// Vue.use(Mint);</span><br><br><span class="hljs-comment">// 按需加载的用法:</span><br><span class="hljs-keyword">import</span> Header <span class="hljs-keyword">from</span> <span class="hljs-string">'mint-ui/lib/header'</span><br><span class="hljs-keyword">import</span> Switch <span class="hljs-keyword">from</span> <span class="hljs-string">'mint-ui/lib/switch'</span><br><span class="hljs-keyword">import</span> SwitchItem <span class="hljs-keyword">from</span> <span class="hljs-string">'mint-ui/lib/switch-item'</span><br><span class="hljs-keyword">import</span> Button <span class="hljs-keyword">from</span> <span class="hljs-string">'mint-ui/lib/button'</span><br><span class="hljs-keyword">import</span> Lazyload <span class="hljs-keyword">from</span> <span class="hljs-string">'mint-ui/lib/lazyload'</span><br><span class="hljs-comment">// ...</span><br><br>Vue.component(Header.name, Header);<br>Vue.component(SwitchItem.name, SwitchItem);<br>Vue.component(Button.name, Button);<br>Vue.use(Lazyload); <span class="hljs-comment">// 注意lazyload(懒加载)仍需要use方式调用</span><br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><h3 id="6-代码文件的结构整理"><a href="#6-代码文件的结构整理" class="headerlink" title="6.代码文件的结构整理"></a>6.代码文件的结构整理</h3><blockquote><p>文件的分类整理</p><ul><li>注意: 将文件路径分类整理后,代码中的相对路径引用文件可能会发生错误,需要修正</li></ul></blockquote><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">output: &#123;<br>   <span class="hljs-attr">path</span>: path.join(__dirname, <span class="hljs-string">'dist'</span>),<br>   <span class="hljs-comment">// 修正资源请求路径</span><br>   publicPath: <span class="hljs-string">'/'</span>,   <span class="hljs-comment">// 企业中也可以是 www.xxx.com/为根路径</span><br>   <span class="hljs-comment">// js文件的路径</span><br>   filename: <span class="hljs-string">"js/[name].[chunkhash:6].js"</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>   <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(jpg|png|svg|ttf|woff|woff2|gif)$/</span>,<br>   <span class="hljs-attr">use</span>: [<br>       <span class="hljs-string">'url-loader'</span>,<br>       <span class="hljs-attr">options</span>: &#123;<br>           <span class="hljs-attr">limit</span>: <span class="hljs-number">4096</span>,<br>           <span class="hljs-comment">// 图片文件的路径</span><br>           name: <span class="hljs-string">'/assets/[name].[ext]'</span><br>       &#125;<br>   ]<br>&#125;<br></code></pre></td></tr></table></figure><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">plugins: [<br>       <span class="hljs-comment">// css文件的路径</span><br>       <span class="hljs-keyword">new</span> ExtractTextPlugin(<span class="hljs-string">"css/[name].[contenthash:6].css"</span>)<br>   ]<br></code></pre></td></tr></table></figure><h3 id="7-路由的懒加载"><a href="#7-路由的懒加载" class="headerlink" title="7.路由的懒加载"></a>7.路由的懒加载</h3><blockquote><p>根据路由路径按需加载页面</p></blockquote><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.vue'</span>  <span class="hljs-comment">// 公用App组件不用</span><br><br><span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">'./component/home/home.vue'</span><br><span class="hljs-keyword">import</span> News <span class="hljs-keyword">from</span> <span class="hljs-string">'./component/news/news.vue'</span><br><span class="hljs-comment">// 修改为</span><br><span class="hljs-keyword">const</span> Home = <span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">require</span>([<span class="hljs-string">'./component/home/home.vue'</span>, resolve]);<br><span class="hljs-keyword">const</span> News = <span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> <span class="hljs-built_in">require</span>([<span class="hljs-string">'./component/news/news.vue'</span>, r]);<br></code></pre></td></tr></table></figure><h3 id="8-去除控制台开发的提示"><a href="#8-去除控制台开发的提示" class="headerlink" title="8.去除控制台开发的提示"></a>8.去除控制台开发的提示</h3><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">plugins: [<br>    <span class="hljs-keyword">new</span> webpack.DefinePlugin(&#123;<br>        <span class="hljs-string">'process.env'</span>: &#123;<br>            <span class="hljs-attr">NODE_ENV</span>: <span class="hljs-string">'"production"'</span><br>        &#125;<br>    &#125;)<br>]<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前端-JavaScript-项目优化&quot;&gt;&lt;a href=&quot;#前端-JavaScript-项目优化&quot; class=&quot;headerlink&quot; title=&quot;前端 JavaScript 项目优化&quot;&gt;&lt;/a&gt;前端 JavaScript 项目优化&lt;/h2&gt;&lt;h3 id=&quot;1
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="node" scheme="http://www.wanglichao.top/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>输入URL地址敲回车之后发生了什么</title>
    <link href="http://www.wanglichao.top/2018/11/10/enter-event/"/>
    <id>http://www.wanglichao.top/2018/11/10/enter-event/</id>
    <published>2018-11-10T12:14:24.000Z</published>
    <updated>2018-11-12T18:44:50.292Z</updated>
    
    <content type="html"><![CDATA[<h2 id="输入URL地址敲回车之后发生了什么"><a href="#输入URL地址敲回车之后发生了什么" class="headerlink" title="输入URL地址敲回车之后发生了什么"></a>输入URL地址敲回车之后发生了什么</h2><blockquote><p> 输入网址敲回车之后,<br> 浏览器开始向DNS服务器发送请求,    (request)请求<br> DNS服务器解析,<br> 找到IP地址对应的服务器,<br> 服务器根据对应的端口号找到对应的项目,<br> 将需要的数据代码编码后返回给浏览器客户端,并将数据的类型告诉浏览器(HTML/json…),     (response)响应<br> 浏览器将接收到的数据根据返回来的数据类型进行解析,</p></blockquote><ul><li><p>http事物: request请求和response响应都成功就是一个完整的HTTP事物;</p></li><li><p><a href="https://www.baidu.com:443/xx/yy/index.html?name=aa&amp;age=30#id=5" target="_blank" rel="noopener">https://www.baidu.com:443/xx/yy/index.html?name=aa&amp;age=30#id=5</a></p></li><li><p>(https) – (www.baidu.com ) – (443) – (/xx/yy/index.html) – (name=aa&amp;age=30) – (id=5)</p></li></ul><h2 id="1-HTTPS-传输协议"><a href="#1-HTTPS-传输协议" class="headerlink" title="1.(HTTPS) 传输协议"></a>1.(HTTPS) 传输协议</h2><blockquote><p>https / http  完成客户端和服务端的数据交互传输<br>https: 更加安全<br>http: 超文本传输协议<br>FTP: 往服务器上上传项目文件</p></blockquote><h2 id="2-www-baidu-com-域名"><a href="#2-www-baidu-com-域名" class="headerlink" title="2.(www.baidu.com) 域名:"></a>2.(www.baidu.com) 域名:</h2><blockquote><p>一级域名<br>二级域名<br>三级域名</p></blockquote><h2 id="3-443-端口号"><a href="#3-443-端口号" class="headerlink" title="3.(443) 端口号:"></a>3.(443) 端口号:</h2><ul><li>根据端口号找到对应的项目<blockquote><p>http: 默认端口号80<br>https: 默认端口号443<br>FTP: 默认端口号21</p></blockquote></li></ul><h2 id="4-xx-yy-index-html-项目地址"><a href="#4-xx-yy-index-html-项目地址" class="headerlink" title="4.(/xx/yy/index.html)项目地址"></a>4.(/xx/yy/index.html)项目地址</h2><ul><li>根据地址值找到项目下的具体页面文件<blockquote><p>/xx/yy/index.html 真实地址, 请求资源文件<br>/xxx  伪地址, 请求数据</p></blockquote></li></ul><h2 id="5-name-aa-amp-age-30-参数"><a href="#5-name-aa-amp-age-30-参数" class="headerlink" title="5.(name=aa&amp;age=30)参数"></a>5.(name=aa&amp;age=30)参数</h2><ul><li>参数格式是后台规定的,根据参数的值返回响应的数据</li></ul><h2 id="6-id-5-哈希值-Hash值"><a href="#6-id-5-哈希值-Hash值" class="headerlink" title="6.(id=5) 哈希值 Hash值"></a>6.(id=5) 哈希值 Hash值</h2><blockquote><p>锚点定位<br>路由</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;输入URL地址敲回车之后发生了什么&quot;&gt;&lt;a href=&quot;#输入URL地址敲回车之后发生了什么&quot; class=&quot;headerlink&quot; title=&quot;输入URL地址敲回车之后发生了什么&quot;&gt;&lt;/a&gt;输入URL地址敲回车之后发生了什么&lt;/h2&gt;&lt;blockquote&gt;

      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="http" scheme="http://www.wanglichao.top/tags/http/"/>
    
      <category term="url" scheme="http://www.wanglichao.top/tags/url/"/>
    
  </entry>
  
  <entry>
    <title>javascript学习之json常用方法</title>
    <link href="http://www.wanglichao.top/2018/02/16/page/javascript-json/"/>
    <id>http://www.wanglichao.top/2018/02/16/page/javascript-json/</id>
    <published>2018-02-15T21:30:40.000Z</published>
    <updated>2018-11-10T15:22:40.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="javascript中JSON语法有三种表示方法："><a href="#javascript中JSON语法有三种表示方法：" class="headerlink" title="javascript中JSON语法有三种表示方法："></a>javascript中JSON语法有三种表示方法：</h1><h3 id="简单值-“hello-json”"><a href="#简单值-“hello-json”" class="headerlink" title="简单值:      “hello json”"></a>简单值:      “hello json”</h3><h3 id="对象-“name”-”jack”"><a href="#对象-“name”-”jack”" class="headerlink" title="对象:        {“name”:”jack”}"></a>对象:        {“name”:”jack”}</h3><h3 id="数组-“aaa”-”bbb”-“ccc”-”ddd”"><a href="#数组-“aaa”-”bbb”-“ccc”-”ddd”" class="headerlink" title="数组:        [{“aaa”:”bbb”},{“ccc”:”ddd”}]"></a>数组:        [{“aaa”:”bbb”},{“ccc”:”ddd”}]</h3><h2 id="JSON常用的两个方法："><a href="#JSON常用的两个方法：" class="headerlink" title="JSON常用的两个方法："></a>JSON常用的两个方法：</h2><h2 id="stringify-和-parse"><a href="#stringify-和-parse" class="headerlink" title="stringify() 和 parse()"></a>stringify() 和 parse()</h2><h2 id="stringify用法："><a href="#stringify用法：" class="headerlink" title="*stringify用法："></a>*stringify用法：</h2><h4 id="用法一：-把javascript对象转化成JSON格式"><a href="#用法一：-把javascript对象转化成JSON格式" class="headerlink" title="用法一： 把javascript对象转化成JSON格式:"></a>用法一： 把javascript对象转化成JSON格式:</h4><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> demo = &#123;<br>  <span class="hljs-string">"name"</span>:<span class="hljs-string">"aaa"</span>,<br>  <span class="hljs-string">"type"</span>:<span class="hljs-string">"bbb"</span> <br>&#125;<br><span class="hljs-keyword">var</span> jsonDemo = <span class="hljs-built_in">JSON</span>.stringify(demo);<br><span class="hljs-built_in">console</span>.log(jsonDemo);<br></code></pre></td></tr></table></figure><ul><li>得到结果：</li></ul><figure class="hljs highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<span class="hljs-attr">"name"</span>:<span class="hljs-string">"aaa"</span>,<span class="hljs-attr">"type"</span>:<span class="hljs-string">"bbb"</span>&#125;<br></code></pre></td></tr></table></figure><h4 id="用法二：把javascript对象转化成JSON格式，增加过滤，只留想要的数据"><a href="#用法二：把javascript对象转化成JSON格式，增加过滤，只留想要的数据" class="headerlink" title="用法二：把javascript对象转化成JSON格式，增加过滤，只留想要的数据"></a>用法二：把javascript对象转化成JSON格式，增加过滤，只留想要的数据</h4><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> demo = &#123;<br><span class="hljs-string">"name"</span>:<span class="hljs-string">"aaa"</span>,<br><span class="hljs-string">"sex"</span>:<span class="hljs-string">"boy"</span>,<br><span class="hljs-string">"age"</span>: <span class="hljs-number">20</span><br>&#125;<br><span class="hljs-keyword">var</span> jsonDemo = <span class="hljs-built_in">JSON</span>.stringify(demo,[<span class="hljs-string">"name"</span>]);<br><span class="hljs-built_in">console</span>.log(jsonDemo);<br></code></pre></td></tr></table></figure><ul><li>得到结果：</li></ul><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs josn">&#123;&quot;name&quot;:&quot;aaa&quot;&#125;<br></code></pre></td></tr></table></figure><h4 id="用法三：把javascript对象转化成JSON格式，并改变原有的值"><a href="#用法三：把javascript对象转化成JSON格式，并改变原有的值" class="headerlink" title="用法三：把javascript对象转化成JSON格式，并改变原有的值"></a>用法三：把javascript对象转化成JSON格式，并改变原有的值</h4><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> demo = &#123;<br><span class="hljs-string">"name"</span>:<span class="hljs-string">"aaa"</span>,<br><span class="hljs-string">"sex"</span>:<span class="hljs-string">"bbb"</span>,<br><span class="hljs-string">"type"</span>:<span class="hljs-string">"ccc"</span><br>&#125;<br><span class="hljs-keyword">var</span> jsonDemo = <span class="hljs-built_in">JSON</span>.stringify(demo,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key, value</span>) </span>&#123;<br><span class="hljs-keyword">switch</span>(key)&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">"name"</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">"a"</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">"sex"</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">"b"</span>;<br><span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> value;<br>&#125;<br>&#125;);<br><span class="hljs-built_in">console</span>.log(jsonDemo);<br></code></pre></td></tr></table></figure><ul><li>得到结果：</li></ul><figure class="hljs highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<span class="hljs-attr">"name"</span>:<span class="hljs-string">"a"</span>,<span class="hljs-attr">"sex"</span>:<span class="hljs-string">"b"</span>,<span class="hljs-attr">"type"</span>:<span class="hljs-string">"ccc"</span>&#125;<br></code></pre></td></tr></table></figure><h4 id="用法四：把javascript对象转化成JSON格式，并控制缩进和空白符"><a href="#用法四：把javascript对象转化成JSON格式，并控制缩进和空白符" class="headerlink" title="用法四：把javascript对象转化成JSON格式，并控制缩进和空白符"></a>用法四：把javascript对象转化成JSON格式，并控制缩进和空白符</h4><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> book = &#123;<br><span class="hljs-string">"title"</span>: <span class="hljs-string">"aaa"</span>,<br><span class="hljs-string">"type"</span>: <span class="hljs-string">"bbb"</span>,<br><span class="hljs-string">"page"</span>: <span class="hljs-number">50</span><br>&#125;<br><span class="hljs-keyword">var</span> jsonBook = <span class="hljs-built_in">JSON</span>.stringify(book,<span class="hljs-literal">null</span>,<span class="hljs-string">"$$"</span>);<br><span class="hljs-built_in">console</span>.log(jsonBook)<br></code></pre></td></tr></table></figure><ul><li>得到结果：</li><li><figure class="hljs highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br><span class="hljs-attr">"title"</span>: <span class="hljs-string">"aaa"</span>,<br><span class="hljs-attr">"type"</span>: <span class="hljs-string">"bbb"</span>,<br><span class="hljs-attr">"page"</span>: <span class="hljs-number">50</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>－该方法第三个参数如果为数字，那么就是每个属性前面缩进的字符数。</p><h2 id="parse-方法"><a href="#parse-方法" class="headerlink" title="parse()方法"></a>parse()方法</h2><h4 id="用法一：把JSON转化成javascript格式-用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。"><a href="#用法一：把JSON转化成javascript格式-用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。" class="headerlink" title="用法一：把JSON转化成javascript格式, 用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。"></a>用法一：把JSON转化成javascript格式, 用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。</h4><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> book = <span class="hljs-string">'&#123;"title":"aaa", "type":"bbb", "page":"50"&#125;'</span>;<br>  <span class="hljs-keyword">var</span> demo = <span class="hljs-built_in">JSON</span>.parse(book);<br>  <span class="hljs-built_in">console</span>.log(demo);<br></code></pre></td></tr></table></figure><ul><li>得到结果：</li></ul><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<span class="hljs-attr">title</span>: <span class="hljs-string">"aaa"</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">"bbb"</span>, <span class="hljs-attr">page</span>: <span class="hljs-string">"50"</span>&#125;<br></code></pre></td></tr></table></figure><h4 id="用法二：把JSON转化为javascript过程中，改变原有的值"><a href="#用法二：把JSON转化为javascript过程中，改变原有的值" class="headerlink" title="用法二：把JSON转化为javascript过程中，改变原有的值"></a>用法二：把JSON转化为javascript过程中，改变原有的值</h4><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> book = <span class="hljs-string">'&#123;"title":"aaa", "type":"bbb", "page":50&#125;'</span>;<br>  <span class="hljs-keyword">var</span> demo = <span class="hljs-built_in">JSON</span>.stringify(book);<br>  <span class="hljs-keyword">var</span> javascriptDemo = <span class="hljs-built_in">JSON</span>.parse(demo, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key, value</span>) </span>&#123;<br> <span class="hljs-keyword">switch</span> (key) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">"title"</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">"bbbbbb"</span>;<br><span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> value;<br> &#125;<br>  &#125;);<br>  <span class="hljs-built_in">console</span>.log(javascriptDemo);<br></code></pre></td></tr></table></figure><ul><li>得到结果：<figure class="hljs highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<span class="hljs-attr">"title"</span>:<span class="hljs-string">"aaa"</span>, <span class="hljs-attr">"type"</span>:<span class="hljs-string">"bbb"</span>, <span class="hljs-attr">"page"</span>:<span class="hljs-number">50</span>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;javascript中JSON语法有三种表示方法：&quot;&gt;&lt;a href=&quot;#javascript中JSON语法有三种表示方法：&quot; class=&quot;headerlink&quot; title=&quot;javascript中JSON语法有三种表示方法：&quot;&gt;&lt;/a&gt;javascript中
      
    
    </summary>
    
      <category term="js学习" scheme="http://www.wanglichao.top/categories/js%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="javascript" scheme="http://www.wanglichao.top/tags/javascript/"/>
    
      <category term="json" scheme="http://www.wanglichao.top/tags/json/"/>
    
      <category term="js" scheme="http://www.wanglichao.top/tags/js/"/>
    
      <category term="js基础" scheme="http://www.wanglichao.top/tags/js%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>ajax基础知识和核心原理</title>
    <link href="http://www.wanglichao.top/2018/02/15/ajax_base/"/>
    <id>http://www.wanglichao.top/2018/02/15/ajax_base/</id>
    <published>2018-02-15T02:37:24.000Z</published>
    <updated>2018-11-12T18:44:57.075Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ajax基础知识"><a href="#ajax基础知识" class="headerlink" title="ajax基础知识"></a>ajax基础知识</h2><h3 id="1-什么是ajax"><a href="#1-什么是ajax" class="headerlink" title="1.什么是ajax:"></a>1.什么是ajax:</h3><ul><li>Async Javascript And XML ====&gt; 异步的JS和XML;</li><li>XML:可扩展的标记语言(自定义的一些标签,包裹数据,服务器传递数据);</li></ul><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--&lt;?xml version="1.0" encoding="UTF-8" ?&gt;--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">student</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>王二小<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">age</span>&gt;</span>33<span class="hljs-tag">&lt;/<span class="hljs-name">age</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">sex</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">sex</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">student</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-Ajax异步的概念"><a href="#2-Ajax异步的概念" class="headerlink" title="2. Ajax异步的概念:"></a>2. Ajax异步的概念:</h2><ul><li><code>局部刷新</code>:数据传递的是json字符串,前后端分离</li><li>1).向服务器发送ajax请求;</li><li>2).将服务器返回的数据经过前端的解析处理,绑定到页面上;</li><li>3).页面只需要改变一部分,整个页面不需要重新的渲染;</li><li><code>全局刷新</code>:页面的整体刷新,当页面上数据发生改变时,向后台发送请求,后台会将页面的数据重新渲染一遍,将渲染好的页面返回给客户端呈现,这是全局刷新,也是前后端不分离。这就要求后台去套数据,一般会使用jsp来套数据;</li></ul><h2 id="前后端分离和不分离的优势和劣势"><a href="#前后端分离和不分离的优势和劣势" class="headerlink" title="前后端分离和不分离的优势和劣势"></a>前后端分离和不分离的优势和劣势</h2><h3 id="不分离的优势"><a href="#不分离的优势" class="headerlink" title="不分离的优势:"></a>不分离的优势:</h3><ul><li>1.页面上的数据都是服务器渲染好的,源代码上能看到数据,有利于SEO优化(SEO:搜索引擎的收录和抓取);</li><li>2.从服务器上获取的页面已经是渲染好的,不需要客户端在去额外的请求,所以页面加载速度比较快(前提是服务器够快),一般京东淘宝这样的页面首屏一般都是前后端不分离,直接渲染好页面给前端返回;</li><li><h4 id="不分离的劣势"><a href="#不分离的劣势" class="headerlink" title="不分离的劣势:"></a>不分离的劣势:</h4></li><li><p>1.如果页面有很多内容需要改变,需要实时获取数据,每次更新数据都要重新刷新一下页面,客户体验不好;</p></li><li>2.每次都是服务器渲染的话,对服务器的要求比较高,服务器的压力比较大,如果服务器处理不过来,就会导致加载变慢甚至服务器崩溃;所以京东淘宝等网站只有首屏才会采用服务器渲染以提高页面加载速度;</li><li>3.目前市场上前后端分离的项目占大部分;</li><li><h4 id="分离的优势"><a href="#分离的优势" class="headerlink" title="分离的优势"></a>分离的优势</h4></li><li><p>1.可以根据需求任意改变页面的某一部分的数据更新,而不用刷新整个页面(例如:实时刷新,表单提交,用户登录),用户体验好;</p></li><li>2.有利于开发,提高开发效率,开发的时候前后端互不影响,不需要考虑各自使用的技术,相当于实现了技术的分离;可以进行同时开发,项目开始的时候,只需要制定以下交互文档(API文档),规定请求的url,请求方式,参数,返回数据格式等等,前端也可以使用node模拟接口和数据,来验证和调试页面;</li></ul><h4 id="分离的弊端"><a href="#分离的弊端" class="headerlink" title="分离的弊端"></a>分离的弊端</h4><ul><li>1.不利于SEO优化(注意:后期使用JS将数据绑定到页面上,不会在源代码上体现,所以不会被SEO收录和抓取);</li><li>2.刚开始加载时,请求资源文件的时候如果请求次数过多,会影响页面的加载速度;为了防止加载速度过慢,可以进行优化处理;</li></ul><h3 id="基于原生实现ajax"><a href="#基于原生实现ajax" class="headerlink" title="基于原生实现ajax"></a>基于原生实现ajax</h3><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建ajax对象:</span><br><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br><span class="hljs-comment">// 定义请求方式,同步或者异步,请求路径等等:</span><br>xhr.open(<span class="hljs-string">"method"</span>, <span class="hljs-string">"URL"</span>, <span class="hljs-keyword">async</span>, user.name, user.password);<br><span class="hljs-comment">// 定义返回状态:</span><br>xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br><span class="hljs-keyword">if</span> (xhr.readyState === <span class="hljs-number">4</span> &amp;&amp; xhr.status === <span class="hljs-number">200</span>) &#123;<br><span class="hljs-comment">// 获取响应的文本内容;</span><br><span class="hljs-keyword">let</span> res = xhr.responseText;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 开始发送请求(请求主体的内容数据):</span><br>xhr.send(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><h3 id="分析open的参数"><a href="#分析open的参数" class="headerlink" title="分析open的参数:"></a>分析open的参数:</h3><h4 id="method-ajax的请求方式"><a href="#method-ajax的请求方式" class="headerlink" title="method: ajax的请求方式:"></a>method: ajax的请求方式:</h4><ul><li>1).<code>GET</code>系列方式(获取数据):</li><li>get: 从服务器获取数据;</li><li>delete: 从服务器上删除某些文件;</li><li>head: 获取响应头信息;(不要响应主体,只要响应头);</li><li><p>……</p></li><li><p>2).<code>POST</code>系列方式((推送数据):</p></li><li>post: 向服务器传递数据;</li><li>put: 向服务器添加指定的资源文件;</li><li><p>……</p></li><li><p><code>不管是哪一种方式,都可以向服务器发送数据,也可以获取数据,但是一般GET系列以获取为主,POST系列就是以发送数据为主;</code></p></li><li><code>1).想获取动态展示的数据(如:新闻列表),一般使用GET请求,因为只需要告诉服务器需要什么,服务器就返回需要的内容;</code></li><li><code>2).当页面上有大量信息需要发送给服务器(如:表单提交),服务器接收到数据只需要返回成功或失败的状态,此时合适POST请求;</code></li></ul><h3 id="第一个参数-GET和POST具体有哪些区别"><a href="#第一个参数-GET和POST具体有哪些区别" class="headerlink" title="第一个参数:GET和POST具体有哪些区别"></a>第一个参数:GET和POST具体有哪些区别</h3><h4 id="区别1-数据携带方式-GET向服务器发送请求时-发送的内容比POST少-获取的比POST多"><a href="#区别1-数据携带方式-GET向服务器发送请求时-发送的内容比POST少-获取的比POST多" class="headerlink" title="区别1:数据携带方式:  GET向服务器发送请求时,发送的内容比POST少,获取的比POST多;"></a>区别1:数据携带方式:  <code>GET</code>向服务器发送请求时,发送的内容比<code>POST</code>少,获取的比<code>POST</code>多;</h4><ul><li>1.GET请求的参数是拼接在url上的,通过url的参数形式来传递数据,但是url的大小是有限制的,只有几KB,一旦超过限制,就会被默认剪切掉,所以无法携带大量的数据;</li><li>2.<code>POST</code>发送的数据是通过请求主体实现的,理论上大小是没有限制的,但是真实项目中为了保证传输数据的速度,也会加一些限制(例如:上传资料/图片等等文件时,后台服务器做一下特殊处理);</li></ul><h4 id="区别2-缓存问题-GET请求容易走缓存-POST不会"><a href="#区别2-缓存问题-GET请求容易走缓存-POST不会" class="headerlink" title="区别2:缓存问题: GET请求容易走缓存,POST不会:"></a>区别2:缓存问题: <code>GET</code>请求容易走缓存,<code>POST</code>不会:</h4><ul><li><code>GET</code>通过url传参数的方式请求数据,当遇到实时获取数据的时候,以为url是一样的,参数也是一样的,此时浏览器就会默认读取缓存中的内容返回给页面,导致获取不到服务器最新的数据,一般都是在参数后面加一个时间戳或者随机数来防止浏览器读取缓存;</li><li><code>POST</code>请求不会走缓存,因为请求的数据在请求主体中,是不会走缓存的;</li></ul><h4 id="区别3-安全性-GET请求法师没有POST请求方式安全"><a href="#区别3-安全性-GET请求法师没有POST请求方式安全" class="headerlink" title="区别3:安全性: GET请求法师没有POST请求方式安全:"></a>区别3:安全性: <code>GET</code>请求法师没有<code>POST</code>请求方式安全:</h4><ul><li><code>GET</code>的参数在url上,一些简单的黑客技术,拦截url(url劫持),也可以把客户端传递的信息获取到,导致信息泄露;</li><li><code>POST</code>的信息都在请求主体中,相对比较安全;</li></ul><h3 id="第二个参数-URL"><a href="#第二个参数-URL" class="headerlink" title="第二个参数:URL"></a>第二个参数:URL</h3><ul><li><code>这个url地址就是后台给的地址,一般都会有一个API文档,参照文档写就成;</code></li></ul><h3 id="第三个参数-Async"><a href="#第三个参数-Async" class="headerlink" title="第三个参数: Async"></a>第三个参数: Async</h3><ul><li>async: true 不写就是默认true,===&gt;异步;</li><li>async:false ===&gt; 同步;</li></ul><h3 id="最后两个参数-用户名-密码"><a href="#最后两个参数-用户名-密码" class="headerlink" title="最后两个参数:用户名,密码"></a>最后两个参数:用户名,密码</h3><blockquote><p><code>一般不需要写,只有一些服务器不允许匿名访问,只有开通权限的才可以访问,比如一些重要机密的,银行等这样的服务器才会设置权限;</code></p></blockquote><h4 id="第三部分解析"><a href="#第三部分解析" class="headerlink" title="第三部分解析"></a>第三部分解析</h4><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>ajax请求中xhr.readyState的状态码: </p><ul><li>0: 创建一个ajax对象,默认状态是0;</li><li>1: 执行xhr.open是1;</li><li>2: 请求已发送,并接受到了响应头是2;</li><li>3: 响应主体在路上是3;</li><li>4:响应主体返回客户端是4;</li></ul><p>ajax请求中xhr.status的HTTP网络状态码:</p><ul><li>200:成功状态,一个完整的HTTP事物完成,以2开头的都是成功状态;</li><li>300:以3开头的状态码也是成功状态,只不过是服务器做了一些处理;</li><li>301:永久重定向(永久转移),一般都是域名的迁移;比如京东的www.360buy.com重定向到www.jd.com;</li><li>302:临时重定向(临时转移),在新版的HTTP中307也代表临时重定向,一般是在处理服务器的负载均衡,当一个服务器负荷太大,将内容临时迁移到另一个服务器上处理,主要是一些图片,有一些大公司一般都有专门处理图片的服务器;</li><li>304:从浏览器中读取缓存,把一些不经常更新的文件和图片缓存,减少服务器的压力,增加页面的加载速度;</li></ul><p>以4开头的都是失败的,一般都是客户端的错误;</p><ul><li>400:请求参数错误;</li><li>401:无权限访问;</li><li>404:访问的地址不存在;</li></ul><p>以5开头的一般都是服务器的错误;</p><ul><li>500:服务器未知错误;</li><li>503:服务器超负载;</li></ul></blockquote><h3 id="ajax常用的属性和方法有哪些"><a href="#ajax常用的属性和方法有哪些" class="headerlink" title="ajax常用的属性和方法有哪些"></a>ajax常用的属性和方法有哪些</h3><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br><span class="hljs-built_in">console</span>.dir(xhr);<br></code></pre></td></tr></table></figure><blockquote><p>[属性]</p><ul><li>readyState:存储的是ajax的状态码;</li><li>responseText/responseXML:返回的是响应主体的内容,只是格式不一样,使用不同的属性接收即可;<ul><li>responseText 一般都是json字符串;</li><li>responseXML是XML格式的数据字符串;</li></ul></li><li>status:记录服务器返回的HTTP状态码;</li><li>statusText:对返回状态码status的描述;</li><li>timeout:设置ajax请求的超时时间;超过设置的时间响应主体还没回来,浏览器就会把请求强制断开;</li></ul><p>[方法]</p><ul><li>abort():强制中断ajax请求;</li><li>getAllResponseHeaders();获取全部响应头的信息(获取的是一堆字符串文本);</li><li>getResponseHeader(“属性名”);获取指定的响应头;如:getResponseHeader(“date”);获取响应头中存储的服务器的时间;</li><li>open(); 略</li><li>overrideMimeType();重写MIME类型;</li><li>send(); 略</li><li>setRequestHeader(“属性名”,属性值);设置请求头;<code>注意</code>:必须写在open()之后,send()之前,内容不可以是中文,否则会报错;</li></ul><p>[事件]</p><ul><li>onabort();当ajax中断的时候触发的事件;</li><li>onreadystatechange();当ajax状态发生变化就会触发的事件;</li><li>ontimeout();当ajax超时触发的事件;</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ajax基础知识&quot;&gt;&lt;a href=&quot;#ajax基础知识&quot; class=&quot;headerlink&quot; title=&quot;ajax基础知识&quot;&gt;&lt;/a&gt;ajax基础知识&lt;/h2&gt;&lt;h3 id=&quot;1-什么是ajax&quot;&gt;&lt;a href=&quot;#1-什么是ajax&quot; class=&quot;he
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.wanglichao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://www.wanglichao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="ajax" scheme="http://www.wanglichao.top/tags/ajax/"/>
    
  </entry>
  
</feed>
