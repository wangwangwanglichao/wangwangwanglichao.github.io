<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Vue学习笔记之响应接口</title>
      <link href="/2018/11/17/Vue-API-Response/"/>
      <url>/2018/11/17/Vue-API-Response/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue-js-响应接口"><a href="#Vue-js-响应接口" class="headerlink" title="Vue.js 响应接口"></a>Vue.js 响应接口</h2><blockquote><p>Vue 可以添加数据动态响应接口。<br>例如以下实例，我们通过使用 $watch 属性来实现数据的监听，$watch 必须添加在 Vue 实例之外才能实现正确的响应。<br>实例中通过点击按钮自动加 1。setTimeout 设置两秒后计算器的值加上 20 。</p></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>    &lt;p&gt;计数器:&#123;&#123; counter &#125;&#125;&lt;/p&gt;<br>    &lt;button @click=&quot;counter++&quot;&gt;click me&lt;/button&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>    const vm = new Vue(&#123;<br>        el: &quot;#app&quot;,<br>        data: &#123;counter: 1&#125;<br>    &#125;);<br>    vm.$watch(&apos;counter&apos;, (newValue, oldValue) =&gt; &#123;<br>        console.log(&quot;newValue:&quot;, newValue);<br>        console.log(&quot;oldValue:&quot;, oldValue);<br>    &#125;);<br>    setTimeout(function () &#123;<br>        vm.counter = 3333333;<br>    &#125;, 2000);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><blockquote><p>Vue 不允许在已经创建的实例上动态添加新的根级响应式属性。</p><p>　Vue 不能检测到对象属性的添加或删除，最好的方式就是在初始化实例前声明根级响应式属性，哪怕只是一个空值。</p></blockquote><p>＞如果我们需要在运行过程中实现属性的添加或删除，则可以使用全局 Vue，Vue.set 和 Vue.delete 方法。</p><h3 id="Vue-set"><a href="#Vue-set" class="headerlink" title="Vue.set"></a>Vue.set</h3><blockquote><p>　Vue.set 方法用于设置对象的属性，它可以解决 Vue 无法检测添加属性的限制，语法格式如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">Vue.set(target, key , value);<br></code></pre></td></tr></table></figure></p><p>参数说明:</p><ul><li>target 可以是对象或数组</li><li>key 可以是字符串或数字</li><li>value 可以是任何类型</li></ul></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id = &quot;app&quot;&gt;<br>&lt;p style = &quot;font-size:25px;&quot;&gt;计数器: &#123;&#123; products.id &#125;&#125;&lt;/p&gt;<br>&lt;button @click = &quot;products.id++&quot; style = &quot;font-size:25px;&quot;&gt;点我&lt;/button&gt;<br>&lt;/div&gt;<br>&lt;script type = &quot;text/javascript&quot;&gt;<br>var myproduct = &#123;&quot;id&quot;:1, name:&quot;book&quot;, &quot;price&quot;:&quot;20.00&quot;&#125;;<br>var vm = new Vue(&#123;<br>   el: &apos;#app&apos;,<br>   data: &#123;<br>      counter: 1,<br>      products: myproduct<br>   &#125;<br>&#125;);<br>Vue.set(myproduct, &apos;qty&apos;, 1);<br>console.log(vm);<br>vm.$watch(&apos;counter&apos;, function(nval, oval) &#123;<br>   alert(&apos;计数器值的变化 :&apos; + oval + &apos; 变为 &apos; + nval + &apos;!&apos;);<br>&#125;);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><blockquote><p>从控制台输出的结果可以看出 get/set 方法可用于qty 属性。</p></blockquote><h4 id="Vue-delete"><a href="#Vue-delete" class="headerlink" title="Vue.delete"></a>Vue.delete</h4><blockquote><p>Vue.delete 用于删除动态添加的属性 语法格式：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">Vue.delete(target, key)<br></code></pre></td></tr></table></figure></p><p>参数说明:</p><ul><li>target: 可以是对象或数组;</li><li>key: 可以是字符串或数字;</li></ul></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id = &quot;app&quot;&gt;<br>   &lt;p style = &quot;font-size:25px;&quot;&gt;计数器: &#123;&#123; products.id &#125;&#125;&lt;/p&gt;<br>   &lt;button @click = &quot;products.id++&quot; style = &quot;font-size:25px;&quot;&gt;点我&lt;/button&gt;<br>&lt;/div&gt;<br>&lt;script type = &quot;text/javascript&quot;&gt;<br>var myproduct = &#123;&quot;id&quot;:1, name:&quot;book&quot;, &quot;price&quot;:&quot;20.00&quot;&#125;;<br>var vm = new Vue(&#123;<br>   el: &apos;#app&apos;,<br>   data: &#123;<br>      counter: 1,<br>      products: myproduct<br>   &#125;<br>&#125;);<br>Vue.delete(myproduct, &apos;price&apos;);<br>console.log(vm);<br>vm.$watch(&apos;counter&apos;, function(nval, oval) &#123;<br>   alert(&apos;计数器值的变化 :&apos; + oval + &apos; 变为 &apos; + nval + &apos;!&apos;);<br>&#125;);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><blockquote><p>使用Vue.delete删除了product中的price属性；</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue学习笔记之混入</title>
      <link href="/2018/11/17/Vue-Mixin/"/>
      <url>/2018/11/17/Vue-Mixin/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue-js-混入"><a href="#Vue-js-混入" class="headerlink" title="Vue.js 混入"></a>Vue.js 混入</h2><blockquote><p>混入 (mixins)定义了一部分可复用的方法或者计算属性。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;script type = &quot;text/javascript&quot;&gt;<br>var vm = new Vue(&#123;<br>el: &apos;#databinding&apos;<br>&#125;);<br>// 定义一个混入对象<br>var myMixin = &#123;<br>created: function () &#123;<br>this.startmixin()<br>&#125;,<br>methods: &#123;<br>startmixin: function () &#123;<br>document.write(&quot;欢迎来到混入实例&quot;);<br>&#125;<br>&#125;<br>&#125;;<br>var Component = Vue.extend(&#123;<br>mixins: [myMixin]<br>&#125;)<br>var component = new Component();<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p></blockquote><h4 id="选项合并"><a href="#选项合并" class="headerlink" title="选项合并"></a>选项合并</h4><blockquote><p>当组件和混入对象含有同名选项时，这些选项将以恰当的方式混合。</p><p>比如，数据对象在内部会进行浅合并 (一层属性深度)，在和组件的数据发生冲突时以组件数据优先。</p><p>以下实例中，Vue 实例与混入对象包含了相同的方法。从输出结果可以看出两个选项合并了。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">var mixin = &#123;<br>    created: function () &#123;<br>        document.write(&apos;混入调用&apos; + &apos;&lt;br&gt;&apos;)<br>    &#125;<br>&#125;<br>new Vue(&#123;<br>    mixins: [mixin],<br>    created: function () &#123;<br>        document.write(&apos;组件调用&apos; + &apos;&lt;br&gt;&apos;)<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure></p><p>输出结果为:<br>混入调用<br>组件调用</p><p>如果 methods 选项中有相同的函数名，则 Vue 实例优先级会较高。如下实例，Vue 实例与混入对象的 methods 选项都包含了相同的函数：</p></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs undefined">var mixin = &#123;<br>    methods: &#123;<br>        hellworld() &#123;<br>            document.write(&apos;HelloWorld 方法&apos; + &apos;&lt;br&gt;&apos;);<br>        &#125;,<br>        samemethod() &#123;<br>            document.write(&apos;Mixin：相同方法名&apos; + &apos;&lt;br&gt;&apos;);<br>        &#125;<br>    &#125;<br>&#125;;<br>var vm = new Vue(&#123;<br>    mixins: [mixin],<br>    methods: &#123;<br>        start() &#123;<br>            document.write(&apos;start 方法&apos; + &apos;&lt;br&gt;&apos;);<br>        &#125;,<br>        samemethod() &#123;<br>            document.write(&apos;Main：相同方法名&apos; + &apos;&lt;br&gt;&apos;);<br>        &#125;<br>    &#125;<br>&#125;);<br>vm.hellworld();<br>vm.start();<br>vm.samemethod();<br></code></pre></td></tr></table></figure><blockquote><p>HelloWorld 方法<br>start 方法<br>Main：相同方法名</p><p>以上实例，我们调用了以下三个方法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">vm.hellworld();<br>vm.start();<br>vm.samemethod();<br></code></pre></td></tr></table></figure></p><p>从输出结果 methods 选项中如果碰到相同的函数名则 Vue 实例有更高的优先级会执行输出。</p></blockquote><h4 id="全局混入"><a href="#全局混入" class="headerlink" title="全局混入"></a>全局混入</h4><blockquote><p>也可以全局注册混入对象。注意使用！ 一旦使用全局混入对象，将会影响到 所有 之后创建的 Vue 实例。使用恰当时，可以为自定义对象注入处理逻辑。</p><p>谨慎使用全局混入对象，因为会影响到每个单独创建的 Vue 实例 (包括第三方模板)。</p></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;script&gt;<br>    Vue.mixin(&#123;<br>        created() &#123;<br>            let myOption = this.$options.myOption;<br>            if (myOption) &#123;<br>                document.write(myOption);<br>            &#125;<br>        &#125;<br>    &#125;);<br>    new Vue(&#123;<br>        myOption: &apos;Hello Vue!!&apos;<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue学习笔记之Ａｊａｘ</title>
      <link href="/2018/11/17/Vue-Ajax/"/>
      <url>/2018/11/17/Vue-Ajax/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue-js-Ajax-vue-resource"><a href="#Vue-js-Ajax-vue-resource" class="headerlink" title="Vue.js Ajax(vue-resource)"></a>Vue.js Ajax(vue-resource)</h2><blockquote><p> Vue 要实现异步加载需要使用到 vue-resource 库。</p></blockquote><h3 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h3><blockquote><p> 以下是一个简单的 Get 请求实例，请求地址是一个简单的 txt 文本：</p></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs undefined">window.onload = function()&#123;<br>    var vm = new Vue(&#123;<br>        el:&apos;#box&apos;,<br>        data:&#123;<br>            msg:&apos;Hello World!&apos;,<br>        &#125;,<br>        methods:&#123;<br>            get:function()&#123;<br>                //发送get请求<br>                this.$http.get(&apos;/try/ajax/ajax_info.txt&apos;).then(function(res)&#123;<br>                    document.write(res.body);    <br>                &#125;,function()&#123;<br>                    console.log(&apos;请求失败处理&apos;);<br>                &#125;);<br>            &#125;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>　如果需要传递数据，可以使用 this.$http.get(‘get.php’,jsonData) 格式，第二个参数 jsonData 就是传到后端的数据。</p></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">this.$http.get(&apos;get.php&apos;,&#123;a:1,b:2&#125;).then(function(res)&#123;<br>    document.write(res.body);    <br>&#125;,function(res)&#123;<br>    console.log(res.status);<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h4><blockquote><p>post 发送数据到后端，需要第三个参数 {emulateJSON:true}。<br>emulateJSON 的作用： 如果Web服务器无法处理编码为 application/json 的请求，你可以启用 emulateJSON 选项。</p></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs undefined">window.onload = function()&#123;<br>    var vm = new Vue(&#123;<br>        el:&apos;#box&apos;,<br>        data:&#123;<br>            msg:&apos;Hello World!&apos;,<br>        &#125;,<br>        methods:&#123;<br>            post:function()&#123;<br>                //发送 post 请求<br>                this.$http.post(&apos;/try/ajax/demo_test_post.php&apos;,&#123;name:&quot;呵呵哈哈&quot;,url:&quot;http://www.wanglichao.top&quot;&#125;,  &#123;emulateJSON:true&#125;).then(function(res)&#123;<br>                    document.write(res.body);    <br>                &#125;,function(res)&#123;<br>                    console.log(res.status);<br>                &#125;);<br>            &#125;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>demo_test_post.php 代码如下：</p></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;?php<br>$name = isset($_POST[&apos;name&apos;]) ? htmlspecialchars($_POST[&apos;name&apos;]) : &apos;&apos;;<br>$city = isset($_POST[&apos;url&apos;]) ? htmlspecialchars($_POST[&apos;url&apos;]) : &apos;&apos;;<br>echo &apos;网站名: &apos; . $name;<br>echo &quot;\n&quot;;<br>echo &apos;URL 地址: &apos; .$city;<br>?&gt;<br></code></pre></td></tr></table></figure><h4 id="语法-amp-API"><a href="#语法-amp-API" class="headerlink" title="语法 &amp; API"></a>语法 &amp; API</h4><blockquote><p>　你可以使用全局对象方式 Vue.http 或者在一个 Vue 实例的内部使用 this.$http来发起 HTTP 请求。</p></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">// 基于全局Vue对象使用http<br>Vue.http.get(&apos;/someUrl&apos;, [options]).then(successCallback, errorCallback);<br>Vue.http.post(&apos;/someUrl&apos;, [body], [options]).then(successCallback, errorCallback);<br><br>// 在一个Vue实例内使用$http<br>this.$http.get(&apos;/someUrl&apos;, [options]).then(successCallback, errorCallback);<br>this.$http.post(&apos;/someUrl&apos;, [body], [options]).then(successCallback, errorCallback);<br></code></pre></td></tr></table></figure><blockquote><p>vue-resource 提供了 7 种请求 API(REST 风格)：</p></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">get(url, [options])<br>head(url, [options])<br>delete(url, [options])<br>jsonp(url, [options])<br>post(url, [body], [options])<br>put(url, [body], [options])<br>patch(url, [body], [options])<br></code></pre></td></tr></table></figure><blockquote><p>　除了 jsonp 以外，另外 6 种的 API 名称是标准的 HTTP 方法。</p><p>options 参数说明:</p></blockquote><table><thead><tr><th>参数</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>url</td><td>string</td><td>请求的目标URL</td></tr><tr><td>body</td><td>Object, FormData, string</td><td>作为请求体发送的数据</td></tr><tr><td>headers</td><td>　    Object</td><td>作为请求头部发送的头部对象</td></tr><tr><td>params</td><td>Object</td><td>作为URL参数的参数对象</td></tr><tr><td>method</td><td>string</td><td>HTTP方法 (例如GET，POST，…)</td></tr><tr><td>timeout</td><td>number</td><td>请求超时（单位：毫秒） (0表示永不超时)</td></tr><tr><td>before</td><td>function(request)</td><td>在请求发送之前修改请求的回调函数</td></tr><tr><td>progress</td><td>function(event)</td><td>用于处理上传进度的回调函数ProgressEvent</td></tr><tr><td>credentials</td><td>boolean</td><td>是否需要出示用于跨站点请求的凭据</td></tr><tr><td>emulateHTTP</td><td>boolean</td><td>是否需要通过设置X-HTTP-Method-Override头部并且以传统POST方式发送PUT，PATCH和DELETE请求。</td></tr><tr><td>emulateJSON</td><td>boolean</td><td>设置请求体的类型为application/x-www-form-urlencoded</td></tr></tbody></table><blockquote><p> 通过如下属性和方法处理一个请求获取到的响应对象：</p></blockquote><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td> url</td><td>string</td><td>响应的URL源</td></tr><tr><td>body</td><td>Object, Blob, string</td><td>响应体数据</td></tr><tr><td>headers</td><td>Header</td><td>请求头部对象</td></tr><tr><td>ok</td><td>boolean</td><td>当HTTP响应码为200到299之间的数值时该值为true</td></tr><tr><td>status</td><td>number</td><td>HTTP响应吗</td></tr><tr><td>statusText</td><td>string</td><td>HTTP响应状态</td></tr><tr><td>方法</td><td>类型</td><td>描述</td><td></td></tr><tr><td>text()</td><td>约定值</td><td>以字符串方式返回响应体</td></tr><tr><td>json()</td><td>约定值</td><td>以格式化后的json对象方式返回响应体</td></tr><tr><td>blob()</td><td>约定值</td><td>以二进制Blob对象方式返回响应体</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue学习笔记之路由</title>
      <link href="/2018/11/17/Vue-Router/"/>
      <url>/2018/11/17/Vue-Router/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue-js-路由"><a href="#Vue-js-路由" class="headerlink" title="Vue.js 路由"></a>Vue.js 路由</h2><blockquote><p>Vue.js 路由语序我们通过不同的URL访问不同的内容;<br>通过Vue.js可以实现多视图的单页Web应用SPA(single page web application);</p></blockquote><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><blockquote><p>1 直接下载或CDN<br><a href="https://unpkg.com/vue-router/dist/vue-router.js" target="_blank" rel="noopener">https://unpkg.com/vue-router/dist/vue-router.js</a><br>2 NPM 推荐使用淘宝镜像<br> $ cnpm install vue-router</p></blockquote><h4 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h4><blockquote><p>Vue.js + vue-router  可以很简单的实现单页应用;<br><code>&lt;router-link&gt;</code>是一个组件,该组件用于设置一个导航链接,切换不同HTML内容.to属性为目标地址,即:要显示的内容<br>以下实例中将vue-router加入,然后配置组件和路由映射,在告诉vue-router在哪里渲染组件:<br><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;script src="https://unpkg.com/vue/dist/vue.js"&gt;&lt;/script&gt;<br>&lt;script src="https://unpkg.com/vue-router/dist/vue-router.js"&gt;&lt;/script&gt;<br>&lt;div id="app"&gt;<br>&lt;h1&gt;Hello, Vue-Router!!!&lt;/h1&gt;<br>&lt;p&gt;<br>&lt;router-link to="/foo"&gt;Go to Foo-Component&lt;/router-link&gt;<br>&lt;router-link to="/bar"&gt;Go to Bar-Component&lt;/router-link<br>&lt;/p&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure></p></blockquote><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义路由组件</span><br><span class="hljs-keyword">const</span> Foo = &#123;<span class="hljs-attr">template</span>:<span class="hljs-string">'&lt;div&gt;Foo-Component&lt;/div&gt;'</span>&#125;;<br><span class="hljs-keyword">const</span> Bar  = &#123;<span class="hljs-attr">template</span>:<span class="hljs-string">'&lt;div&gt;Bar-Component&lt;/div&gt;'</span>&#125;;<br><span class="hljs-comment">// 定义路由配置</span><br><span class="hljs-keyword">const</span> routes = &#123;<br>&#123;<span class="hljs-attr">path</span>: <span class="hljs-string">'/foo'</span>, <span class="hljs-attr">component</span>: Foo&#125;,<br>&#123;<span class="hljs-attr">path</span>: <span class="hljs-string">'/bar'</span>, <span class="hljs-attr">component</span>: Bar&#125;<br>&#125;;<br><span class="hljs-comment">// 创建router实例,出入routes配置;</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;<br>routes      <span class="hljs-comment">// routes:routes 缩写</span><br>&#125;)<br><span class="hljs-comment">// 创建和挂载根实例</span><br><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;<br>router<br>&#125;).$mount(<span class="hljs-string">"#app"</span>);<br></code></pre></td></tr></table></figure><blockquote><p>点击过的导航链接都会加上样式 class=”router-link-exact-active router-link-active”;</p><h4 id="lt-router-link-gt-属性"><a href="#lt-router-link-gt-属性" class="headerlink" title="&lt;router-link&gt; 属性"></a><code>&lt;router-link&gt;</code> 属性</h4><p>router-link 的属性:</p><h5 id="to"><a href="#to" class="headerlink" title="to"></a>to</h5><p>表示目标路由的链接,当被点击后,内部会立刻把to的值传到router.push(),所以这个值可以是一个字符串或者描述目标位置的对象<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">字符串<br>&lt;router-link to=&quot;home&apos;&gt;Home&lt;/router-link&gt;<br>使用v-bind的js表达式<br>&lt;router-link v-bind:to=&quot;&apos;home&apos;&quot;&gt;Home&lt;/router-link&gt;<br>简写方式<br>&lt;router-link :to=&quot;&apos;home&apos;&quot;&gt;Home&lt;/router-link&gt;<br><br>&lt;router-link :to=&quot;&#123;path: &apos;home&apos;&#125;&quot;&gt;&lt;/router-link&gt;<br>&lt;router-link :to=&quot;&#123;name: &apos;user&apos;, params: &#123;userId: 123&#125;&#125;&quot;&gt;&lt;/router-link&gt;<br>&lt;router-link :to=&quot;&#123;path: &apos;register&apos;,query: &#123;plan: &apos;private&apos;&#125;&#125;&quot;&gt;&lt;/router-link&gt;<br></code></pre></td></tr></table></figure></p></blockquote><h5 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h5><blockquote><p>设置replace属性的话,当点击时,会调用router.replace()而不是router.push(),导航后不会留下history记录;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;router-link :to=&quot;&#123;path: &apos;/aaa&apos;&#125;&quot; replace&gt;&lt;/router-link&gt;<br></code></pre></td></tr></table></figure></p></blockquote><h5 id="append"><a href="#append" class="headerlink" title="append"></a>append</h5><blockquote><p>设置append属性后,则在当前(相对)路径前添加基路径<br>例如: 从/a导航到一个相对路径b,如果没有配置append,则路径为/b,如果配了,则为/a/b;</p><h4 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h4><p>有时候想要<code>&lt;router-link&gt;</code>渲染成某种标签,例如<code>&lt;li&gt;</code>,可以使用tag prop类指定何种标签,同样它还是会监听点击,触发导航;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;router-link to=&quot;/foo&quot; tag=&quot;li&quot;&gt;foo&lt;/router-link&gt;<br></code></pre></td></tr></table></figure></p></blockquote><h4 id="active-class"><a href="#active-class" class="headerlink" title="active-class"></a>active-class</h4><blockquote><p>设置链接激活时使用的css类名,可以通过以下代码来替代:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;style&gt;<br>.active &#123;<br>background-color: #333;<br>&#125;<br>&lt;/style&gt;<br>&lt;p&gt;<br>&lt;router-link v-bind:to=&quot;&#123;path: &apos;/user&apos;&#125;&quot; active-class=&quot;active&quot;&gt;user&lt;/router-link&gt;<br>&lt;/p&gt;<br></code></pre></td></tr></table></figure></p></blockquote><h4 id="exact-active-class"><a href="#exact-active-class" class="headerlink" title="exact-active-class"></a>exact-active-class</h4><blockquote><p>配置当链接被精确匹配的时候应该激活的class;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;router-link v-bind:to=&quot;&#123;path; &apos;/goods&apos;&#125;&quot; exact-active-class=&quot;active&quot;&gt;xxx&lt;/router-link&gt;<br></code></pre></td></tr></table></figure></p></blockquote><h4 id="event"><a href="#event" class="headerlink" title="event"></a>event</h4><blockquote><p>声明可以用来触发导航的事件,可以是一个字符串或是一个包含字符串的数组;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;router-link :to=&quot;&#123;path: &apos;/home&apos;&#125;&quot; event=&quot;mousevoer&quot;&gt;Home&lt;/router-link&gt;<br></code></pre></td></tr></table></figure></p></blockquote><h4 id="exact-active-class-和-active-class-的区别"><a href="#exact-active-class-和-active-class-的区别" class="headerlink" title="exact-active-class 和 active-class 的区别"></a>exact-active-class 和 active-class 的区别</h4><blockquote><p>router-link 默认情况下的路由是模糊匹配;<br>例如:当前路径是/article/1,那么也会激活<code>&lt;router-link to=&quot;/article&quot;&gt;</code>,所以当设置exact-active-class以后,这个router-link只有在当前路由被全包含匹配时才会被激活exact-active-class中的class;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;router-link to=&quot;/goods&quot;&gt; active-class=&quot;router-active&quot;&gt;&lt;/router-link&gt;<br>当用户访问/goods/1时会被激活为<br>&lt;a href=&quot;#/goods&quot; class=&quot;router-active&quot; rel=&quot;nofollow&quot;&gt;&lt;/a&gt;<br>而使用:<br>&lt;router-link to=&quot;/goods&quot; exact-active-class=&quot;router-active&quot;&gt;&lt;/router-link&gt;<br>当用户访问/goods/1时,不会激活这个link的class:<br>&lt;a href=&quot;#/goods&quot; res=&quot;nofollow&quot;&gt;&lt;/a&gt;<br></code></pre></td></tr></table></figure></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue学习笔记之过渡/动画</title>
      <link href="/2018/11/17/Vue-Transition/"/>
      <url>/2018/11/17/Vue-Transition/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue-js-过渡-动画"><a href="#Vue-js-过渡-动画" class="headerlink" title="Vue.js 过渡 / 动画"></a>Vue.js 过渡 / 动画</h2><h3 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h3><blockquote><p>Vue 在插入/更新或者移出DOM时,提供多种不同方式的应用过渡效果;<br>Vue 提供了内置的过渡封装组件,该组件用于包裹要实现过渡效果的组件;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;transition name=&quot;nameOfTransition&quot;&gt;<br>&lt;div&gt;&lt;/div&gt;<br>&lt;/transition&gt;<br></code></pre></td></tr></table></figure></p><p>通过实例来理解Vue的过渡是如何实现的:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;style&gt;<br>        .fade-enter-active,<br>        .fade-leave-active &#123;<br>            transition: opacity 1s;<br>        &#125;<br>        .fade-enter,<br>        .fade-leave-to &#123;<br>            opacity: 0;<br>        &#125;<br>    &lt;/style&gt;<br>&lt;div id=&quot;app&quot;&gt;<br>        &lt;button @click=&quot;show=!show&quot;&gt;点我&lt;/button&gt;<br>        &lt;transition name=&quot;fade&quot;&gt;<br>            &lt;p v-show=&quot;show&quot; :style=&quot;styleObj&quot;&gt;动画示例&lt;/p&gt;<br>        &lt;/transition&gt;<br>    &lt;/div&gt;<br>&lt;script&gt;<br>    new Vue(&#123;<br>        el: &quot;#app&quot;,<br>        data: &#123;<br>            show: true,<br>            styleObj: &#123;<br>                fontSize: &apos;30px&apos;,<br>                color: &apos;red&apos;<br>            &#125;<br>        &#125;<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><p>此过渡其实就是一个淡入淡出的效果,Vue在元素显示于隐藏的过渡中,提供了6个class来切换;</p><ul><li>v-enter: 定义进入过渡的开始状态,在元素被插入之前生效,在元素被插入之后的下一帧移除;</li><li>v-enter-active: 定义进入过渡生效时的状态,在整个进入过渡的阶段中应用,在元素被插入之前生效,在过渡/动画完成只I后移除,这个类可以被用来定义进入过渡的过程时间/延迟和曲线函数;</li><li>v-enter-to: 2.1.8版本及以上: 定义进入过渡的结束状态,在元素被插入之后下一帧生效(与此同时v-enter被移除),在过渡/动画完成之后移除;</li><li>v-leave: 定义离开过渡的开始状态,在离开过渡被触发时立刻生效,在下一帧被移除;</li><li>v-leave-active: 定义离开过渡生效时的状态,在整个离开过渡的阶段中应用,在离开过渡被触发时生效,在过渡/动画完成之后移除.这个类可以被用来定义过渡的过程时间/延迟和曲线函数;</li><li>v-leave-to: 2.1.8版本及以上: 定义离开过渡的结束状态,在离开过渡被触发之后下一帧生效(与此同时v-leave被移除),在过渡/动画完成之后移除;<br>对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 <code>&lt;transition&gt;</code>，则 v- 是这些类名的默认前缀。如果你使用了<code>&lt;transition name=&quot;my-transition&quot;&gt;</code>，那么 v-enter 会替换为 my-transition-enter。</li></ul><p>v-enter-active 和 v-leave-active 可以控制进入/离开过渡的不同的缓和曲线</p></blockquote><h4 id="css过渡"><a href="#css过渡" class="headerlink" title="css过渡"></a>css过渡</h4><blockquote><p>通常我们都使用 CSS 过渡来实现效果。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;style&gt;<br>/* 可以设置不同的进入和离开动画 */<br>/* 设置持续时间和动画函数 */<br>.slide-fade-enter-active &#123;<br>  transition: all .3s ease;<br>&#125;<br>.slide-fade-leave-active &#123;<br>  transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);<br>&#125;<br>.slide-fade-enter, .slide-fade-leave-to<br>/* .slide-fade-leave-active 用于 2.1.8 以下版本 */ &#123;<br>  transform: translateX(10px);<br>  opacity: 0;<br>&#125;<br>&lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;div id = &quot;databinding&quot;&gt;<br>&lt;button v-on:click = &quot;show = !show&quot;&gt;点我&lt;/button&gt;<br>&lt;transition name=&quot;slide-fade&quot;&gt;<br>    &lt;p v-if=&quot;show&quot;&gt;哈哈哈&lt;/p&gt;<br>&lt;/transition&gt;<br>&lt;/div&gt;<br>&lt;script type = &quot;text/javascript&quot;&gt;<br>new Vue(&#123;<br>    el: &apos;#databinding&apos;,<br>    data: &#123;<br>        show: true<br>    &#125;<br>&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p></blockquote><h4 id="css动画"><a href="#css动画" class="headerlink" title="css动画"></a>css动画</h4><blockquote><p>CSS 动画用法类似 CSS 过渡，但是在动画中 v-enter 类名在节点插入 DOM 后不会立即删除，而是在 animationen 事件触发时删除。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs undefined">    &lt;style&gt;<br>        .bounce-enter-active &#123;<br>            animation: bounce-in .5s;<br>        &#125;<br>        .bounce-leave-active &#123;<br>            animation: bounce-in .5s reverse;<br>        &#125;<br>        @keyframes bounce-in &#123;<br>            0% &#123;<br>                transform: scale(0);<br>            &#125;<br>            50% &#123;<br>                transform: scale(1.5);<br>            &#125;<br>            100% &#123;<br>                transform: scale(1);<br>            &#125;<br>        &#125;<br>    &lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;div id = &quot;app&quot;&gt;<br>    &lt;button @click = &quot;show = !show&quot;&gt;点我&lt;/button&gt;<br>    &lt;transition name=&quot;bounce&quot;&gt;<br>        &lt;p v-if=&quot;show&quot;&gt;啊哈哈,看我!!看我!!看我!!&lt;/p&gt;<br>    &lt;/transition&gt;<br>&lt;/div&gt;<br>&lt;script type = &quot;text/javascript&quot;&gt;<br>    new Vue(&#123;<br>        el: &apos;#app&apos;,<br>        data: &#123;<br>            show: true<br>        &#125;<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p></blockquote><h4 id="自定义过渡的类名"><a href="#自定义过渡的类名" class="headerlink" title="自定义过渡的类名"></a>自定义过渡的类名</h4><blockquote><p>我们可以通过以下特性来自定义过渡类名：</p><ul><li>enter-class</li><li>enter-active-class</li><li>enter-to-class (2.1.8+)</li><li>leave-class</li><li>leave-active-class</li><li>leave-to-class (2.1.8+)<br>自定义过渡的类名优先级高于普通的类名，这样就能很好的与第三方（如：animate.css）的动画库结合使用。<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id = &quot;app&quot;&gt;<br>    &lt;button @click = &quot;show = !show&quot;&gt;点我&lt;/button&gt;<br>    &lt;transition name=&quot;custom-classes-transition&quot;<br>                enter-active-class=&quot;animated tada&quot;<br>                leave-active-class=&quot;animated bounceOutRight&quot;<br>    &gt;<br>        &lt;p v-if=&quot;show&quot;&gt;啊哈哈,看我!!看我!!看我!!&lt;/p&gt;<br>    &lt;/transition&gt;<br>&lt;/div&gt;<br>&lt;script type = &quot;text/javascript&quot;&gt;<br>    new Vue(&#123;<br>        el: &apos;#app&apos;,<br>        data: &#123;<br>            show: true<br>        &#125;<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ul></blockquote><h4 id="同时使用过渡和动画"><a href="#同时使用过渡和动画" class="headerlink" title="同时使用过渡和动画"></a>同时使用过渡和动画</h4><blockquote><p>Vue 为了知道过渡的完成，必须设置相应的事件监听器。它可以是 transitionend 或 animationend ，这取决于给元素应用的 CSS 规则。如果你使用其中任何一种，Vue 能自动识别类型并设置监听。</p><p>但是，在一些场景中，你需要给同一个元素同时设置两种过渡动效，比如 animation 很快的被触发并完成了，而 transition 效果还没结束。在这种情况中，你就需要使用 type 特性并设置 animation 或 transition 来明确声明你需要 Vue 监听的类型。</p></blockquote><h4 id="显性的过渡持续时间"><a href="#显性的过渡持续时间" class="headerlink" title="显性的过渡持续时间"></a>显性的过渡持续时间</h4><blockquote><p>在很多情况下，Vue 可以自动得出过渡效果的完成时机。默认情况下，Vue 会等待其在过渡效果的根元素的第一个 transitionend 或 animationend 事件。然而也可以不这样设定——比如，我们可以拥有一个精心编排的一系列过渡效果，其中一些嵌套的内部元素相比于过渡效果的根元素有延迟的或更长的过渡效果。</p><p>在这种情况下你可以用<code>&lt;transition&gt;</code>组件上的 duration 属性定制一个显性的过渡持续时间 (以毫秒计)：<br>`</p><p><transition :duration="1000">…</transition><br><code>你也可以定制进入和移出的持续时间：</code></p><p><transition :duration="{ enter: 500, leave: 800 }">…</transition><br>`</p><h3 id="JavaScript-钩子"><a href="#JavaScript-钩子" class="headerlink" title="JavaScript 钩子"></a>JavaScript 钩子</h3><p>可以在属性中声明JavaScript钩子;<br><figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">transition</span><br>  <span class="hljs-attr">v-on:before-enter</span>=<span class="hljs-string">"beforeEnter"</span><br>  <span class="hljs-attr">v-on:enter</span>=<span class="hljs-string">"enter"</span><br>  <span class="hljs-attr">v-on:after-enter</span>=<span class="hljs-string">"afterEnter"</span><br>  <span class="hljs-attr">v-on:enter-cancelled</span>=<span class="hljs-string">"enterCancelled"</span><br> <br>  <span class="hljs-attr">v-on:before-leave</span>=<span class="hljs-string">"beforeLeave"</span><br>  <span class="hljs-attr">v-on:leave</span>=<span class="hljs-string">"leave"</span><br>  <span class="hljs-attr">v-on:after-leave</span>=<span class="hljs-string">"afterLeave"</span><br>  <span class="hljs-attr">v-on:leave-cancelled</span>=<span class="hljs-string">"leaveCancelled"</span><br>&gt;</span><br>  <span class="hljs-comment">&lt;!-- ... --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br></code></pre></td></tr></table></figure></p></blockquote><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript">methods: &#123;<br>  <span class="hljs-attr">beforeEnter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;,<br>  <span class="hljs-attr">enter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el, done</span>) </span>&#123;<br>  <span class="hljs-comment">// 此回调函数是可选项的设置</span><br>  <span class="hljs-comment">// 与 CSS 结合时使用</span><br>    done()<br>  &#125;,<br>  <span class="hljs-attr">afterEnter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;,<br>  <span class="hljs-attr">enterCancelled</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>  beforeLeave: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;,<br><br>  <span class="hljs-attr">leave</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el, done</span>) </span>&#123;<br>     <span class="hljs-comment">// 此回调函数是可选项的设置</span><br>    <span class="hljs-comment">// 与 CSS 结合时使用</span><br>    done()<br>  &#125;,<br>  <span class="hljs-attr">afterLeave</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;,<br>  <span class="hljs-comment">// leaveCancelled 只用于 v-show 中</span><br>  leaveCancelled: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这些钩子函数可以结合 CSS transitions/animations 使用，也可以单独使用。</p><p>当只用 JavaScript 过渡的时候，在 enter 和 leave 中必须使用 done 进行回调。否则，它们将被同步调用，过渡会立即完成。</p><p>推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=”false”，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响</p><h4 id="初始渲染的过渡"><a href="#初始渲染的过渡" class="headerlink" title="初始渲染的过渡"></a>初始渲染的过渡</h4><p>可以通过 appear 特性设置节点在初始渲染的过渡<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;transition appear&gt;<br>  &lt;!-- ... --&gt;<br>&lt;/transition&gt;<br></code></pre></td></tr></table></figure></p><p>这里默认和进入/离开过渡一样，同样也可以自定义 CSS 类名。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;transition<br>  appear<br>  appear-class=&quot;custom-appear-class&quot;<br>  appear-to-class=&quot;custom-appear-to-class&quot; (2.1.8+)<br>  appear-active-class=&quot;custom-appear-active-class&quot;<br>&gt;<br>  &lt;!-- ... --&gt;<br>&lt;/transition&gt;<br></code></pre></td></tr></table></figure></p><p>　自定义 JavaScript 钩子：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;transition<br>  appear<br>  v-on:before-appear=&quot;customBeforeAppearHook&quot;<br>  v-on:appear=&quot;customAppearHook&quot;<br>  v-on:after-appear=&quot;customAfterAppearHook&quot;<br>  v-on:appear-cancelled=&quot;customAppearCancelledHook&quot;<br>&gt;<br>  &lt;!-- ... --&gt;<br>&lt;/transition&gt;<br></code></pre></td></tr></table></figure></p></blockquote><h4 id="多个元素的过渡"><a href="#多个元素的过渡" class="headerlink" title="多个元素的过渡"></a>多个元素的过渡</h4><blockquote><p>我们可以设置多个元素的过渡，一般列表与描述：</p><p>需要注意的是当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;transition&gt;<br>  &lt;table v-if=&quot;items.length &gt; 0&quot;&gt;<br>    &lt;!-- ... --&gt;<br>  &lt;/table&gt;<br>  &lt;p v-else&gt;抱歉，没有找到您查找的内容。&lt;/p&gt;<br>&lt;/transition&gt;<br></code></pre></td></tr></table></figure></p></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;transition&gt;<br>  &lt;button v-if=&quot;isEditing&quot; key=&quot;save&quot;&gt;<br>    Save<br>  &lt;/button&gt;<br>  &lt;button v-else key=&quot;edit&quot;&gt;<br>    Edit<br>  &lt;/button&gt;<br>&lt;/transition&gt;<br></code></pre></td></tr></table></figure><blockquote><p>在一些场景中，也可以通过给同一个元素的 key 特性设置不同的状态来代替 v-if 和 v-else，上面的例子可以重写为：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;transition&gt;<br>  &lt;button v-bind:key=&quot;isEditing&quot;&gt;<br>    &#123;&#123; isEditing ? &apos;Save&apos; : &apos;Edit&apos; &#125;&#125;<br>  &lt;/button&gt;<br>&lt;/transition&gt;<br></code></pre></td></tr></table></figure></p><p>使用多个 v-if 的多个元素的过渡可以重写为绑定了动态属性的单个元素过渡。例如：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;transition&gt;<br>  &lt;button v-if=&quot;docState === &apos;saved&apos;&quot; key=&quot;saved&quot;&gt;<br>    Edit<br>  &lt;/button&gt;<br>  &lt;button v-if=&quot;docState === &apos;edited&apos;&quot; key=&quot;edited&quot;&gt;<br>    Save<br>  &lt;/button&gt;<br>  &lt;button v-if=&quot;docState === &apos;editing&apos;&quot; key=&quot;editing&quot;&gt;<br>    Cancel<br>  &lt;/button&gt;<br>&lt;/transition&gt;<br></code></pre></td></tr></table></figure></p><p>可以重写为:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;transition&gt;<br>  &lt;button v-bind:key=&quot;docState&quot;&gt;<br>    &#123;&#123; buttonMessage &#125;&#125;<br>  &lt;/button&gt;<br>&lt;/transition&gt;<br>//-----------------------------<br>computed: &#123;<br>  buttonMessage: function () &#123;<br>    switch (this.docState) &#123;<br>      case &apos;saved&apos;: return &apos;Edit&apos;<br>      case &apos;edited&apos;: return &apos;Save&apos;<br>      case &apos;editing&apos;: return &apos;Cancel&apos;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue学习笔记之自定义指令</title>
      <link href="/2018/11/17/Vue-Custom-Directive/"/>
      <url>/2018/11/17/Vue-Custom-Directive/</url>
      
        <content type="html"><![CDATA[<h3 id="Vue-js-自定义指令"><a href="#Vue-js-自定义指令" class="headerlink" title="Vue.js 自定义指令"></a>Vue.js 自定义指令</h3><blockquote><p>除了默认设置的核心指令(v-model 和v-show ), Vue也允许注册自定义指令;<br>注册一个全局指令v-focus, 该指令的功能是在页面加载的时候,元素获得焦点:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>    &lt;input v-focus&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>    Vue.directive(&apos;focus&apos;, &#123;<br>        inserted(el) &#123;<br>            el.focus();<br>        &#125;<br>    &#125;);<br>    new Vue(&#123;<br>        el: &apos;#app&apos;<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><p>也可以在实例使用directives选项来注册局部指令,这样指令只能在这个实例中使用;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>    &lt;input v-focus&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>    new Vue(&#123;<br>        el: &apos;#app&apos;,<br>        directives: &#123;<br>            focus: &#123;<br>                inserted(el) &#123;<br>                    el.focus();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="钩子"><a href="#钩子" class="headerlink" title="钩子"></a>钩子</h3><h4 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h4><blockquote><p>指定定义函数提供了几个钩子函数:</p><ul><li>bind: 只调用一次,指令第一次绑定到元素时调用,用这个钩子函数可以定义一个在绑定时执行一次的初始化动作;</li><li>inserted: 被绑定元素插入父节点时调用(父节点存在即可调用,不必存在于document中);</li><li>update: 被绑定元素所在的模板更新时调用,而不论绑定值是否变化,通过比较更新前后的绑定值,可以忽略不必要的模板更新;<br>componentUpdated: 被绑定元素所在模板完成一次更新周期时调用;<br>unbind: 只调用一次,指令与元素解绑时调用;</li></ul></blockquote><h4 id="钩子函数参数"><a href="#钩子函数参数" class="headerlink" title="钩子函数参数"></a>钩子函数参数</h4><blockquote><p>钩子函数的参数有:</p><ul><li>el: 指令所绑定的元素,可以用来直接操作DOM;</li><li>binding: 一个对象,包含以下属性:<ul><li>name:指令名,不包含’v-‘前缀;</li><li>value:指令的绑定值,例如: v-my-directive=”1+1”,value的值是2;</li><li>oldValue: 指令绑定的前一个值,仅在update和componentUpdated钩子中可用,无论值是否改变都可用;</li><li>expression: 绑定值的表达式或变量名,例如:v-my-directive=”1+1”,expression的值是”1+1”;</li><li>arg: 传给指令的参数,例如: v-my-directive:foo, arg的值是foo;</li><li>modifiers: 一个包含修饰符的对象;例如: v-my-directive.foo.bar,修饰符对象modifiers的值是{foo:true,bar:true};</li></ul></li><li>vnode: Vue编译生成的虚拟节点;</li><li>oldVnode: 上一个虚拟节点,仅在update和componentUpdated钩子中可用;<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot; v-custom:hello.a.b=&quot;message&quot;&gt;&lt;/div&gt;<br>&lt;script&gt;<br>    Vue.directive(&apos;custom&apos;, &#123;<br>        bind: function (el, binding, vnode) &#123;<br>            let s = JSON.stringify;<br>            el.innerHTML =<br>                &apos;name:&apos; + s(binding.name) + &apos;&lt;br&gt;&apos; +<br>                &apos;value:&apos; + s(binding.value) + &apos;&lt;br&gt;&apos; +<br>                &apos;expression:&apos; + s(binding.expression) + &apos;&lt;br&gt;&apos; +<br>                &apos;argument:&apos; + s(binding.arg) + &apos;&lt;br&gt;&apos; +<br>                &apos;modifiers:&apos; + s(binding.modifiers) + &apos;&lt;br&gt;&apos; +<br>                &apos;vnode keys:&apos; + Object.keys(vnode).join(&apos;,&apos;)<br>        &#125;<br>    &#125;);<br>    new Vue(&#123;<br>        el: &apos;#app&apos;,<br>        data: &#123;<br>            message: &apos;哈哈哈哈哈哈&apos;<br>        &#125;<br>    &#125;);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ul></blockquote><p>`</p><ul><li>name:”custom”</li><li>value:”哈哈哈哈哈哈”</li><li>expression:”message”</li><li>argument:”hello”</li><li>modifiers:{“a”:true,”b”:true}</li><li>vnodekeys:tag,data,children,text,elm,ns,context,functionalContext,key,componentOptions,componentInstance,parent,raw,isStatic,isRootInsert,isComment,isCloned,isOnce<br>`<blockquote><p>有时候不需要其他钩子函数,可以简写函数.如下:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">Vue.directive(&apos;custom&apos;,function(el,binding)&#123;<br>el.style.backgroundColor = binding.value.color;<br>&#125;)<br></code></pre></td></tr></table></figure></blockquote></li></ul><blockquote><p>指令函数可以接受所有合法的JavaScript表达式:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&apos;app&apos;&gt;<br>&lt;div v-custom=&quot;&#123;color: &apos;green&apos;,text: &apos;好好学习&apos;&#125;&quot;&gt;&lt;/div&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>Vue.directive(&apos;custom&apos;, function (el, binding)&#123;<br>el.innerHTML = binding.value.text;<br>el.style.backgroundColor = binding.value.color;<br>&#125;);<br>new Vue(&#123;<br>el: &apos;#app&apos;<br>&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue学习笔记之监听属性</title>
      <link href="/2018/11/16/Vue-watch/"/>
      <url>/2018/11/16/Vue-watch/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue-js监听属性"><a href="#Vue-js监听属性" class="headerlink" title="Vue.js监听属性"></a>Vue.js监听属性</h2><blockquote><p>计数器<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>    &lt;p&gt;计数器: &#123;&#123;counter&#125;&#125;&lt;/p&gt;<br>    &lt;button @click=&quot;counter++&quot;&gt;点我&lt;/button&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>    const vm = new Vue(&#123;<br>        el: &quot;#app&quot;,<br>        data: &#123;<br>            counter: 1<br>        &#125;<br>    &#125;);<br>    vm.$watch(&apos;counter&apos;, (mewValue, oldValue)=&gt;&#123;<br>        console.log(&apos;计数器值得变化:&apos; + oldValue + &apos;变为&apos; + mewValue);<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><p>千米换算<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>    &lt;input type=&quot;text&quot; v-model=&quot;kilometers&quot;&gt;<br>    &lt;input type=&quot;text&quot; v-model=&quot;meters&quot;&gt;<br>    &lt;p id=&quot;info&quot;&gt;&lt;/p&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>    const vm = new Vue(&#123;<br>        el: &quot;#app&quot;,<br>        data: &#123;<br>            kilometers: 0,<br>            meters: 0<br>        &#125;,<br>       watch: &#123;<br>            kilometers(value) &#123;<br>                this.kilometers = value;<br>                this.meters = value * 1000<br>            &#125;,<br>           meters(value) &#123;<br>                this.kilometers = value / 1000;<br>                this.meters = value;<br>           &#125;<br>       &#125;<br>    &#125;);<br>    vm.$watch(&apos;kilometers&apos;, (newValue, oldValue) =&gt; &#123;<br>        document.getElementById(&quot;info&quot;).innerHTML = &apos;old ==&gt;&apos; + oldValue + &apos;,new ==&gt;&apos; + newValue;<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>    &lt;table&gt;<br>        &lt;tr&gt;<br>            &lt;th&gt;序号&lt;/th&gt;<br>            &lt;th&gt;商品名称&lt;/th&gt;<br>            &lt;th&gt;商品价格&lt;/th&gt;<br>            &lt;th&gt;购买数量&lt;/th&gt;<br>            &lt;th&gt;操作&lt;/th&gt;<br>        &lt;/tr&gt;<br>        &lt;tr v-for=&quot;iphone in Ip_Json&quot;&gt;<br>            &lt;td&gt;&#123;&#123; iphone.id &#125;&#125;&lt;/td&gt;<br>            &lt;td&gt;&#123;&#123; iphone.name &#125;&#125;&lt;/td&gt;<br>            &lt;td&gt;&#123;&#123; iphone.price &#125;&#125;&lt;/td&gt;<br>            &lt;td&gt;<br>                &lt;button @click=&quot;iphone.count-=1&quot;&gt;-&lt;/button&gt;<br>                &#123;&#123; iphone.count &#125;&#125;<br>                &lt;button @click=&quot;iphone.count+=1&quot;&gt;+&lt;/button&gt;<br>            &lt;/td&gt;<br>            &lt;td&gt;<br>                &lt;button @click=&quot;iphone.count=0&quot;&gt;移出&lt;/button&gt;<br>            &lt;/td&gt;<br>        &lt;/tr&gt;<br>    &lt;/table&gt;<br>    总价: $&#123;&#123; totalPrice() &#125;&#125;<br>&lt;/div&gt;<br>&lt;script&gt;<br>    const vm = new Vue(&#123;<br>        el: &quot;#app&quot;,<br>        data: &#123;<br>            Ip_Json: [<br>                &#123;<br>                    id: 1,<br>                    name: &apos;iPhone 8&apos;,<br>                    price: 5000,<br>                    count: 1<br>                &#125;,<br>                &#123;<br>                    id: 2,<br>                    name: &apos;iPhone XS&apos;,<br>                    price: 6000,<br>                    count: 1<br>                &#125;,<br>                &#123;<br>                    id: 3,<br>                    name: &apos;iPhone XR&apos;,<br>                    price: 7000,<br>                    count: 1<br>                &#125;<br>            ]<br>        &#125;,<br>        methods: &#123;<br>            totalPrice() &#123;<br>                let totalP = 0;<br>                for (let i = 0, len = this.Ip_Json.length; i &lt; len; i++) &#123;<br>                    totalP += this.Ip_Json[i].price * this.Ip_Json[i].count;<br>                &#125;<br>                return totalP;<br>            &#125;<br>        &#125;<br>    &#125;);<br><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue学习笔记之组件</title>
      <link href="/2018/11/16/Vue-Component/"/>
      <url>/2018/11/16/Vue-Component/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue-js-组件"><a href="#Vue-js-组件" class="headerlink" title="Vue.js 组件"></a>Vue.js 组件</h2><blockquote><p>组件(Component)是Vue.js最强大的功能之一;<br>组件可以扩展HTML元素,封装可重用的代码;<br>组件系统让我们可以用独立可复用的小组件来构建大型应用,几乎任意类型的应用的界面都可以抽象为一个组件树:</p></blockquote><p><img src="/2018/11/16/Vue-Component/Vue-component/Vue-components-tree.png" alt="ComponentTree"></p><blockquote><p>注册一个全局组件的语法格式:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">Vue.component(tagName,options)<br></code></pre></td></tr></table></figure></p><p>tagName为组件名,options为配置选项,注册后可以用下面的方式调用U组件:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;tagName&gt;&lt;/tagName&gt;<br></code></pre></td></tr></table></figure></p></blockquote><h4 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h4><blockquote><p>　所有实例都能用全局组件<br>　实例：注册一个全局组件并调用:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>    &lt;good&gt;&lt;/good&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>    // 注册组件<br>    Vue.component(&quot;good&quot;, &#123;<br>        template: &quot;&lt;h1&gt;我是注册的自定义组件!!!&lt;/h1&gt;&quot;<br>    &#125;);<br>    // 根实例<br>    new Vue(&#123;<br>        el: &quot;#app&quot;<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p></blockquote><h4 id="局部组件"><a href="#局部组件" class="headerlink" title="局部组件"></a>局部组件</h4><blockquote><p>也可以在实例选项中注册局部组件,这样的最贱只能在这个实例中使用:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>    &lt;good&gt;&lt;/good&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>    const Child = &#123;<br>        template: &apos;&lt;h1&gt;我是自定义组件:Child-Component!!!&lt;/h1&gt;&apos;<br>    &#125;;<br>    // 根实例<br>    new Vue(&#123;<br>        el: &quot;#app&quot;,<br>        components: &#123;<br>            &quot;good&quot;: Child<br>        &#125;<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p></blockquote><h4 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h4><blockquote><p>prop是父组件用来传递参数的一个自定义属性;<br>父组件的数据需要通过props把数据传给子组件,子组件需要显式地用props选项声明prop;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>    &lt;h1&gt;我是根组件&lt;/h1&gt;<br>    &lt;good message=&quot;Hello, Vue.js!!!&quot;&gt;&lt;/good&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>    new Vue(&#123;<br>        el: &quot;#app&quot;,<br>        components: &#123;<br>            &quot;good&quot;: &#123;<br>                props: [&quot;message&quot;],<br>                template: `<br>                    &lt;div&gt;<br>                        &lt;h1&gt;我是自定义组件: goodComponent&lt;/h1&gt;<br>                        &lt;h2&gt;父组件传来的信息: &#123;&#123; message &#125;&#125;&lt;/h2&gt;<br>                    &lt;/div&gt;<br>                `<br>            &#125;<br>        &#125;<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p></blockquote><h4 id="动态Prop"><a href="#动态Prop" class="headerlink" title="动态Prop"></a>动态Prop</h4><blockquote><p>类似于用v-bind绑定HTML特性到一个表达式,也可以用v-bind动态绑定props的值到父组件的数据中,每当父组件的数据变化时,该变化也会传导给子组件;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>    &lt;h1&gt;我是根组件&lt;/h1&gt;<br>    &lt;input type=&quot;text&quot; v-model=&quot;parentMessage&quot;&gt;<br>    &lt;hr&gt;<br>    &lt;good :message=&quot;parentMessage&quot;&gt;&lt;/good&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>    new Vue(&#123;<br>        el: &quot;#app&quot;,<br>        data: &#123;<br>            parentMessage: &apos;父组件的数据&apos;<br>        &#125;,<br>        components: &#123;<br>            &quot;good&quot;: &#123;<br>                props: [&quot;message&quot;],<br>                template: `<br>                    &lt;div&gt;<br>                        &lt;h1&gt;我是自定义组件: goodComponent&lt;/h1&gt;<br>                        &lt;h2&gt;父组件传来的信息: &#123;&#123; message &#125;&#125;&lt;/h2&gt;<br>                    &lt;/div&gt;<br>                `<br>            &#125;<br>        &#125;<br>    &#125;)<br></code></pre></td></tr></table></figure></p><p>注意: prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是子组件的变化不会传递到父组件;</p><h4 id="Prop-验证"><a href="#Prop-验证" class="headerlink" title="Prop 验证"></a>Prop 验证</h4><p>组件可以为props指定验证要求<br>prop 是一个对象而不是字符串数组时,它包含验证要求;</p></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs undefined">Vue.copmonent(&apos;example&apos;, &#123;<br>        props: &#123;<br>            // 基础类型检测(null指任意类型都可以)<br>            propA: Number,<br>            // 多种类型<br>            propB: [String, Number],<br>            // 必须且是字符串<br>            propC: &#123;<br>                type: String,<br>                required: true<br>            &#125;,<br>            // 有默认值,数字类型<br>            propD: &#123;<br>                type: Number,<br>                default: 1000<br>            &#125;,<br>            // 数组/对象的默认值应当由一个工厂函数返回<br>            propE: &#123;<br>                type: Object,<br>                default: function() &#123;<br>                    return &#123;message: &apos;hello&apos;&#125;<br>                &#125;<br>            &#125;,<br>            // 自定义函数<br>            propF: &#123;<br>                validator: function(value) &#123;<br>                    return value &gt; 100;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;)<br></code></pre></td></tr></table></figure><p>type 可以是下面原生构造器:</p><blockquote><ul><li>String</li><li>Number</li><li>Boolean</li><li>Function</li><li>Object</li><li>Array<br>type也可以是一个自定义构造器,使用instanceof检测;</li></ul></blockquote><h4 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h4><blockquote><p>父组件是使用props传递数据给子组件,但如果子组件要把数据传递回去,就需要使用自定义事件;<br>我们可以使用v-on绑定自定义事件,每个Vue实例都实现了事件接口(Events interface);</p><ul><li>使用 $on(eventName) 监听事件</li><li>使用 $emit(eventName) 触发事件<br>另外,父组件可以在使用子组件的地方直接用v-on来监听子组件触发的事件;<br>以下示例中子组件已经和它外部完全解耦了,它所做的指示触发一个父组件关心的内部事件;<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>    &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt;<br>    &lt;button-counter v-on:increment=&quot;incrementTotal&quot;&gt;&lt;/button-counter&gt;<br>    &lt;button-counter v-on:increment=&quot;incrementTotal&quot;&gt;&lt;/button-counter&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>    Vue.component(&apos;button-counter&apos;, &#123;<br>        data: function() &#123;<br>            return &#123;<br>                counter: 0<br>            &#125;<br>        &#125;,<br>        template: &apos;&lt;button @click=&quot;incrementHandler&quot;&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;&apos;,<br>        methods: &#123;<br>            incrementHandler() &#123;<br>                this.counter += 1;<br>                this.$emit(&quot;increment&quot;);<br>            &#125;<br>        &#125;<br>    &#125;);<br>    new Vue(&#123;<br>        el: &quot;#app&quot;,<br>        data: &#123;<br>            total: 0<br>        &#125;,<br>        methods: &#123;<br>            incrementTotal() &#123;<br>                this.total += 1;<br>            &#125;<br>        &#125;<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ul><p>如果想在某个组件的根元素上监听一个原生事件,可以使用.native修饰v-on;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;my-component v-on:click.native=&quot;doSomething&quot;&gt;&lt;/my-component&gt;<br></code></pre></td></tr></table></figure></p><p>父组件给子组件传值的时候,如果想传入一个变量,写法如下:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">Vue.component(&apos;child&apos;, &#123;<br>props: [&apos;message&apos;],<br>template: &apos;&lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;<br>&#125;)<br>new Vue(&#123;<br>el: &apos;#app&apos;,<br>data: &#123;<br>message: &apos;hello, vue.js&apos;<br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure></p><p>子组件通过$emit触发父组件的方法时,如果需要传递参数,可在方法后面加参数数组:<br>比如 $emit(‘FunctionName’) 需要传递参数时: $emit(‘FunctionName’, [arg1, arg2,…])<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">methods: &#123;<br>incrementHandler: function (v) &#123;<br>if (v == 1) &#123;<br>this.counter -=1;<br>this.$emit(&apos;increment&apos;, [1]);<br>&#125; else &#123;<br>this.counter += 1;<br>this.$emit(&apos;increment&apos;, [2]);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue学习笔记之样式绑定</title>
      <link href="/2018/11/16/Vue-bind-style/"/>
      <url>/2018/11/16/Vue-bind-style/</url>
      
        <content type="html"><![CDATA[<h3 id="Vue-js样式绑定"><a href="#Vue-js样式绑定" class="headerlink" title="Vue.js样式绑定"></a>Vue.js样式绑定</h3><h4 id="class"><a href="#class" class="headerlink" title="class"></a>class</h4><blockquote><p>class 与style 时HTML元素的属性,用于设置元素的样式,用v-bind来设置 样式属性;<br>v-bind在处理class和style时,表达式的结果类型除了字符串意外,还可以是对象或数组;</p><h4 id="class属性绑定"><a href="#class属性绑定" class="headerlink" title="class属性绑定"></a>class属性绑定</h4><p>为b-bind:class设置一个对象,动态的切换class;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;style&gt;<br>.active &#123;<br>width: 100px;<br>height: 100px;<br>background: green;<br>&#125;<br>&lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;div id=&quot;app&quot;&gt;<br>  &lt;div v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/div&gt;<br>&lt;/div&gt;<br><br>&lt;script&gt;<br>new Vue(&#123;<br>  el: &apos;#app&apos;,<br>  data: &#123;<br>  // 将 isActive 设置为 true 显示了一个绿色的 div 块，如果设置为 false 则不显示<br>    isActive: true<br>  &#125;<br>&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><p>也可以在对象中传入更多属性用来动态切换多个 class 。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div class=&quot;box&quot; :class=&quot;&#123;active: isActive, &apos;text-danger&apos;: hasError&#125;&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure></p><p>也可以直接绑定数据里的一个对象：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>    &lt;div class=&quot;box&quot; :class=&quot;objClass&quot;&gt;&lt;/div&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>    new Vue(&#123;<br>        el: &quot;#app&quot;,<br>        data: &#123;<br>            objClass: &#123;<br>                isActive: true,<br>                hasError: true<br>            &#125;<br>        &#125;<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><p>也可以在这里绑定返回对象的计算属性,这是一个常用且强大的模式<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>    &lt;div class=&quot;box&quot; :class=&quot;classObj&quot;&gt;&lt;/div&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>    new Vue(&#123;<br>        el: &quot;#app&quot;,<br>        data: &#123;<br>            isActive: true,<br>            error: &#123;<br>                value: false,<br>                type: &apos;fatal&apos;<br>            &#125;<br>        &#125;,<br>        computed: &#123;<br>            classObj() &#123;<br>                return &#123;<br>                    base: true,<br>                    active: this.isActive &amp;&amp; !this.error.value,<br>                    &apos;text-danger&apos;: this.error.value &amp;&amp; this.error.type === &apos;fatal&apos;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><p>传一个数组给v-bind:class<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>    &lt;div class=&quot;box&quot; :class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>    new Vue(&#123;<br>        el: &quot;#app&quot;,<br>        data: &#123;<br>            activeClass: &apos;active&apos;,<br>            errorClass: &apos;text-danger&apos;<br>        &#125;<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><p>errorClass 始终存在，isActive 为 true 时添加 activeClass 类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div v-bind:class=&quot;[errorClass ,isActive ? activeClass : &apos;&apos;]&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure></p></blockquote><h4 id="style-内联样式"><a href="#style-内联样式" class="headerlink" title="style(内联样式)"></a>style(内联样式)</h4><blockquote><p>可以在 v-bind:style 直接设置样式：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&apos;app&apos;&gt;<br>&lt;div :style=&quot;&#123;color:activeColor, fontSize: fontSize + &apos;px&apos;&#125;&quot;&gt;哈哈&lt;/div&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure></p></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div style=&quot;color:green; font-size: 30px;&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><blockquote><p>可以直接绑定到一个样式对象,让模板更清晰;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure></p><p>v-bing:style 可以使用数组将多个样式对象应用到一个元素上;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div v-bind:style=&quot;[baseStyle, overridingStyle]&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue学习笔记之事件处理器</title>
      <link href="/2018/11/16/Vue-Events/"/>
      <url>/2018/11/16/Vue-Events/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue-js-事件处理器"><a href="#Vue-js-事件处理器" class="headerlink" title="Vue.js 事件处理器"></a>Vue.js 事件处理器</h2><blockquote><p>事件监听可以使用v-on指令:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>  &lt;button v-on:click=&quot;counter += 1&quot;&gt;增加 1&lt;/button&gt;<br>  &lt;p&gt;这个按钮被点击了 &#123;&#123; counter &#125;&#125; 次。&lt;/p&gt;<br>&lt;/div&gt;<br> <br>&lt;script&gt;<br>new Vue(&#123;<br>  el: &apos;#app&apos;,<br>  data: &#123;<br>    counter: 0<br>  &#125;<br>&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><p>通常情况下,需要使用一个方法来调用JavaScript方法;<br>v-on 可以接收一个定义的方法来调用;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>    &lt;button @click=&quot;greet&quot;&gt;Greet&lt;/button&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>    const app = new Vue(&#123;<br>        el: &apos;#app&apos;,<br>        data: &#123;<br>            name: &apos;Vue.js&apos;<br>        &#125;,<br>        methods: &#123;<br>            greet(event) &#123;<br>                console.log(&apos;Hello &apos; + this.name);<br>                if (event) &#123;<br>                    console.log(&quot;Event:&quot; + event.target.tagName);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><p>可以用内联JavaScript语句;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>  &lt;button v-on:click=&quot;say(&apos;hi&apos;)&quot;&gt;Say hi&lt;/button&gt;<br>  &lt;button v-on:click=&quot;say(&apos;what&apos;)&quot;&gt;Say what&lt;/button&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>new Vue(&#123;<br>  el: &apos;#app&apos;,<br>  methods: &#123;<br>    say(message) &#123;<br>      consle.log(message)<br>    &#125;<br>  &#125;<br>&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><blockquote><p>Vue.js为v-on提供了事件修饰符来处理DOM事件细节;<br>如:event.preventDefault()组织默认行为,或event.stopPropagation() 阻止冒泡;</p><ul><li>.stop</li><li>.prevent</li><li>.capture</li><li>.self</li><li>.once<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;a v-on:click.stop=&quot;doSomething&quot;&gt; 阻止单击事件冒泡<br>&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt; 提交事件不再重载页面<br>&lt;a v-on:click.stop.prevent=&quot;doSomething&quot;&gt; 串联修饰符<br>&lt;form v-on:submit.prevent&gt; 只有修饰符<br>&lt;div v-on:click.capture=&quot;doSomething&quot;&gt; 添加事件侦听器使用事件捕获模式<br>&lt;div v-on:click.self=&quot;doSomething&quot;&gt; 只当事件在该元素本身触发时触发回调(而不是子元素)<br>&lt;a v-on:click.once=&quot;doSomething&quot;&gt; click事件只能点击一次<br></code></pre></td></tr></table></figure></li></ul></blockquote><h4 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h4><blockquote><p>Vue 允许为v-on 在监听键盘事件时添加按键修好符;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;input v-on:keyup.13=&quot;submit&quot;&gt; 只有可以Code是13时调用submit;<br></code></pre></td></tr></table></figure></p><p>Vue为最常用的按键提供了别名;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;<br></code></pre></td></tr></table></figure></p><p>全部按键的别名</p><ul><li>.enter</li><li>.tab</li><li>.delete (捕获”删除键”和”退格键”)</li><li>.esc</li><li>.space</li><li>.up</li><li>.down</li><li>.left</li><li>.right</li><li>.ctrl</li><li>.alt</li><li>.shift</li><li>.meta<br>实例:<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;input @keyup.alt.67=&quot;doSomething&quot;&gt; Alt + C<br>&lt;div @click.ctrl=&quot;doSomething&quot;&gt;&lt;/div&gt; Ctrl+ Click<br></code></pre></td></tr></table></figure></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue学习笔记之表单</title>
      <link href="/2018/11/16/Vue-Form/"/>
      <url>/2018/11/16/Vue-Form/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue-js-表单"><a href="#Vue-js-表单" class="headerlink" title="Vue.js 表单"></a>Vue.js 表单</h2><blockquote><p>可以用v-model指令在表单空间元素上创建双向数据绑定;</p></blockquote><p><img src="/2018/11/16/Vue-Form/Vue-form/viewmodel.png" alt="viewmodel"></p><blockquote><p>v-model 会根据控件类型自动选取正确的方法来更新元素:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>  &lt;p&gt;input 元素：&lt;/p&gt;<br>  &lt;input v-model=&quot;message&quot; placeholder=&quot;请输入……&quot;&gt;<br>  &lt;p&gt;消息是: &#123;&#123; message &#125;&#125;&lt;/p&gt;<br>  &lt;p&gt;textarea 元素：&lt;/p&gt;<br>  &lt;p style=&quot;white-space: pre&quot;&gt;&#123;&#123; message2 &#125;&#125;&lt;/p&gt;<br>  &lt;textarea v-model=&quot;message2&quot; placeholder=&quot;多行文本输入……&quot;&gt;&lt;/textarea&gt;<br>&lt;/div&gt;<br> <br>&lt;script&gt;<br>new Vue(&#123;<br>  el: &apos;#app&apos;,<br>  data: &#123;<br>    message: &apos;心有远方&apos;,<br>    message2: &apos;www.wanglichao.top&apos;<br>  &#125;<br>&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p></blockquote><h6 id="复选按钮"><a href="#复选按钮" class="headerlink" title="复选按钮"></a>复选按钮</h6><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>    &lt;p&gt;单个复选框&lt;/p&gt;<br>    &lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;<br>    &lt;label for=&quot;checkbox&quot;&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt;<br>    &lt;p&gt;多个复选框&lt;/p&gt;<br>    &lt;input type=&quot;checkbox&quot; id=&quot;baidu&quot; value=&quot;baidu&quot; v-model=&quot;checkedNames&quot;&gt;<br>    &lt;label for=&quot;baidu&quot;&gt;baidu&lt;/label&gt;<br>    &lt;input type=&quot;checkbox&quot; id=&quot;google&quot; value=&quot;google&quot; v-model=&quot;checkedNames&quot;&gt;<br>    &lt;label for=&quot;google&quot;&gt;google&lt;/label&gt;<br>    &lt;input type=&quot;checkbox&quot; id=&quot;facebook&quot; value=&quot;facebook&quot; v-model=&quot;checkedNames&quot;&gt;<br>    &lt;label for=&quot;facebook&quot;&gt;facebook&lt;/label&gt;<br>    &lt;hr&gt;<br>    &lt;span&gt;选择的值是: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>    new Vue(&#123;<br>        el: &quot;#app&quot;,<br>        data: &#123;<br>            checked: false,<br>            checkedNames: []<br>        &#125;<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h6 id="单选按钮"><a href="#单选按钮" class="headerlink" title="单选按钮"></a>单选按钮</h6><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>    &lt;input type=&quot;radio&quot; id=&quot;google&quot; value=&quot;google&quot; v-model=&quot;picked&quot;&gt;<br>    &lt;label for=&quot;google&quot;&gt;Google&lt;/label&gt;<br>    &lt;input type=&quot;radio&quot; id=&quot;baidu&quot; value=&quot;baidu&quot; v-model=&quot;picked&quot;&gt;<br>    &lt;label for=&quot;baidu&quot;&gt;Baidu&lt;/label&gt;<br>    &lt;input type=&quot;radio&quot; id=&quot;taobao&quot; value=&quot;taobao&quot; v-model=&quot;picked&quot;&gt;<br>    &lt;label for=&quot;taobao&quot;&gt;Taobao&lt;/label&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>    new Vue(&#123;<br>        el: &quot;#app&quot;,<br>        data: &#123;<br>            picked: &quot;google&quot;<br>        &#125;<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><blockquote><p>select 列表<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>    &lt;select name=&quot;site&quot; v-model=&quot;selected&quot;&gt;<br>        &lt;option value=&quot;&quot;&gt;选择一个网站&lt;/option&gt;<br>        &lt;option value=&quot;www.wanglichao.top&quot;&gt;我的博客&lt;/option&gt;<br>        &lt;option value=&quot;www.google.com&quot;&gt;谷歌&lt;/option&gt;<br>        &lt;option value=&quot;www.baidu.com&quot;&gt;百度&lt;/option&gt;<br>    &lt;/select&gt;<br>    &lt;div&gt;<br>        &lt;h1&gt;&#123;&#123; selected &#125;&#125;&lt;/h1&gt;<br>    &lt;/div&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>    new Vue(&#123;<br>        el: &quot;#app&quot;,<br>        data: &#123;<br>            selected: &quot;&quot;<br>        &#125;<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p></blockquote><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><h6 id="lazy"><a href="#lazy" class="headerlink" title=".lazy"></a>.lazy</h6><blockquote><p>在默认情况下,v-model在input事件中同步输入框的值与数据,但可以添加一个修饰符lazy,从而转变为在change事件中同步;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">在&quot;change&quot;而不是&quot;input&quot;事件中更新<br>&lt;input v-model.lazy=&quot;message&quot;&gt;<br></code></pre></td></tr></table></figure></p></blockquote><h6 id="number"><a href="#number" class="headerlink" title=".number"></a>.number</h6><blockquote><p>如果想自动将用户的输入值转为Number类型,可以添加一个修饰符number给v-model来处理输入值,如果原值的转换结果为NaN,则返回原值:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;<br></code></pre></td></tr></table></figure></p><p>这通常很有用,因为在type=”number”时HTML中输入的值也总是会返回字符串类型;</p><h6 id="trim"><a href="#trim" class="headerlink" title=".trim"></a>.trim</h6><p>如果要自动过滤用户输入的首尾空格,可以添加trim修饰符懂啊v-model上过滤输入;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;input v-model.trim=&quot;message&quot;&gt;<br></code></pre></td></tr></table></figure></p></blockquote><h6 id="全选与取消全选"><a href="#全选与取消全选" class="headerlink" title="全选与取消全选"></a>全选与取消全选</h6><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>    &lt;p&gt;全选&lt;/p&gt;<br>    &lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot; @change=&quot;changeAllChecked()&quot;&gt;<br>    &lt;label for=&quot;checkbox&quot;&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt;<br>    &lt;p&gt;多个复选框&lt;/p&gt;<br>    &lt;input type=&quot;checkbox&quot; id=&quot;google&quot; value=&quot;Google&quot; v-model=&quot;checkedNames&quot;&gt;<br>    &lt;label for=&quot;google&quot;&gt;Google&lt;/label&gt;<br>    &lt;input type=&quot;checkbox&quot; id=&quot;baidu&quot; value=&quot;Baidu&quot; v-model=&quot;checkedNames&quot;&gt;<br>    &lt;label for=&quot;baidu&quot;&gt;Baidu&lt;/label&gt;<br>    &lt;input type=&quot;checkbox&quot; id=&quot;taobao&quot; value=&quot;Taobao&quot; v-model=&quot;checkedNames&quot;&gt;<br>    &lt;label for=&quot;taobao&quot;&gt;Taobao&lt;/label&gt;<br>    &lt;hr&gt;<br>    &lt;span&gt;选择得知为: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>    new Vue(&#123;<br>        el: &quot;#app&quot;,<br>        data: &#123;<br>            checked: false,<br>            checkedNames: [],<br>            checkedArray: [&quot;谷歌&quot;, &quot;百度&quot;, &quot;淘宝&quot;]<br>        &#125;,<br>        methods: &#123;<br>            changeAllChecked() &#123;<br>                if (this.checked) &#123;<br>                    this.checkedNames = this.checkedArray;<br>                &#125; else &#123;<br>                    this.checkedNames = [];<br>                &#125;<br>            &#125;<br>        &#125;,<br>        watch: &#123;<br>            &quot;checkedNames&quot;() &#123;<br>                if (this.checkedNames.length === this.checkedArray.length) &#123;<br>                    this.checked = true;<br>                &#125; else &#123;<br>                    this.checked = false;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue学习笔记之计算属性</title>
      <link href="/2018/11/15/Vue-Computed/"/>
      <url>/2018/11/15/Vue-Computed/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue-js计算属性"><a href="#Vue-js计算属性" class="headerlink" title="Vue.js计算属性"></a>Vue.js计算属性</h2><blockquote><p>计算属性关键词: computed<br>计算属性在处理一些复杂逻辑的时候是非常有用的<br>如: 反转字符串实例的计算属性方式实现:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>    &lt;p&gt;反转之前的字符串:----&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;<br>    &lt;p&gt;反转之后的字符串:----&gt;&#123;&#123;reverseMessage&#125;&#125;&lt;/p&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>    new Vue(&#123;<br>        el: &quot;#app&quot;,<br>        data: &#123;<br>            message: &quot;Hello, World!!!&quot;<br>        &#125;,<br>        computed: &#123;<br>            reverseMessage() &#123;<br>                return this.message.split(&quot;&quot;).reverse().join(&apos;&apos;);<br>            &#125;<br>        &#125;<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><p>实例中声明了一个计算属性 reversedMessage ;<br>提供的函数将用作属性 vm.reversedMessage 的 getter ;<br>vm.reversedMessage 依赖于 vm.message;<br>在 vm.message 发生改变时，vm.reversedMessage 也会更新;</p></blockquote><h5 id="computed-对比-methods"><a href="#computed-对比-methods" class="headerlink" title="computed 对比 methods"></a>computed 对比 methods</h5><blockquote><p>我们可以使用 methods 来替代 computed，效果上两个都是一样的，&gt; 但是 computed 是基于它的依赖缓存，只有相关依赖发生改变时才会重新取值。<br>而使用 methods ，在重新渲染的时候，函数总会重新调用执行。<br>可以说使用 computed 性能会更好，但是如果不希望缓存，可以使用 methods 属性。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">methods: &#123;<br>  reversedMessage2: function () &#123;<br>    return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="computed-setter"><a href="#computed-setter" class="headerlink" title="computed setter"></a>computed setter</h3><blockquote><p>computed 属性默认只有getter,不过在需要时也可以提供一个setter;<br>在运行vm.site=”xxx”;的时候,setter会被调用,vm.name和vm.url也会被对应更新;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>    &lt;p&gt;&#123;&#123; site &#125;&#125;&lt;/p&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>    const vm = new Vue(&#123;<br>        el: &quot;#app&quot;,<br>        data: &#123;<br>            name: &quot;心有远方&quot;,<br>            url: &quot;http://www.wanglichao.top&quot;<br>        &#125;,<br>        computed: &#123;<br>            site: &#123;<br>                get() &#123;<br>                    return this.name + &quot; &quot; + this.url;<br>                &#125;,<br>                set(newValue) &#123;<br>                    let names = newValue.split(&quot; &quot;);<br>                    this.name = names[0];<br>                    this.url = names[names.length - 1]<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;);<br>    vm.site = &quot;勇往直前 www.wanglichao.top&quot;;<br>    document.write(&apos;name: &apos; + vm.name);<br>    document.write(&apos;&lt;br&gt;&apos;);<br>    document.write(&apos;url: &apos; + vm.url);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue学习笔记之循环语句</title>
      <link href="/2018/11/15/Vue-for/"/>
      <url>/2018/11/15/Vue-for/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue-js-循环语句"><a href="#Vue-js-循环语句" class="headerlink" title="Vue.js 循环语句"></a>Vue.js 循环语句</h2><blockquote><p>循环使用v-for指令;<br>v-for指令需要以 list in lists 形式的特殊语法,lists是源数据数组并且list时数组元素迭代的别名;<br>v-for可以绑定数据到数组来渲染一个列表;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>    &lt;ul&gt;<br>        &lt;li v-for=&quot;(arr, index) in array&quot; :key=&quot;index&quot;&gt;&#123;&#123;arr&#125;&#125;&lt;/li&gt;<br>    &lt;/ul&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>    new Vue(&#123;<br>        el: &quot;#app&quot;,<br>        data: &#123;<br>            array: [&apos;google&apos;, &apos;baidu&apos;, &apos;taobao&apos;, &apos;facebook&apos;]<br>        &#125;<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><p>也可以在模板中使用<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>    &lt;ul&gt;<br>        &lt;template v-for=&quot;arr in array&quot;&gt;<br>            &lt;li&gt;&#123;&#123;arr&#125;&#125;&lt;/li&gt;<br>        &lt;/template&gt;<br>    &lt;/ul&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>    new Vue(&#123;<br>        el: &quot;#app&quot;,<br>        data: &#123;<br>            array: [&apos;google&apos;, &apos;baidu&apos;, &apos;taobao&apos;, &apos;facebook&apos;]<br>        &#125;<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p></blockquote><h4 id="v-for-迭代对象"><a href="#v-for-迭代对象" class="headerlink" title="v-for 迭代对象"></a>v-for 迭代对象</h4><blockquote><p>v-for 可以通过一个对象的属性来迭代数据:<br>第一个参数是value,第二个参数(可选)是key,第三个参数(可选)是index;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>    &lt;ul&gt;<br>        &lt;template v-for=&quot;(value,key,index) in object&quot;&gt;<br>            &lt;li&gt;&#123;&#123;index&#125;&#125;:&#123;&#123;key&#125;&#125;: &#123;&#123;value&#125;&#125;&lt;/li&gt;<br>        &lt;/template&gt;<br>    &lt;/ul&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>    new Vue(&#123;<br>        el: &quot;#app&quot;,<br>        data: &#123;<br>            object: &#123;<br>                site1:&apos;google&apos;,<br>                site2:&apos;baidu&apos;,<br>                site3:&apos;taobao&apos;,<br>                site4:&apos;facebook&apos;<br>            &#125;<br>        &#125;<br>    &#125;)<br></code></pre></td></tr></table></figure></p><p>v-for可以直接迭代整数<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>  &lt;ul&gt;<br>    &lt;li v-for=&quot;n in 10&quot;&gt;<br>     &#123;&#123; n &#125;&#125;<br>    &lt;/li&gt;<br>  &lt;/ul&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure></p><p>嵌套迭代对象<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>    &lt;ul&gt;<br>        &lt;li v-for=&quot;(value,key,index) in object&quot;&gt;<br>            &lt;p v-if=&quot;typeof value != &apos;object&apos;&quot;&gt;&#123;&#123;value&#125;&#125; ===&gt; &#123;&#123;key&#125;&#125;&lt;/p&gt;<br>            &lt;p v-else&gt;嵌套对象:&#123;&#123;value&#125;&#125;&lt;/p&gt;<br>            &lt;ul v-if=&quot;typeof value == &apos;object&apos;&quot;&gt;<br>                &lt;li v-for=&quot;(val, key, index) in value&quot;&gt;<br>                    &#123;&#123;val&#125;&#125; ===&gt; &#123;&#123;key&#125;&#125;<br>                &lt;/li&gt;<br>            &lt;/ul&gt;<br>        &lt;/li&gt;<br>    &lt;/ul&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>    new Vue(&#123;<br>        el: &quot;#app&quot;,<br>        data: &#123;<br>            object: &#123;<br>                site1: &apos;谷歌&apos;,<br>                site2: &apos;百度&apos;,<br>                site3: &apos;淘宝&apos;,<br>                object2: &#123;<br>                    name1: &quot;京东&quot;,<br>                    name2: &quot;天猫&quot;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><p>乘法表<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>    &lt;div v-for=&quot;n in 9&quot;&gt;<br>        &lt;b v-for=&quot;m in n&quot;&gt;<br>            &#123;&#123;m&#125;&#125;*&#123;&#123;n&#125;&#125;=&#123;&#123;m*n&#125;&#125;<br>        &lt;/b&gt;<br>    &lt;/div&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>    new Vue(&#123;<br>        el: &quot;#app&quot;<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue学习笔记之条件语句</title>
      <link href="/2018/11/15/Vue-if/"/>
      <url>/2018/11/15/Vue-if/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue-js条件语句"><a href="#Vue-js条件语句" class="headerlink" title="Vue.js条件语句"></a>Vue.js条件语句</h2><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断:"></a>条件判断:</h3><h4 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h4><blockquote><p>条件判断使用v-if指令:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>    &lt;button @click=&quot;isShow=!isShow&quot;&gt;显示或隐藏&lt;/button&gt;<br>    &lt;p v-if=&quot;isShow&quot;&gt;能看到我吗?&lt;/p&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>    new Vue(&#123;<br>        el: &quot;#app&quot;,<br>        data: &#123;<br>            isShow: true<br>        &#125;<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p></blockquote><h4 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a>v-else</h4><blockquote><p>可以用v-else指令给v-if添加一个else块:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>&lt;div v-if=&quot;Math.random() &gt; 0.5&quot;&gt;<br>  哈哈<br>&lt;/div&gt;<br>&lt;div v-else&gt;<br>  呵呵<br>&lt;/div&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>new Vue(&#123;<br>  el: &apos;#app&apos;<br>&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p></blockquote><h4 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a>v-else-if</h4><blockquote><p>v-else-if 在2.1.0中新增,用作v-if的else-if块,可以链式使用;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div id=&quot;app&quot;&gt;<br>    &lt;div v-if=&quot;type === &apos;A&apos;&quot;&gt;<br>      A<br>    &lt;/div&gt;<br>    &lt;div v-else-if=&quot;type === &apos;B&apos;&quot;&gt;<br>      B<br>    &lt;/div&gt;<br>    &lt;div v-else-if=&quot;type === &apos;C&apos;&quot;&gt;<br>      C<br>    &lt;/div&gt;<br>    &lt;div v-else&gt;<br>      Not A/B/C<br>    &lt;/div&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure></p><p>v-else v-else-if v-else 必须跟在v-if或者v-else之后; </p></blockquote><h4 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h4><p>根据true或者false来展示或者隐藏元素;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div v-show=&quot;true&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure></p><h4 id="v-if-和-v-show-的区别"><a href="#v-if-和-v-show-的区别" class="headerlink" title="v-if 和 v-show 的区别"></a>v-if 和 v-show 的区别</h4><blockquote><p>在切换 v-if 块时，Vue.js 有一个局部编译/卸载过程，因为 v-if 之中的模板也可能包括数据绑定或子组件。v-if 是真实的条件渲染，因为它会确保条件块在切换当中合适地销毁与重建条件块内的事件监听器和子组件。</p><p>v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——在条件第一次变为真时才开始局部编译（编译会被缓存起来）。</p><p>相比之下，v-show 简单得多——元素始终被编译并保留，只是简单地基于 CSS 切换。</p><p>一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。</p><p>v-if 是动态添加，当值为 false 时，是完全移除该元素，即 dom 树中不存在该元素。</p><p>v-show 仅是隐藏 / 显示，值为 false 时，该元素依旧存在于 dom 树中。若其原有样式设置了 display: none 则会导致其无法正常显示。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React学习笔记之ajax</title>
      <link href="/2018/11/15/React-ajax/"/>
      <url>/2018/11/15/React-ajax/</url>
      
        <content type="html"><![CDATA[<h2 id="React-AJAX"><a href="#React-AJAX" class="headerlink" title="React AJAX"></a>React AJAX</h2><blockquote><p>React组件的数据可以通过componentDidMount方法中的ajax来获取,当从服务端获取数据时可以将数据存储在state中,再用this.setState()方法重新渲染UI.<br>当使用异步加载数据的时候,在组件卸载前使用componentWillUnmount来取消未完成的请求;<br>以下实例演示了获取 Github 用户最新 gist 共享描述:</p></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class UserGist extends React.Component &#123;<br>        constructor(props) &#123;<br>            super(props);<br>            this.state = &#123;<br>                username : &apos;&apos;,<br>                lastGistUrl: &apos;&apos;<br>            &#125;;<br>        &#125;<br><br>        componentDidMount() &#123;<br>            this.serverRequest = $.get(this.props.source, res =&gt; &#123;<br>                let lastGist = res[0];<br>                this.setState(&#123;<br>                    username: lastGist.owner.login,<br>                    lastGistUrl: lastGist.html_url<br>                &#125;);<br>            &#125;);<br>        &#125;<br><br>        componentWillUnmount() &#123;<br>            this.serverRequest.abort();<br>        &#125;<br><br>        render() &#123;<br>            return (<br>                &lt;div&gt;<br>                    &#123;this.state.username&#125; 用户最新的Gist共享地址:<br>                    &lt;a href=&#123;this.state.lastGistUrl&#125;&gt;&#123;this.state.lastGistUrl&#125;&lt;/a&gt;<br>                &lt;/div&gt;<br>            )<br>        &#125;<br>    &#125;<br><br>    ReactDOM.render(<br>        &lt;UserGist source=&quot;https://api.github.com/users/octocat/gists&quot; /&gt;,<br>        document.getElementById(&quot;example&quot;)<br>    )<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> react </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React学习笔记之表单与事件</title>
      <link href="/2018/11/15/React-form-and-events/"/>
      <url>/2018/11/15/React-form-and-events/</url>
      
        <content type="html"><![CDATA[<h2 id="Reactor-表单与事件"><a href="#Reactor-表单与事件" class="headerlink" title="Reactor 表单与事件"></a>Reactor 表单与事件</h2><blockquote><p>HTML表单元素与Reactor中的其它DOM元素有所不同,因为表单元素生来就保留一些内部状态;<br>在HTML当中,像input,textarea和select这类表单元素会维持自身状态,并根据用户输入进行更新,但在React中,可变的状态通常保存在组件的状态属性中,并且只能用setState()方法进行更新;</p></blockquote><h5 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h5><blockquote><p>在实例中设置了输入框input的值value={this.state.data},在输入框的值发生变化时我们可以更新state,我们可以使用onChange事件来监听input的变化,并修改state;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class Content extends React.Component &#123;<br>        render() &#123;<br>            return (<br>                &lt;div&gt;<br>                    &lt;input type=&quot;text&quot;<br>                           value=&#123;this.props.myDataProp&#125;<br>                           onChange=&#123;this.props.updateStateProp&#125;<br>                    /&gt;<br>                    &lt;h4&gt;&#123;this.props.myDataProp&#125;&lt;/h4&gt;<br>                &lt;/div&gt;<br>            )<br>        &#125;<br>    &#125;<br>    class HelloMessage extends React.Component &#123;<br>        constructor(props) &#123;<br>            super(props);<br>            this.state = &#123;value: &quot;Hello, React!&quot;&#125;;<br>        &#125;<br>        handleChange(e) &#123;<br>            this.setState(&#123;value: e.target.value&#125;);<br>        &#125;<br>        render() &#123;<br>            let value = this.state.value;<br>            return (<br>                &lt;div&gt;<br>                    &lt;Content myDataProp=&#123;value&#125;<br>                             updateStateProp=&#123;(e)=&gt;this.handleChange(e)&#125;<br>                    /&gt;<br>                &lt;/div&gt;<br>            )<br>        &#125;<br>    &#125;<br>    ReactDOM.render(<br>        &lt;HelloMessage /&gt;,<br>        document.getElementById(&apos;example&apos;)<br>    )<br></code></pre></td></tr></table></figure></p><p>上面的代码将渲染出一个值为Hello React! 的input元素,并通过onChange事件影响更新用户输入的值</p></blockquote><h5 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h5><blockquote><p>在以下实例中,将演示如何在子组件上使用表单,onChange方法将触发state的更新,并将更新的值传递到子组件的输入框的value上来重新渲染界面;<br>需要在父组件通过创建事件句柄(handleChange),并作为prop(updateStateProp)传递到子组件上;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs undefined">// 创建一个Content组件:<br>    class Content extends React.Component &#123;<br>        render() &#123;<br>            return (<br>                &lt;div&gt;<br>                    &lt;input type=&quot;text&quot;<br>                           value=&#123;this.props.myDataProp&#125;<br>                           onChange=&#123;this.props.updateStateProp&#125;<br>                    /&gt;<br>                    &lt;h4&gt;&#123;this.props.myDataProp&#125;&lt;/h4&gt;<br>                &lt;/div&gt;<br>            )<br>        &#125;<br>    &#125;<br><br>    // 创建HelloMessage组件<br>    class HelloMessage extends React.Component &#123;<br>        constructor(props) &#123;<br>            super(props);<br>            this.state = &#123;<br>                value: &apos;Hello, React&apos;<br>            &#125;;<br>        &#125;<br><br>        handleChange(e) &#123;<br>            this.setState(&#123;<br>                value: e.target.value<br>            &#125;)<br>        &#125;<br><br>        render() &#123;<br>            let value = this.state.value;<br>            return (<br>                &lt;div&gt;<br>                    &lt;Content myDataProp=&#123;value&#125;<br>                             updateStateProp=&#123;e=&gt;this.handleChange(e)&#125;<br>                    /&gt;<br>                &lt;/div&gt;<br>            )<br>        &#125;<br>    &#125;<br><br>    ReactDOM.render(<br>        &lt;HelloMessage/&gt;,<br>        document.getElementById(&quot;example&quot;)<br>    )<br></code></pre></td></tr></table></figure></p></blockquote><h5 id="Select下拉菜单"><a href="#Select下拉菜单" class="headerlink" title="Select下拉菜单"></a>Select下拉菜单</h5><blockquote><p>在React中,不使用selected属性,而是在根select标签上用value属性来表示选中项;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class LikeForm extends React.Component &#123;<br>        constructor(props) &#123;<br>            super(props);<br>            this.state = &#123;<br>                value: &apos;coconut&apos;<br>            &#125;<br>        &#125;<br>        handleChange(e) &#123;<br>            this.setState(&#123;<br>                value: e.target.value<br>            &#125;)<br>        &#125;<br>        handleSubmit(e) &#123;<br>            alert(&quot;你最喜欢的网站是&quot; + this.state.value);<br>            e.preventDefault();<br>        &#125;<br>        render() &#123;<br>            return (<br>                &lt;form onSubmit=&#123;(e)=&gt;this.handleSubmit(e)&#125;&gt;<br>                    &lt;label&gt;<br>                        &lt;select value=&#123;this.state.value&#125;<br>                                onChange=&#123;e=&gt;this.handleChange(e)&#125;<br>                        &gt;<br>                            &lt;option value=&quot;谷歌&quot;&gt;Google&lt;/option&gt;<br>                            &lt;option value=&quot;脸书&quot;&gt;Facebook&lt;/option&gt;<br>                            &lt;option value=&quot;淘宝&quot;&gt;Taobao&lt;/option&gt;<br>                            &lt;option value=&quot;草榴&quot;&gt;Caoliu&lt;/option&gt;<br>                        &lt;/select&gt;<br>                    &lt;/label&gt;<br>                    &lt;input type=&quot;submit&quot; value=&apos;提交&apos;/&gt;<br>                &lt;/form&gt;<br>            )<br>        &#125;<br>    &#125;<br>    ReactDOM.render(<br>        &lt;LikeForm /&gt;,<br>        document.getElementById(&apos;example&apos;)<br>    )<br></code></pre></td></tr></table></figure></p></blockquote><h5 id="多个表单"><a href="#多个表单" class="headerlink" title="多个表单"></a>多个表单</h5><blockquote><p>当需要处理多个input元素时,可以通过给每个元素添加一个name属性,来让处理函数根据event.target.name的值来选择做什么:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class Reservation extends React.Component &#123;<br>        constructor(props) &#123;<br>            super(props);<br>            this.state = &#123;<br>                isGoing: true,<br>                numberOfGuests: 10<br>            &#125;;<br>        &#125;<br>        handleInputChange(e) &#123;<br>            const target = e.target;<br>            const value = target.type === &apos;checkbox&apos; ? target.checked : target.value;<br>            const name = target.name;<br>            this.setState(&#123;<br>                [name]: value<br>            &#125;)<br>        &#125;<br>        render() &#123;<br>            return (<br>                &lt;form&gt;<br>                    &lt;label&gt;<br>                        是或否:<br>                        &lt;input type=&quot;checkbox&quot;<br>                               name=&quot;isGoing&quot;<br>                               checked=&#123;this.state.isGoing&#125;<br>                               onChange=&#123;e=&gt;this.handleInputChange(e)&#125;<br>                        /&gt;<br>                    &lt;/label&gt;<br>                    &lt;br/&gt;<br>                    &lt;label&gt;<br>                        统计数:<br>                        &lt;input type=&quot;number&quot;<br>                               name=&quot;numberOfGuests&quot;<br>                               value=&#123;this.state.numberOfGuests&#125;<br>                               onChange=&#123;e=&gt;this.handleInputChange(e)&#125;<br>                        /&gt;<br>                    &lt;/label&gt;<br>                &lt;/form&gt;<br>            )<br>        &#125;<br>    &#125;<br>    ReactDOM.render(<br>        &lt;Reservation /&gt;,<br>        document.getElementById(&quot;example&quot;)<br>    )<br></code></pre></td></tr></table></figure></p></blockquote><h5 id="React事件"><a href="#React事件" class="headerlink" title="React事件"></a>React事件</h5><blockquote><p>通过onClick事件来修改数据:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class Message extends React.Component &#123;<br>        constructor(props) &#123;<br>            super(props);<br>            this.state = &#123;<br>                value: &quot;Hello, React!&quot;<br>            &#125;;<br>        &#125;<br>        handleChangeValue() &#123;<br>            this.setState(&#123;<br>                value: &quot;Hello, Vue!&quot;<br>            &#125;)<br>        &#125;<br>        render() &#123;<br>            return (<br>                &lt;div&gt;<br>                    &lt;button onClick=&#123;()=&gt;this.handleChangeValue()&#125;&gt;点我&lt;/button&gt;<br>                    &lt;h4&gt;&#123;this.state.value&#125;&lt;/h4&gt;<br>                &lt;/div&gt;<br>            )<br>        &#125;<br>    &#125;<br>    ReactDOM.render(<br>        &lt;Message /&gt;,<br>        document.getElementById(&quot;example&quot;)<br>    )<br></code></pre></td></tr></table></figure></p><p>当需要从子组件中更新父组件的state时,需要在父组件通过创建事件句柄(handleChange),并作为prop(updateStateProp)传递到子组件上;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class Content extends React.Component &#123;<br>        render() &#123;<br>            return(<br>                &lt;div&gt;<br>                    &lt;button onClick=&#123;this.props.updateStateProp&#125;&gt;button&lt;/button&gt;<br>                    &lt;h4&gt;&#123;this.props.myDataProp&#125;&lt;/h4&gt;<br>                &lt;/div&gt;<br>            )<br>        &#125;<br>    &#125;<br>    class Message extends React.Component &#123;<br>        constructor(props) &#123;<br>            super(props);<br>            this.state = &#123;<br>                value: &quot;Hello React!!!&quot;<br>            &#125;;<br>        &#125;<br>        handleChange() &#123;<br>            this.setState(&#123;<br>                value: &quot;My App is Success!!!&quot;<br>            &#125;)<br>        &#125;<br>        render() &#123;<br>            return (<br>                &lt;div&gt;<br>                    &lt;Content updateStateProp=&#123;()=&gt;this.handleChange()&#125;<br>                             myDataProp=&#123;this.state.value&#125;<br>                    /&gt;<br>                &lt;/div&gt;<br>            )<br>        &#125;<br>    &#125;<br>    ReactDOM.render(<br>        &lt;Message /&gt;,<br>        document.getElementById(&quot;example&quot;)<br>    )<br></code></pre></td></tr></table></figure></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> react </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React学习笔记之渲染</title>
      <link href="/2018/11/14/React-refs/"/>
      <url>/2018/11/14/React-refs/</url>
      
        <content type="html"><![CDATA[<h2 id="React-Refs"><a href="#React-Refs" class="headerlink" title="React Refs"></a>React Refs</h2><blockquote><p>React支持一种非常特殊的属性 ref , 可以用来绑定到render()输出的任何组件上;<br>这个特殊的属性允许引用render()返回的相应的支撑实例(backing instance),这样就可以确保在任何时间都能拿到正确的实例;</p><h5 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h5><p>绑定一个ref属性到render的返回值上:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;input ref=&quot;myInput&quot;/&gt;<br></code></pre></td></tr></table></figure></p></blockquote><p>在其他代码中,通过this.refs获取支撑实例:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">let input = this.refs.myInput;<br>let inputValue = input.value;<br></code></pre></td></tr></table></figure></p><h4 id="完整实例"><a href="#完整实例" class="headerlink" title="完整实例"></a>完整实例</h4><blockquote><p>可以通过使用this来获取当前React组件,或使用ref来获取组件的引用;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class MyComponent extends React.Component &#123;<br>  handleClick() &#123;<br>    // 使用原生的DOM API获取焦点<br>    this.refs.myInput.focus();<br>  &#125;<br>  render() &#123;<br>    // 当组件插入到DOM后，ref属性添加一个组件的引用于到this.refs<br>    return (<br>      &lt;div&gt;<br>        &lt;input type=&quot;text&quot; ref=&quot;myInput&quot; /&gt;<br>        &lt;input<br>          type=&quot;button&quot;<br>          value=&quot;点我输入框获取焦点&quot;<br>          onClick=&#123;this.handleClick.bind(this)&#125;<br>        /&gt;<br>      &lt;/div&gt;<br>    );<br>  &#125;<br>&#125;<br> <br>ReactDOM.render(<br>  &lt;MyComponent /&gt;,<br>  document.getElementById(&apos;example&apos;)<br>);<br></code></pre></td></tr></table></figure></p><p>也可以使用getDOMNode()方法获取DOM元素;</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> react </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React学习笔记之组件API</title>
      <link href="/2018/11/14/React-component-API/"/>
      <url>/2018/11/14/React-component-API/</url>
      
        <content type="html"><![CDATA[<h2 id="React-组件-API"><a href="#React-组件-API" class="headerlink" title="React 组件 API"></a>React 组件 API</h2><blockquote><p>React 组件API的7个方法:</p><ul><li>设置状态:setState</li><li>替换状态: replaceState</li><li>设置属性: setProps</li><li>替换属性: replaceState</li><li>强制更新: forceUpdate</li><li>获取DOM节点: findDOMNode</li><li>判断组件挂在状态： isMounted</li></ul></blockquote><h3 id="设置状态-setState"><a href="#设置状态-setState" class="headerlink" title="设置状态: setState"></a>设置状态: setState</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">setState(object nextState[, function callback])<br></code></pre></td></tr></table></figure><h5 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h5><pre><code>&gt; * nextState 将要设置新的状态,该状态会和当前的state合并;&gt; * callback 可选参数,回调函数,该函数会在setState设置成功,且组件重新渲染后调用;</code></pre><blockquote><p>合并nextState和当前state,并重新渲染组件,setState是React事件处理函数中和请求回调函数中触发UI更新的主要方法;</p></blockquote><h5 id="关于setState"><a href="#关于setState" class="headerlink" title="关于setState"></a>关于setState</h5><blockquote><p>不能在组件内部通过this.state修改状态,因为该状态会在调用setState()后被替换;<br>setState()并不会立即改变this.state,而是创建一个即将处理的state;<br>setState()并不一定是同步的,为了提升性能React会批量执行state和DOM渲染;<br>setState()总是会触发一次组件重绘,除非在shouldComponentUpdate()中实现了一些条件渲染逻辑;<br>点击计数器:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class Counter extends React.Component &#123;<br>        constructor(props) &#123;<br>            super(props);<br>            this.state = &#123;<br>                clickCount: 0<br>            &#125;;<br>            this.handleClick = this.handleClick.bind(this);<br>        &#125;<br><br>        handleClick() &#123;<br>            this.setState(function (state) &#123;<br>                return &#123;clickCount: state.clickCount + 1&#125;;<br>            &#125;)<br>        &#125;<br><br>        render() &#123;<br>            return(<br>                &lt;div&gt;<br>                    &lt;button onClick=&#123;this.handleClick&#125;&gt;点我&lt;/button&gt;<br>                    &lt;h3&gt;点击次数为&#123;this.state.clickCount&#125;&lt;/h3&gt;<br>                &lt;/div&gt;<br>            )<br>        &#125;<br>    &#125;<br><br>    ReactDOM.render(<br>        &lt;Counter /&gt;,<br>        document.getElementById(&quot;example&quot;)<br>    )<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="替换状态-replaceState"><a href="#替换状态-replaceState" class="headerlink" title="替换状态: replaceState"></a>替换状态: replaceState</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">replaceState(object nextState[, function callback])<br></code></pre></td></tr></table></figure><blockquote><p>replaceState() 方法与setState() 类似,但是方法只会保留nextState中的状态,原state不在nextState中的状态都会被删除</p></blockquote><h3 id="设置属性-setProps"><a href="#设置属性-setProps" class="headerlink" title="设置属性: setProps"></a>设置属性: setProps</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">setProps(object nextProps[, function callback])<br></code></pre></td></tr></table></figure><pre><code>&gt; * nextProps 将要设置的新属性,该状态会和当前的props合并;&gt; * callback 可选参数,回调函数,该函数会在setProps设置成功,且组件重新渲染后调用;</code></pre><blockquote><p>props相当于组件的数据流,它总是会从父组件向下传递至所有的子组件中.<br>当和一个外部的javascript应用集成时,我们可能需要向组件传递数据或者通知React.render() 组件需要重新渲染,可以使用setProps();<br>更新组件,我可以在节点上再次调用React.render(),也可以通过setProps() 方法改变组件属性,触发组件重新渲染;</p></blockquote><h3 id="替换属性-replaceProps"><a href="#替换属性-replaceProps" class="headerlink" title="替换属性: replaceProps"></a>替换属性: replaceProps</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">replaceProps(object nextProps[, function callback])<br></code></pre></td></tr></table></figure><blockquote><p>replaceProps()方法与setProps()方法类似,但是它会删除原有的props;</p></blockquote><h3 id="强制更新-forceUpdate"><a href="#强制更新-forceUpdate" class="headerlink" title="强制更新: forceUpdate"></a>强制更新: forceUpdate</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">forceUpdate([function callback])<br></code></pre></td></tr></table></figure><blockquote><ul><li>callback 可选参数,回调函数,该函数会在组件render()方法调用后调用;<br>forceUpdate()方法会使组件调用自身的render() 方法重新渲染组件,组件的子组件也会调用自己的render() ,但是,组件重新渲染时,依然会读取this.props和this.state,如果状态没有改变,那么React只会更新DOM;<br>forceUpdate()方式适用于this.props和this.state之外的组件重绘(如:修改了this.state后), 通过该方法通知React需要调用render();<br>一般来说,应该尽量避免使用forceUpdate(),而仅从this.props和this.state中读取状态并由React触发render调用;</li></ul></blockquote><h3 id="获取DOM节点-findDOMNode"><a href="#获取DOM节点-findDOMNode" class="headerlink" title="获取DOM节点: findDOMNode"></a>获取DOM节点: findDOMNode</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">DOMElement findDOMNode<br></code></pre></td></tr></table></figure><blockquote><ul><li>返回值: DOM元素DOMElement<br>如果组件已经挂载到DOM中,该方法返回对应的本地浏览器DOM元素<br>当render()返回null或false时,this.findDOMNode()也会返回null.<br>从DOM中读取值得时候，该方法很有用，如：获取表单字段的值和做一些DOM操作；</li></ul></blockquote><h3 id="判断组件挂载状态：-isMounted"><a href="#判断组件挂载状态：-isMounted" class="headerlink" title="判断组件挂载状态： isMounted"></a>判断组件挂载状态： isMounted</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">bool isMounted()<br></code></pre></td></tr></table></figure><blockquote><ul><li>返回值： true或false，表示组件是否已经挂载到DOM中<br>isMounted()方法用于判断组件是否已挂在到DOM中<br>可以使用该方法保证来setState（）和forceUpdate（）在异步场景下的调用不会出错。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> react </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React学习笔记之生命周期</title>
      <link href="/2018/11/14/React-life/"/>
      <url>/2018/11/14/React-life/</url>
      
        <content type="html"><![CDATA[<h2 id="React-生命周期"><a href="#React-生命周期" class="headerlink" title="React 生命周期"></a>React 生命周期</h2><blockquote><p>组件的生命周期可分成三个状态:</p><ul><li>Mounting: 已插入真实DOM;</li><li>Updating: 正在被重新渲染;</li><li>Unmounting: 已移出真实DOM;</li></ul></blockquote><p><strong>生命周期的方法有</strong>：</p><blockquote><ul><li>componentWillComponent 在渲染前调用,在客户端也在服务端;</li><li>componentDidMount 在第一次渲染后调用,只在客户端.  之后已经生成了对应的DOM结构,可以通过this.getDOMNode()来进行访问,如果你想和其他javascript框架一起使用,可以在这个方法中调用setTimeout,setInterval或者发送ajax请求等操作(防止异步操作阻塞UI);</li><li>componentWillReceiveProps 在组件接收到一个新的prop(更新后)时被调用,这个方法在初始化render时不会被调用;</li><li>shouldComponentUpdate 返回一个布尔值,在组件接收到新的props或者state时被调用,在初始化时或者使用forceUpdate时不被调用;<br>componentWillUpdate 在组件接收到新的props或者state,但还没有render时调用,在初始化时不会被调用;</li><li>componentDidUpdate 在组件完成更新后立即调用,在初始化时不会被调用;</li><li>componentWillUnmount 在组件从DOM中移除之前立刻被调用;<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs undefined">componentWillMount() &#123;<br>            console.log(&apos;Component Will Mount&apos;);<br>        &#125;<br>        componentDidMount() &#123;<br>            console.log(&apos;Component Did Mount&apos;);<br>        &#125;<br>        componentWillReceiveProps(newProps) &#123;<br>            console.log(&apos;Component Will Receive Props&apos;);<br>        &#125;<br>        shouldComponentUpdate(newProps, newState) &#123;<br>            console.log(&apos;Should Component Update&apos;);<br>            return true;<br>        &#125;<br>        componentWillUpdate(nextProps, nextState) &#123;<br>            console.log(&apos;Component Will Update&apos;);<br>        &#125;<br>        componentDidUpdate(prevProps, prevState) &#123;<br>            console.log(&apos;Component Did Update&apos;);<br>        &#125;<br>        componentWillUnmount() &#123;<br>            console.log(&apos;Component Will Unmount&apos;);<br>        &#125;<br></code></pre></td></tr></table></figure></li></ul></blockquote><p><img src="/2018/11/14/React-life/React-life1.png" alt="生命周期1"><br><img src="/2018/11/14/React-life/React-life2.jpg" alt="生命周期2"></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> react </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React学习笔记之列表和keys</title>
      <link href="/2018/11/14/React-list/"/>
      <url>/2018/11/14/React-list/</url>
      
        <content type="html"><![CDATA[<h2 id="React-列表-和-keys"><a href="#React-列表-和-keys" class="headerlink" title="React 列表 和 keys"></a>React 列表 和 keys</h2><blockquote><p>我们可以使用javascript的map()方法来创建数字列表:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">const numbers = [1, 2, 3, 4, 5];<br>    const listItem = numbers.map(number =&gt;<br>        &lt;li&gt;&#123;number&#125;&lt;/li&gt;<br>    );<br>    ReactDOM.render(<br>        &lt;ul&gt;<br>            &#123;listItem&#125;<br>        &lt;/ul&gt;,<br>        document.getElementById(&quot;example&quot;)<br>    )<br></code></pre></td></tr></table></figure></p><p>我们可以将以上实例重构成一个组件,组件接收数组参数,每个列表元素分配一个key,不然会出现警告<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs undefined">let numbers = [1, 2, 3, 4, 5];<br><br>   function NumberList(props) &#123;<br>       const numbers = props.numbers;<br>       const listItems = numbers.map(number =&gt;<br>           &lt;li key=&#123;number&#125;&gt;&#123;number&#125;&lt;/li&gt;<br>       );<br>       return (<br>           &lt;ul&gt;<br>               &#123;listItems&#125;<br>           &lt;/ul&gt;<br>       )<br>   &#125;<br><br>   ReactDOM.render(<br>       &lt;NumberList numbers=&#123;numbers&#125;/&gt;,<br>       document.getElementById(&quot;example&quot;)<br>   )<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a>Keys</h3><blockquote><p>keys可以在DOM中的某些元素被增加或删除的时候,帮助React识别哪些元素发生了变化,因此应当给数组中每一个元素赋予一个确定的标识.<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;li key=&#123;number.toString()&#125;&gt;<br></code></pre></td></tr></table></figure></p><p>一个元素的key最好是这个元素在列表中拥有的独一无二的字符串,通常,我们使用来自数据的ID作为元素的key;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">const todoItems = todos.map(todo =&gt;<br>&lt;li key=&#123;todo.id&#125;&gt;<br>&#123;todo.text&#125;<br>&lt;/li&gt;<br>);<br></code></pre></td></tr></table></figure></p><p>当元素没有确定的id时,可以使用它的序列号索引index作为它的key<br> <figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">const todoItems = todos.map((todo, index) =&gt;<br>&lt;li key=&#123;index&#125;&gt;<br>&#123;todo.text&#125;<br>&lt;/li&gt;<br>);<br></code></pre></td></tr></table></figure></p><p>如果列表可以重新排序,我们不建议使用索引来进行排序,因为这回导致渲染变得很慢</p></blockquote><h3 id="用Keys-提取组件"><a href="#用Keys-提取组件" class="headerlink" title="用Keys 提取组件"></a>用Keys 提取组件</h3><blockquote><p>元素的key只有在它和它的兄弟节点对比时才有意义;<br>比方说,如果需要提取一个ListItem组件,你应该把key保存在数组中的<listitem>元素上,而不是放在ListItem组件中的li元素上<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs undefined">function ListItem(props) &#123;<br>  // 这里不需要指定key<br>  return &lt;li&gt;&#123;props.value&#125;&lt;/li&gt;;<br>&#125;<br>function NumberList(props) &#123;<br>  const numbers = props.numbers;<br>  const listItems = numbers.map((number) =&gt;<br>    // 建议将key指定在这里,数组的上下文里;<br>    &lt;ListItem key=&#123;number.toString()&#125;<br>              value=&#123;number&#125; /&gt;<br>  );<br>  return (<br>    &lt;ul&gt;<br>      &#123;listItems&#125;<br>    &lt;/ul&gt;<br>  );<br>&#125;<br>const numbers = [1, 2, 3, 4, 5];<br>ReactDOM.render(<br>  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,<br>  document.getElementById(&apos;example&apos;)<br>);<br></code></pre></td></tr></table></figure></listitem></p><p>在map()方法的内部调用元素时,最好随时记得为每一个元素加上独一无二的key;</p></blockquote><h3 id="元素的key在它与它的兄弟元素之间应该是唯一"><a href="#元素的key在它与它的兄弟元素之间应该是唯一" class="headerlink" title="元素的key在它与它的兄弟元素之间应该是唯一"></a>元素的key在它与它的兄弟元素之间应该是唯一</h3><blockquote><p>数组元素中使用的key在其兄弟之间应该是独一无二的,然而,它们不需要是全局唯一的,当生成两个不同的数组时,可以使用相同的key;<br>key会作为给React的提示,但不会传递给你的组件.如果你的组件中需要使用和key相同的值,请将其作为属性传递;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">const content = posts.map((post) =&gt; <br>&lt;Post key=&#123;post.id&#125;<br>  id=&#123;post.id&#125;<br>  title=&#123;post.title&#125; /&gt;<br>);<br></code></pre></td></tr></table></figure></p><p>上面例子中,Post组件可以读出props.id,但是不能读出props.key;</p></blockquote><h3 id="在JSX中嵌入map"><a href="#在JSX中嵌入map" class="headerlink" title="在JSX中嵌入map()"></a>在JSX中嵌入map()</h3><blockquote><p>JSX允许在大括号中嵌入任何表达式,所以我们可以在map()中这样使用:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">function NumberList(props)&#123;<br> const nubers = props.numbers;<br>reutnr (<br>&lt;ul&gt;<br>&#123;numbers.map(number) =&gt;<br>&lt;ListItem key=&#123;number.toString()&#125; value=&#123;number&#125; /&gt;<br>&lt;/ul&gt;<br>)<br> &#125;<br></code></pre></td></tr></table></figure></p><p>这么做有时可以使你的代码更清晰,但有时这种风格会被滥用,就像在javascript中一样,何时需要为了可读性提取出一个变量,这完全取决于你自己,但请记住,如果一个map() 嵌套了太多层级,那你就可以提取出组件;</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> react </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React学习笔记之事件处理</title>
      <link href="/2018/11/13/React-Events/"/>
      <url>/2018/11/13/React-Events/</url>
      
        <content type="html"><![CDATA[<h2 id="React-事件处理"><a href="#React-事件处理" class="headerlink" title="React 事件处理"></a>React 事件处理</h2><blockquote><p>React 元素的事件处理和DOM元素类似，但是语法上有有点不同；</p><ul><li>React 事件绑定属性的命名采用驼峰式写法，而不是小写；</li><li>如果采用JSX的语法你需要传入一个函数作为事件处理函数，而不是一个字符串（DOM元素的写法）；<br>HTML写法：<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;button onclick=&quot;todoSomething()&quot;&gt;button&lt;/button&gt;<br></code></pre></td></tr></table></figure></li></ul><p>React写法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;button onClick=&quot;todoSomething&quot;&gt;button&lt;/button&gt;<br></code></pre></td></tr></table></figure></p><p>在React中另一个不同是不能使用返回false的方式阻止默认行为，而必须<br>明确的使用preventDefault；<br>使用React的时候通常不需要使用addEventListener为一个已创建的DOM元素添加监视器，仅仅需要在这个元素渲染的时候提供一个监视器；<br>当使用ES6 class语法来定义一个组件的时候，事件处理器会成为类的一个方法。例如：Toggle组件渲染一个让用户切换开关状态的按钮：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class Toggle extends React.Component &#123;<br>        constructor(props) &#123;<br>            super(props);<br>            this.state = &#123;<br>                isToggle: true<br>            &#125;;<br>            this.handleClick = this.handleClick.bind(this);<br>        &#125;<br><br>        handleClick() &#123;<br>            this.setState(prevState =&gt; (&#123;<br>                isToggle: !prevState.isToggle<br>            &#125;))<br>        &#125;<br><br>        render() &#123;<br>            return (<br>                &lt;button onClick=&#123;this.handleClick&#125;&gt;<br>                    &#123;this.state.isToggle ? &apos;ON&apos; : &apos;OFF&apos;&#125;<br>                &lt;/button&gt;<br>            )<br>        &#125;<br>    &#125;<br><br>    ReactDOM.render(<br>        &lt;Toggle /&gt;,<br>        document.getElementById(&quot;example&quot;)<br>    )<br></code></pre></td></tr></table></figure></p><p>必须谨慎对待JSX回调函数中的this， 类的方法默认是不会绑定this的<br>如果忘记绑定this.handleClick并把它传入onClick，当调用这个函数的时候this的值会是undefined。<br>这不是React的特殊行为，它是函数如何在javaScript中运行的一部分。通常情况下，如果没有在方法后面添加（），例如：onClick={this.handleClick},应该为这个方法绑定this。<br>如果使用bind觉得有点烦，可以有两种解决方法：</p><ul><li><p>如果你正在使用实验性的属性初始化器语法，你可以使用属性初始化器来正确的绑定回调函数：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class LoggingButton extends React.Component &#123;<br>  // 这个语法确保了 `this` 绑定在  handleClick 中<br>  handleClick = () =&gt; &#123;<br>    console.log(&apos;this is:&apos;, this);<br>  &#125;<br> <br>  render() &#123;<br>    return (<br>      &lt;button onClick=&#123;this.handleClick&#125;&gt;<br>        Click me<br>      &lt;/button&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如果你没有使用属性初始化器语法，你可以在回调函数中使用 箭头函数：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class LoggingButton extends React.Component &#123;<br>  handleClick() &#123;<br>    console.log(&apos;this is:&apos;, this);<br>  &#125;<br> <br>  render() &#123;<br>    //  这个语法确保了 `this` 绑定在  handleClick 中<br>    return (<br>      &lt;button onClick=&#123;(e) =&gt; this.handleClick(e)&#125;&gt;<br>        Click me<br>      &lt;/button&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>这个语法有个问题就是么次LoggingButton渲染的时候都会创建一个不同的回调函数。在大多数情况下，这没有问题。然而如果这个回调函数作为一个属性值传入低阶组件，这些组件可能会进行额外的重新渲染。通常建议在构造函数中绑定或使用属性初始化器语法来避免这类性能问题。</p></blockquote><h3 id="向事件处理程序传递参数"><a href="#向事件处理程序传递参数" class="headerlink" title="向事件处理程序传递参数"></a>向事件处理程序传递参数</h3><blockquote><p>通常我们会为事件处理程序传递额外的参数。例如，如果是id是要删除的那一行的id，以下两种方式都可以向事件处理程序传递参数：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;button onClick=&#123;(e) =&gt; this.deleteSome(id, e)&#125;&gt;Delete&lt;/button&gt;<br>&lt;button onClick=&#123;this.deleteSome.bind(this, id)&#125;&gt;Delete&lt;/button&gt;<br></code></pre></td></tr></table></figure></p><p>这两种方式是等价的。<br>参数e作为React事件对象将会被作为第二个参数进行传递。<br>通过箭头函数的方式，事件对象必须显式的进行传递。<br>通过bind的方式，事件对象以及更多的参数将会被隐式的进行传递。<br>值得注意的是,通过bind方式向监听函数传参，在类组件中定义的监听函数，事件对象e要排在所传递参数的后面。例如：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class Popper extends React.Component &#123;<br>    constructor(props) &#123;<br>        super(props);<br>        this.state = &#123;<br>            name: &apos;Hello, React&apos;<br>        &#125;<br>    &#125;<br>    preventPop(name, e) &#123;<br>        e.preventDefault();<br>        console.log(name);<br>    &#125;<br>    render() &#123;<br>        return (<br>            &lt;div&gt;<br>                &lt;p&gt;hello&lt;/p&gt;<br>                &#123;/*通过bind()方法传递参数*/&#125;<br>                &lt;a href=&quot;http://www.wanglichao.top&quot;<br>                    onClick=&#123;this.preventPop.bind(this, this.state.name)&#125;<br>                &gt;Click&lt;/a&gt;<br>            &lt;/div&gt;<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> react </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React学习笔记之JSX</title>
      <link href="/2018/11/13/React-JSX/"/>
      <url>/2018/11/13/React-JSX/</url>
      
        <content type="html"><![CDATA[<h2 id="React-JSX"><a href="#React-JSX" class="headerlink" title="React JSX"></a>React JSX</h2><blockquote><p>React 使用JSX来替代常规的JavaScript;<br>JSX是一个看起来像XML的JavaScript语法扩展;<br>我们不需要一定使用JSX,但它有以下优点:</p><ul><li>JSX执行更快,因为它在编译为JavaScript代码后进行了优化;</li><li>它是安全类型的,在编译过程中就能发现错误;</li><li>使用JSX编写模板更加简单快速</li></ul></blockquote><h3 id="使用JSX"><a href="#使用JSX" class="headerlink" title="使用JSX"></a>使用JSX</h3><blockquote><p>JSX使用起来类似HTML;<br>JSX代码可以放在一个独立的文件上,例如:创建一个js文件,然后在HTML中引入该js文件;<br> <figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined"> ReactDOM.render(<br>    &lt;h1&gt;Hello React!&lt;/h1&gt;,<br>    document.getElementById(&quot;box&quot;)<br>);<br></code></pre></td></tr></table></figure></p></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;body&gt;<br>    &lt;!--创建一个JS文件引入--&gt;<br>    &lt;div id=&quot;box&quot;&gt;&lt;/div&gt;<br>    &lt;script type=&quot;text/babel&quot; src=&quot;hello_react.js&quot;&gt;&lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h3 id="JavaScript表达式"><a href="#JavaScript表达式" class="headerlink" title="JavaScript表达式"></a>JavaScript表达式</h3><blockquote><p>我们可以在 JSX 中使用 JavaScript 表达式。表达式写在花括号 {} 中<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">let i = 1;<br>ReactDOM.render(<br>    &lt;h1&gt;&#123;i == 1 ? &apos;True&apos; : &apos;False&apos;&#125;&lt;/h1&gt;,<br>    document.getElementById(&quot;box&quot;)<br>);<br></code></pre></td></tr></table></figure></p><p>在 JSX 中不能使用 if else 语句，但可以使用 conditional (三元运算) 表达式来替代。以下实例中如果变量 i 等于 1 浏览器将输出 true, 如果修改 i 的值，则会输出 false.</p></blockquote><h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><blockquote><p>React 推荐使用内联样式。我们可以使用 camelCase 语法来设置内联样式. React 会在指定元素数字后自动添加 px<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">let myStyle = &#123;<br>    fontSize: 50,<br>    color: &apos;#ff0000&apos;<br>&#125;;<br><br>ReactDOM.render(<br>    &lt;h1 style=&#123;myStyle&#125;&gt;我是菜鸟&lt;/h1&gt;,<br>    document.getElementById(&quot;box&quot;)<br>);<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><blockquote><p>注释需要写在花括号中<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">ReactDOM.render(<br>    &lt;div&gt;<br>    &lt;h1&gt;哈哈哈&lt;/h1&gt;<br>    &#123;/*注释...*/&#125;<br>     &lt;/div&gt;,<br>    document.getElementById(&apos;example&apos;)<br>);<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>JSX 允许在模板中插入数组，数组会自动展开所有成员：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">let arr = [<br>    &lt;h1&gt;我是菜鸟&lt;/h1&gt;,<br>    &lt;h2&gt;正在学习&lt;/h2&gt;,<br>    &lt;h3&gt;不仅技术&lt;/h3&gt;,<br>    &lt;h4&gt;更是梦想&lt;/h4&gt;<br>];<br><br>ReactDOM.render(<br>    &lt;h1&gt;&#123;arr&#125;&lt;/h1&gt;,<br>    document.getElementById(&quot;box&quot;)<br>);<br></code></pre></td></tr></table></figure></p><h3 id="HTML标签-VS-React组件"><a href="#HTML标签-VS-React组件" class="headerlink" title="HTML标签 VS React组件"></a>HTML标签 VS React组件</h3><blockquote><p>React 可以渲染 HTML 标签 (strings) 或 React 组件 (classes)。<br>要渲染 HTML 标签，只需在 JSX 里使用小写字母的标签名。<br>React 的 JSX 使用大、小写的约定来区分本地组件的类和 HTML 标签。<br>要渲染 React 组件，只需创建一个大写字母开头的本地变量。</p><p>注意:<br>由于 JSX 就是 JavaScript，一些标识符像 class 和 for 不建议作为 XML 属性名。作为替代，React DOM 使用 className 和 htmlFor 来做对应的属性。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> react </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React学习笔记之渲染</title>
      <link href="/2018/11/13/React-render/"/>
      <url>/2018/11/13/React-render/</url>
      
        <content type="html"><![CDATA[<h2 id="React元素渲染"><a href="#React元素渲染" class="headerlink" title="React元素渲染"></a>React元素渲染</h2><blockquote><p>元素是构成React应用的最小单位，它用于描述屏幕上输出的内容。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">const element = &lt;h1&gt;Hello,React!&lt;/h1&gt;;<br></code></pre></td></tr></table></figure></p><p>与浏览器的DOM元素不同，React当中的元素事实上是普通的对象， React DOM可以确保浏览器DOM的数据内容与React元素保持一致。</p></blockquote><h3 id="将元素渲染到DOM中"><a href="#将元素渲染到DOM中" class="headerlink" title="将元素渲染到DOM中"></a>将元素渲染到DOM中</h3><blockquote><p>首先，在一个html页面中添加一个id=“example”的div<br>在此div中的所有内容都将由React DOM来管理，所以我们将其称之为“根”DOM节点<br>用React开发应用时一般只会定义一个根节点，但如果是在一个已有的项目中引入React的话，可能会需要在不同部分单独定义React根节点。</p></blockquote><h3 id="更新元素渲染"><a href="#更新元素渲染" class="headerlink" title="更新元素渲染"></a>更新元素渲染</h3><blockquote><p>React 元素都是不可变的，当元素被创建之后，是无法改变其内容或属性的。<br>目前更新界面的唯一办法就是创建一个新的元素，然后将它传入React DOM.render()方法；</p></blockquote><h3 id="React-只会更新必要的部分"><a href="#React-只会更新必要的部分" class="headerlink" title="React 只会更新必要的部分"></a>React 只会更新必要的部分</h3><blockquote><p>值得注意的是，React　DOM首先会比较元素内容先后的不同，而在渲染过程中只会更新改变了的部分。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> react </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React学习笔记之条件渲染</title>
      <link href="/2018/11/13/React-condition-render/"/>
      <url>/2018/11/13/React-condition-render/</url>
      
        <content type="html"><![CDATA[<h2 id="React-条件渲染"><a href="#React-条件渲染" class="headerlink" title="React 条件渲染"></a>React 条件渲染</h2><blockquote><p>在React中，你可以创建不同的组件来封装你需要的各种行为，然后还可以根据应用的状态变化仅渲染其中的一部分。<br>React中的条件渲染和JavaScript中的一致，使用JavaScript操作符if或条件运算符来创建表示当前状态的元素，然后让React根据它们来更新UI。<br>一个根据用户是否登录来显示其中之一的组件：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs undefined">function UserGreeting() &#123;<br>        return &lt;h1&gt;欢迎登录&lt;/h1&gt;<br>    &#125;<br><br>    function GuestGreeting() &#123;<br>        return &lt;h1&gt;请先注册&lt;/h1&gt;<br>    &#125;<br><br>    function Greeting(props) &#123;<br>        const isLoggedIn = props.isLoggedIn;<br>        if (isLoggedIn) &#123;<br>            return &lt;UserGreeting /&gt;<br>        &#125;<br>        return &lt;GuestGreeting /&gt;<br>    &#125;<br><br>    ReactDOM.render(<br>        // true or false<br>        &lt;Greeting isLoggedIn=&#123;false&#125;/&gt;,<br>        document.getElementById(&apos;example&apos;)<br>    )<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="元素变量"><a href="#元素变量" class="headerlink" title="元素变量"></a>元素变量</h3><blockquote><p>你可以使用变量来储存元素，它可以帮助你有条件的渲染组件中的一部分，而其他的部分不会更改。<br>创建一个LoginControl的有状态的组件，根据当前的状态来渲染<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class LoginControl extends React.Component &#123;<br>        constructor(props) &#123;<br>            super(props);<br>            this.state = &#123;<br>                isLoggedIn: false<br>            &#125;;<br>            this.handleLoginClick = this.handleLoginClick.bind(this);<br>            this.handleLogoutClick = this.handleLogoutClick.bind(this);<br>        &#125;<br>        handleLoginClick() &#123;<br>            this.setState(&#123;<br>                isLoggedIn: true<br>            &#125;)<br>        &#125;<br>        handleLogoutClick() &#123;<br>            this.setState(&#123;<br>                isLoggedIn: false<br>            &#125;)<br>        &#125;<br>        render() &#123;<br>            const isLoggedIn = this.state.isLoggedIn;<br>            let button = null;<br>            if (isLoggedIn) &#123;<br>                button = &lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125;/&gt;<br>            &#125; else &#123;<br>                button = &lt;LoginButton onClick=&#123;this.handleLoginClick&#125;/&gt;<br>            &#125;<br>            return (<br>                &lt;div&gt;<br>                    &lt;Greeting isLoggedIn=&#123;isLoggedIn&#125;/&gt;<br>                    &#123;button&#125;<br>                &lt;/div&gt;<br>            )<br>        &#125;<br>    &#125;<br><br>    function UserGreeting() &#123;<br>        return &lt;h1&gt;欢迎登录&lt;/h1&gt;<br>    &#125;<br><br>    function GuestGreeting() &#123;<br>        return &lt;h1&gt;请先登录或者注册&lt;/h1&gt;<br>    &#125;<br><br>    function Greeting(props) &#123;<br>        const isLoggedIn = props.isLoggedIn;<br>        if (isLoggedIn) &#123;<br>            return &lt;UserGreeting /&gt;<br>        &#125;<br>        return &lt;GuestGreeting /&gt;<br>    &#125;<br><br>    function LoginButton(props) &#123;<br>        return (<br>            &lt;button onClick=&#123;props.onClick&#125;&gt;登录&lt;/button&gt;<br>        )<br>    &#125;<br><br>    function LogoutButton(props) &#123;<br>        return (<br>            &lt;button onClick=&#123;props.onClick&#125;&gt;退出&lt;/button&gt;<br>        )<br>    &#125;<br><br>    ReactDOM.render(<br>        &lt;LoginControl /&gt;,<br>        document.getElementById(&quot;example&quot;)<br>    )<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="与运算符-amp-amp"><a href="#与运算符-amp-amp" class="headerlink" title="与运算符 &amp;&amp;"></a>与运算符 &amp;&amp;</h3><blockquote><p>你可以通过花括号包裹代码在JSX中嵌入任何表达式，也包括JavaScript的逻辑与&amp;&amp;，它可以方便的条件渲染一个元素<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs undefined">function Mailbox(props) &#123;<br>        const unreadMessages = props.unreadMessages;<br>        return (<br>            &lt;div&gt;<br>                &lt;h1&gt;Hello!&lt;/h1&gt;<br>                &#123;unreadMessages.length &gt; 0 &amp;&amp;<br>                    &lt;h2&gt;<br>                        您有&#123;unreadMessages.length&#125;条未读消息<br>                    &lt;/h2&gt;<br>                &#125;<br>            &lt;/div&gt;<br>        )<br>    &#125;<br><br>    const messages = [&apos;react&apos;, &apos;vue&apos;, &apos;javascript&apos;];<br>    ReactDOM.render(<br>        &lt;Mailbox unreadMessages=&#123;messages&#125;/&gt;,<br>        document.getElementById(&quot;example&quot;)<br>    )<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h3><p>条件渲染的另一种方法是使用JavaScript的条件运算符。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">something ? true : false<br></code></pre></td></tr></table></figure></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">render() &#123;<br>  const isLoggedIn = this.state.isLoggedIn;<br>  return (<br>    &lt;div&gt;<br>      &#123;isLoggedIn ? (<br>        &lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125; /&gt;<br>      ) : (<br>        &lt;LoginButton onClick=&#123;this.handleLoginClick&#125; /&gt;<br>      )&#125;<br>    &lt;/div&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在极少数情况下，你可能希望隐藏组件，即使它被其他组件渲染。让 render 方法返回 null 而不是它的渲染结果即可实现。<br>组件的 render 方法返回 null 并不会影响该组件生命周期方法的回调。例如，componentWillUpdate 和 componentDidUpdate 依然可以被调用。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> react </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React学习笔记之JSX</title>
      <link href="/2018/11/13/Vue-Start/"/>
      <url>/2018/11/13/Vue-Start/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> react </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React学习笔记之组件</title>
      <link href="/2018/11/13/React-component/"/>
      <url>/2018/11/13/React-component/</url>
      
        <content type="html"><![CDATA[<h2 id="React-组件"><a href="#React-组件" class="headerlink" title="React 组件"></a>React 组件</h2><blockquote><p>封装一个组件:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">// 使用函数定义一个组件<br>function Message(props) &#123;<br>    return &lt;h1&gt;Hello React!&lt;/h1&gt;;<br>&#125;<br> <br>const element = &lt;Message /&gt;;<br> <br>ReactDOM.render(<br>    element,<br>    document.getElementById(&apos;example&apos;)<br>);<br></code></pre></td></tr></table></figure></p><p>也可以使用ES6 class来定义一个组件<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class Welcome extends React.Component &#123;<br>  render() &#123;<br>    return &lt;h1&gt;Hello React!&lt;/h1&gt;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>const element = <hellomessage> 为用户自定义的组件。<br>注意，原生 HTML 元素名以小写字母开头，而自定义的 React 类名以大写字母开头，比如 HelloMessage 不能写成 helloMessage。除此之外还需要注意组件类只能包含一个顶层标签，否则也会报错。</hellomessage></p><p>如果需要向组件传递参数，可以使用 this.props 对象<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;script type=&quot;text/babel&quot;&gt;<br>        function HelloMessage(props) &#123;<br>            return &lt;h1&gt;Hello, &#123;props.name&#125;!&lt;/h1&gt;<br>        &#125;<br>        const element = &lt;HelloMessage name=&apos;React&apos; /&gt;;<br>        ReactDOM.render(<br>            element,<br>            document.getElementById(&apos;box&apos;)<br>        )<br>    &lt;/script&gt;<br></code></pre></td></tr></table></figure></p><p>以上实例中name属性通过proops.name来获取<br><code>注意，在添加属性时， class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字。</code></p></blockquote><h3 id="复合组件"><a href="#复合组件" class="headerlink" title="复合组件"></a>复合组件</h3><blockquote><p>我们可以通过创建多个组件来合成一个组件，即把组件的不同功能点进行分离。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs undefined">function Name(props) &#123;<br>            return &lt;h1&gt;网站名称: &#123;props.name&#125;&lt;/h1&gt;<br>        &#125;<br>        function Url(props) &#123;<br>            return &lt;h1&gt;网站地址: &#123;props.url&#125;&lt;/h1&gt;<br>        &#125;<br>        function Nickname(props) &#123;<br>            return &lt;h1&gt;网站小名: &#123;props.nickname&#125;&lt;/h1&gt;<br>        &#125;<br>        function App() &#123;<br>            return (<br>                &lt;div&gt;<br>                    &lt;Name name=&apos;勇往直前&apos;/&gt;<br>                    &lt;Url url=&quot;http://www.wanglichao.top&quot;/&gt;<br>                    &lt;Nickname nickname=&quot;心有远方&quot;/&gt;<br>                &lt;/div&gt;<br>            )<br>        &#125;<br>        ReactDOM.render(<br>            &lt;App /&gt;,<br>            document.getElementById(&apos;box&apos;)<br>        )<br></code></pre></td></tr></table></figure></p><p>实例中 App 组件使用了 Name、Url 和 Nickname 组件来输出对应的信息。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> react </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React学习笔记之介绍</title>
      <link href="/2018/11/13/React-anzhuang/"/>
      <url>/2018/11/13/React-anzhuang/</url>
      
        <content type="html"><![CDATA[<h2 id="React介绍"><a href="#React介绍" class="headerlink" title="React介绍"></a>React介绍</h2><blockquote><p>React是一个 用于构建用户界面的javascript库<br>React主要用于构建UI,很多人认为React是MVC中的V(视图)<br>React起源于Facebook的内部项目,用来架设Instagram的网站,并于2013年开源<br>React拥有较高的性能,代码逻辑非常简单,越来越多的人开始关注和使用它</p></blockquote><h3 id="React特点"><a href="#React特点" class="headerlink" title="React特点"></a>React特点</h3><blockquote><p>1.声明式设计 - React采用声明范式,可以轻松描述应用<br>2.高效  - React通过对DOM的模拟,最大限度的减少与DOM的交互<br>3.灵活 - React可以与已知的库或框架很好的配合<br>4.JSX - JSX是JavaScript语法的扩展,React开发不一定使用JSX,但建议使用它<br>5.组件 - 通过React构建组件,使得代码更加容易得到复用,能够很好的应用在大项目的开发中<br>6.单向响应的数据流 - React实现了单向响应的数据流,从而减少了重复代码,这也是它为什么比传统数据绑定更简单</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> react </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React学习笔记之安装</title>
      <link href="/2018/11/13/React-install/"/>
      <url>/2018/11/13/React-install/</url>
      
        <content type="html"><![CDATA[<h2 id="React-安装"><a href="#React-安装" class="headerlink" title="React 安装"></a>React 安装</h2><h3 id="React-可以直接下载使用-也可以使用CDN"><a href="#React-可以直接下载使用-也可以使用CDN" class="headerlink" title="React 可以直接下载使用,也可以使用CDN;"></a>React 可以直接下载使用,也可以使用CDN;</h3><blockquote><p>Staticfile CDN 的 React CDN 库:</p></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;script src=&quot;https://cdn.staticfile.org/react/16.4.0/umd/react.development.js&quot;&gt;&lt;/script&gt;<br>&lt;script src=&quot;https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js&quot;&gt;&lt;/script&gt;<br>&lt;!-- 生产环境中不建议使用 --&gt;<br>&lt;script src=&quot;https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js&quot;&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><blockquote><p>官方提供的DCN地址:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;script src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt;<br>&lt;script src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt;<br>&lt;!-- 生产环境中不建议使用 --&gt;<br>&lt;script src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><p>输出Hello,React!的实例<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;meta charset=&quot;UTF-8&quot; /&gt;<br>&lt;title&gt;Hello React!&lt;/title&gt;<br>&lt;script src=&quot;https://cdn.staticfile.org/react/16.4.0/umd/react.development.js&quot;&gt;&lt;/script&gt;<br>&lt;script src=&quot;https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js&quot;&gt;&lt;/script&gt;<br>&lt;script src=&quot;https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js&quot;&gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br> <br>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;<br>&lt;script type=&quot;text/babel&quot;&gt;<br>ReactDOM.render(<br>    &lt;h1&gt;Hello,React!&lt;/h1&gt;,<br>    document.getElementById(&apos;app&apos;)<br>);<br>&lt;/script&gt;<br> <br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure></p><p>实例中需要3个库 react / react-DOM / babel</p><ul><li>react -&gt; React的核心库</li><li>react-dom -&gt; 提供与DOM相关的功能</li><li>babel -&gt;babel可以将ES6代码转为ES5代码,这就可以在不支持ES6的浏览器上执行React代码,babel内嵌了对JSX的支持<br>注意:如果需要使用JSX,则script标签的type属性需要设置为text/babel</li></ul></blockquote><h3 id="通过npm使用React"><a href="#通过npm使用React" class="headerlink" title="通过npm使用React"></a>通过npm使用React</h3><p>国内简易使用cnpm代替npm安装package;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">$ npm install -g cnpm --registry=https://registry.npm.taobao.org<br>$ npm config set registry https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure></p><blockquote><p>这样就可以使用cnpm命令来安装模块了<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">$ cnpm install [packagename]<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="使用create-react-app-快速构建React开发环境"><a href="#使用create-react-app-快速构建React开发环境" class="headerlink" title="使用create-react-app 快速构建React开发环境"></a>使用create-react-app 快速构建React开发环境</h3><blockquote><p>create-react-app 是来自于facebook，通过该命令我们无需配置就能快速构建React开发环境。<br>create-react-app 自动创建的项目是基于Webpack + ES6.<br>执行以下命令创建项目：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">$ cnpm install -g create-react-app<br>$ create-react-app [my-app]<br>$ cd [my-app]<br>$ npm start<br></code></pre></td></tr></table></figure></p><p>在浏览器中打开<a href="http://localhost:3000，就会呈现项目页面" target="_blank" rel="noopener">http://localhost:3000，就会呈现项目页面</a></p></blockquote><p>React 代码的书写格式和以前的 JS 有很大的不同，下面通过对这段代码进行分析了解一下他。</p><p>以前使用JS 定义一个变量使用 var 现在用 const：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">const div = document.createElement(&apos;div&apos;);<br></code></pre></td></tr></table></figure><p>ReactDOM.render(…) 是渲染方法，所有的 js,html 都可通过它进行渲染绘制，他又两个参数，内容和渲染目标 js 对象。</p><p>内容就是要在渲染目标中显示的东西，可以是一个React 部件，也可以是一段HTML或TEXT文本。渲染目标JS对象，就是一个DIV或TABEL,或TD 等HTML的节点对象。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">ReactDOM.render(&lt;App /&gt;, div);<br></code></pre></td></tr></table></figure><p>unmountComponentAtNode() 这个方法是解除渲染挂载，作用和 render 刚好相反，也就清空一个渲染目标中的 React 部件或 html 内容。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">ReactDOM.unmountComponentAtNode(div);<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> react </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React学习笔记之State</title>
      <link href="/2018/11/13/React-State/"/>
      <url>/2018/11/13/React-State/</url>
      
        <content type="html"><![CDATA[<h2 id="React-State"><a href="#React-State" class="headerlink" title="React State"></a>React State</h2><blockquote><p>React 把组件看成是一个状态机(StateMachines).通过与用户的交互,实现不同的状态,然后渲染UI,让用户界面和数据保持一致;<br>React里,只需更新组件的state,然后根据新的state重新渲染用户界面,而不需要去操作DOM;</p></blockquote><h3 id="将生命周期方法添加到类中"><a href="#将生命周期方法添加到类中" class="headerlink" title="将生命周期方法添加到类中"></a>将生命周期方法添加到类中</h3><blockquote><p>在具有许多组件的应用程序中,在销毁时释放组件所占用的资源非常重要;<br>每当组件第一次加载到DOM中的时候,在React中被称为挂载;<br>当这个组件生成的DOM被移除的时候,在React中被称为卸载;</p></blockquote><h3 id="数据自顶向下流动"><a href="#数据自顶向下流动" class="headerlink" title="数据自顶向下流动"></a>数据自顶向下流动</h3><blockquote><p>父组件或子组件都不能知道某个组件是有状态还是无状态，并且它们不应该关心某组件是被定义为一个函数还是一个类。</p><p>这就是为什么状态通常被称为局部或封装。 除了拥有并设置它的组件外，其它组件不可访问。</p><p>通常被称为自顶向下或单向数据流。 任何状态始终由某些特定组件所有，并且从该状态导出的任何数据或 UI 只能影响树中下方的组件;</p><p>在 React 应用程序中，组件是有状态还是无状态被认为是可能随时间而变化的组件的实现细节。</p><p>我们可以在有状态组件中使用无状态组件，也可以在无状态组件中使用有状态组件。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> react </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React学习笔记之Props</title>
      <link href="/2018/11/13/React-Props/"/>
      <url>/2018/11/13/React-Props/</url>
      
        <content type="html"><![CDATA[<h2 id="React-Props"><a href="#React-Props" class="headerlink" title="React Props"></a>React Props</h2><blockquote><p>state 和 props 主要的区别在于props是不可变的,而state可以根据与用户交互来改变;<br>这就是为什么有些容器组件需要定义state来更新和修改数据;<br>而子组件只能通过props来传递数据;<br>演示如何在组件中使用props:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">function Message(props) &#123;<br>            return &lt;h1&gt;Hello, &#123;props.name&#125;!&lt;/h1&gt;<br>        &#125;<br>        const element = &lt;Message name=&quot;React&quot;/&gt;;<br>        ReactDOM.render(<br>            element,<br>            document.getElementById(&quot;box&quot;)<br>        )<br></code></pre></td></tr></table></figure></p><p>实例中name属性通过props.name来获取;</p></blockquote><h3 id="默认Props"><a href="#默认Props" class="headerlink" title="默认Props"></a>默认Props</h3><blockquote><p>你可以通过组件类的defaultProps属性为Props设置默认值:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class Message extends React.Component &#123;<br>            constructor() &#123;<br>                super()<br>            &#125;<br>            render() &#123;<br>                return (<br>                    &lt;h1&gt;Hello, &#123;this.props.name&#125;!&lt;/h1&gt;<br>                )<br>            &#125;<br>        &#125;<br>        Message.defaultProps = &#123;<br>            name: &apos;React&apos;<br>        &#125;;<br>        const element = &lt;Message /&gt;;<br>        ReactDOM.render(<br>            element,<br>            document.getElementById(&apos;box&apos;)<br>        )<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="State-和-Props"><a href="#State-和-Props" class="headerlink" title="State 和 Props"></a>State 和 Props</h3><p>以下实例演示了如何在应用中组合使用state和props, 我们可以在父组件中设置state,并通过在子组件上使用props将其传递到子组件上,在render函数中,我们设置name和site来获取父组件传递过来的数据;<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class WebSite extends React.Component &#123;<br>            constructor () &#123;<br>                super();<br>                this.state = &#123;<br>                    name: &quot;勇往直前&quot;,<br>                    site: &quot;http://www.wanglichao.top&quot;<br>                &#125;<br>            &#125;<br>            render() &#123;<br>                return (<br>                    &lt;div&gt;<br>                        &lt;Name name=&#123;this.state.name&#125;/&gt;<br>                        &lt;Link site=&#123;this.state.site&#125;/&gt;<br>                    &lt;/div&gt;<br>                )<br>            &#125;<br>        &#125;<br><br>        class Name extends React.Component &#123;<br>            render() &#123;<br>                return (<br>                    &lt;h1&gt;&#123;this.props.name&#125;&lt;/h1&gt;<br>                )<br>            &#125;<br>        &#125;<br><br>        class Link extends React.Component &#123;<br>            render() &#123;<br>                return (<br>                    &lt;a href=&#123;this.props.site&#125;&gt;<br>                        &#123;this.props.site&#125;<br>                    &lt;/a&gt;<br>                )<br>            &#125;<br>        &#125;<br><br>        ReactDOM.render(<br>            &lt;WebSite /&gt;,<br>            document.getElementById(&quot;box&quot;)<br>        )<br></code></pre></td></tr></table></figure></p><h3 id="Props-验证"><a href="#Props-验证" class="headerlink" title="Props 验证"></a>Props 验证</h3><blockquote><p><code>React.PropTypes 在 React v15.5 版本后已经移动到prop-types库.</code><br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;script src=&quot;https://cdn.bootcss.com/prop-types/15.6.1/prop-types.js&quot;&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><p>Props验证使用propTypes,它可以保证我们的应用组件被正确的使用,React.PropTypes 提供很多验证器(validator)来验证传入数据是否有效;<br>当向props传入无效数据时,JavaScript控制台会抛出警告.<br>以下实例创建一个MyTitle组件,属性title是必须的且是字符串,非字符串类型会自动转换为字符串.<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs undefined">// React 16.4 实例<br>let title = &quot;勇往直前&quot;;<br>        // title = 123;<br>        // Failed prop type: Invalid prop `title` of type `number` supplied to `MyTitle`, expected `string`.<br>    in MyTitle<br>        class MyTitle extends React.Component &#123;<br>            render() &#123;<br>                return (<br>                    &lt;h1&gt;Hello, &#123;this.props.title&#125;&lt;/h1&gt;<br>                )<br>            &#125;<br>        &#125;<br><br>        MyTitle.propTypes = &#123;<br>            title: PropTypes.string<br>        &#125;;<br><br>        ReactDOM.render(<br>            &lt;MyTitle title=&#123;title&#125; /&gt;,<br>            document.getElementById(&quot;box&quot;)<br>        )<br></code></pre></td></tr></table></figure></p></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs undefined">// React 15.4 实例<br>let title = &quot;勇往直前&quot;;<br>    // title = 123;<br>    const MyTitle = React.createClass(&#123;<br>        propTypes: &#123;<br>            title: React.PropTypes.string.isRequired<br>        &#125;,<br>        render: function() &#123;<br>            return &lt;h1&gt;&#123;this.props.title&#125;&lt;/h1&gt;<br>        &#125;<br>    &#125;);<br>    ReactDOM.render(<br>        &lt;MyTitle title=&#123;title&#125; /&gt;,<br>        document.getElementById(&apos;example&apos;)<br>    );<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> react </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React学习笔记之this相关</title>
      <link href="/2018/11/13/React-This/"/>
      <url>/2018/11/13/React-This/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在JavaScript中，this对象是运行时基于函数的执行环境（也就是上下文）绑定的。</p><p>从 react 中的 demo 说起<br>Facebook一次更新react时，将es6中的class加入了组件的创建方式当中。Facebook也推荐组件创建使用通过定义一个继承自 React.Component 的class来定义一个组件类。官方的demo：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class LikeButton extends React.Component &#123;<br>  constructor() &#123;<br>    super();<br>    this.state = &#123;<br>      liked: false<br>    &#125;;<br>    this.handleClick = this.handleClick.bind(this);<br>  &#125;<br>  handleClick() &#123;<br>    this.setState(&#123;liked: !this.state.liked&#125;);<br>  &#125;<br>  render() &#123;<br>    const text = this.state.liked ? &apos;liked&apos; : &apos;haven\&apos;t liked&apos;;<br>    return (<br>      &lt;div onClick=&#123;this.handleClick&#125;&gt;<br>        You &#123;text&#125; this. Click to toggle.<br>      &lt;/div&gt;<br>    );<br>  &#125;<br>&#125;<br>ReactDOM.render(<br>  &lt;LikeButton /&gt;,<br>  document.getElementById(&apos;example&apos;)<br>);<br></code></pre></td></tr></table></figure></p><p>上面的demo中有大量this的使用，在 class LikeButton extends React.Component 中我们是声明该class，因为this具体是由其上下文决定的，因此在类定义中我们无法得知this用法。<br>相当于是new了上面定义的类，首先调用 constructor() 函数， this.state 的this上下文就是该实例对象；<br>同理，render() 函数中 this.state.liked 的this上下文也是该对象。<br>问题在于 onClick={this.handleClick} ，获取该函数引用是没有问题，这里的this上下文就是该对象。</p><p>这时问题来了，在原来 React.createClass 中， handleClick() 在onClick事件触发的时候，会自动绑定到LikeButton实例上，这时候该函数的this的上下文就是该实例。<br>不过在ES6的class的写法中，Facebook取消了自动绑定，实例化LikeButton后，handleClick()的上下文是div的支撑实例（ backing instance ），而 handleClick() 原本要绑定的上下文是LikeButton的实例。<br>对于该问题，我们有多种解决方案。<br><strong>使用 bind() 函数改变 this 的上下文</strong><br>可以在class声明中的constructor()函数中使用：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">this.handleClick = this.handleClick.bind(this);<br></code></pre></td></tr></table></figure></p><p>该方法是一个bind()绑定，多次使用。在该方法中，我们在声明该实例后，可以在该实例任何地方使用 handleClick() 函数，并且该 handleClick() 函数的this的上下文都是LikeButton实例对象。<br>除此我们也可以在具体使用该函数的地方绑定this的上下文到LikeButton实例对象，代码如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div onClick=&#123;this.handleClick.bind(this)&#125;&gt;<br>   Click to toggle.<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure></p><p>这种方法需要我们每次使用bind()函数绑定到组件对象上。<br><strong>es6的箭头函数</strong><br>es6中新加入了箭头函数=&gt;，箭头函数除了方便之外还有而一个特征就是将函数的this绑定到其定义时所在的上下文。这个特征也可以帮助我们解决这个问题。使用如下代码：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;div onClick=&#123;() =&gt; this.handleClick()&#125;&gt;<br>  Click to toggle.<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure></p></blockquote><p>这样该 this.handleClick() 的上下文就会被绑定到 LikeButton 的实例对象上。</p><blockquote><p><strong>this的总结</strong><br>this 的本质就是：this跟作用域无关的，只跟执行上下文有关。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> react </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于项目打包时的优化</title>
      <link href="/2018/11/11/project_webpack_optimize/"/>
      <url>/2018/11/11/project_webpack_optimize/</url>
      
        <content type="html"><![CDATA[<h2 id="前端-JavaScript-项目优化"><a href="#前端-JavaScript-项目优化" class="headerlink" title="前端 JavaScript 项目优化"></a>前端 JavaScript 项目优化</h2><h3 id="1-CSS抽离"><a href="#1-CSS抽离" class="headerlink" title="1.CSS抽离"></a>1.CSS抽离</h3><blockquote><p>将css文件从js文件中抽离出来;<br>分开加载,代码有改动时css/JS不用全部去加载;</p></blockquote><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 抽离css文件的插件:</span><br><span class="hljs-keyword">const</span> ExtractTextPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">"extract-text-webpack-plugin"</span>);<br><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-attr">module</span>: &#123;<br>        <span class="hljs-attr">rules</span>: [<br>            test: <span class="hljs-regexp">/\.css$/</span>,<br>            <span class="hljs-attr">use</span>: ExtracTextPlugin.extrac(&#123;<br>                <span class="hljs-attr">fallback</span>: <span class="hljs-string">"style-loader"</span>,<br>                <span class="hljs-attr">use</span>: <span class="hljs-string">"css-loader"</span><br>            &#125;)<br>        ]<br>    &#125;,<br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-keyword">new</span> ExtractTextPlugin(<span class="hljs-string">"styles.css"</span>)<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-哈希值"><a href="#2-哈希值" class="headerlink" title="2.哈希值"></a>2.哈希值</h3><blockquote><p>辨识文件是否改动;</p></blockquote><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">output: &#123;<br>   <span class="hljs-attr">path</span>: path.join(__dirname, <span class="hljs-string">'dist'</span>),<br>   <span class="hljs-comment">// js文件的哈希</span><br>   filename: <span class="hljs-string">"[name].[chunkhash:6].js"</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">plugins: [<br>       <span class="hljs-comment">// css文件的哈希</span><br>       <span class="hljs-keyword">new</span> ExtractTextPlugin(<span class="hljs-string">"[name].[contenthash:6].css"</span>)<br>   ]<br></code></pre></td></tr></table></figure><h3 id="3-第三方包抽离"><a href="#3-第三方包抽离" class="headerlink" title="3.第三方包抽离"></a>3.第三方包抽离</h3><blockquote><p>辨识部分文件改动;</p></blockquote><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 此插件依赖webpack</span><br><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>);<br><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-attr">entry</span>: &#123;<br>         <span class="hljs-attr">main</span>: <span class="hljs-string">"./src/main.js"</span>,<br>        <span class="hljs-comment">// 再加一个入口,将第三方包从main.js中分离出来</span><br>        vendors: [<span class="hljs-string">"vue"</span>,<span class="hljs-string">"vue-router"</span>,<span class="hljs-string">"moment"</span>,<span class="hljs-string">"axios"</span>,<span class="hljs-string">"vue-preview"</span>]<br>    &#125;,<br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-comment">// webpack中抽离第三方包的插件:</span><br>        <span class="hljs-keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;<br>            <span class="hljs-comment">// manifest用来记录使用者和第三方包的依赖关系</span><br>            names: [<span class="hljs-string">"vendors"</span>, <span class="hljs-string">"manifest"</span>]<br>        &#125;)<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-代码压缩混淆"><a href="#4-代码压缩混淆" class="headerlink" title="4.代码压缩混淆"></a>4.代码压缩混淆</h3><blockquote><p>很大程度的压缩代码体积</p></blockquote><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 压缩混淆代码的插件,需要 npm i -D uglifyjs-webpack-plugin 下载</span><br><span class="hljs-keyword">const</span> UglifyJSPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">"uglifyjs-webpack-plugin"</span>);<br><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-keyword">new</span> UglifyJSPlugin()<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-main-ui的按需引入"><a href="#5-main-ui的按需引入" class="headerlink" title="5.main-ui的按需引入"></a>5.main-ui的按需引入</h3><blockquote><p>进一步减小代码体积</p></blockquote><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 全部引入的用法:</span><br><span class="hljs-comment">// import Mint from 'mint-ui'</span><br><span class="hljs-comment">// import 'mint-ui/lib/style.css'</span><br><span class="hljs-comment">// Vue.use(Mint);</span><br><br><span class="hljs-comment">// 按需加载的用法:</span><br><span class="hljs-keyword">import</span> Header <span class="hljs-keyword">from</span> <span class="hljs-string">'mint-ui/lib/header'</span><br><span class="hljs-keyword">import</span> Switch <span class="hljs-keyword">from</span> <span class="hljs-string">'mint-ui/lib/switch'</span><br><span class="hljs-keyword">import</span> SwitchItem <span class="hljs-keyword">from</span> <span class="hljs-string">'mint-ui/lib/switch-item'</span><br><span class="hljs-keyword">import</span> Button <span class="hljs-keyword">from</span> <span class="hljs-string">'mint-ui/lib/button'</span><br><span class="hljs-keyword">import</span> Lazyload <span class="hljs-keyword">from</span> <span class="hljs-string">'mint-ui/lib/lazyload'</span><br><span class="hljs-comment">// ...</span><br><br>Vue.component(Header.name, Header);<br>Vue.component(SwitchItem.name, SwitchItem);<br>Vue.component(Button.name, Button);<br>Vue.use(Lazyload); <span class="hljs-comment">// 注意lazyload(懒加载)仍需要use方式调用</span><br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><h3 id="6-代码文件的结构整理"><a href="#6-代码文件的结构整理" class="headerlink" title="6.代码文件的结构整理"></a>6.代码文件的结构整理</h3><blockquote><p>文件的分类整理</p><ul><li>注意: 将文件路径分类整理后,代码中的相对路径引用文件可能会发生错误,需要修正</li></ul></blockquote><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">output: &#123;<br>   <span class="hljs-attr">path</span>: path.join(__dirname, <span class="hljs-string">'dist'</span>),<br>   <span class="hljs-comment">// 修正资源请求路径</span><br>   publicPath: <span class="hljs-string">'/'</span>,   <span class="hljs-comment">// 企业中也可以是 www.xxx.com/为根路径</span><br>   <span class="hljs-comment">// js文件的路径</span><br>   filename: <span class="hljs-string">"js/[name].[chunkhash:6].js"</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>   <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(jpg|png|svg|ttf|woff|woff2|gif)$/</span>,<br>   <span class="hljs-attr">use</span>: [<br>       <span class="hljs-string">'url-loader'</span>,<br>       <span class="hljs-attr">options</span>: &#123;<br>           <span class="hljs-attr">limit</span>: <span class="hljs-number">4096</span>,<br>           <span class="hljs-comment">// 图片文件的路径</span><br>           name: <span class="hljs-string">'/assets/[name].[ext]'</span><br>       &#125;<br>   ]<br>&#125;<br></code></pre></td></tr></table></figure><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">plugins: [<br>       <span class="hljs-comment">// css文件的路径</span><br>       <span class="hljs-keyword">new</span> ExtractTextPlugin(<span class="hljs-string">"css/[name].[contenthash:6].css"</span>)<br>   ]<br></code></pre></td></tr></table></figure><h3 id="7-路由的懒加载"><a href="#7-路由的懒加载" class="headerlink" title="7.路由的懒加载"></a>7.路由的懒加载</h3><blockquote><p>根据路由路径按需加载页面</p></blockquote><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.vue'</span>  <span class="hljs-comment">// 公用App组件不用</span><br><br><span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">'./component/home/home.vue'</span><br><span class="hljs-keyword">import</span> News <span class="hljs-keyword">from</span> <span class="hljs-string">'./component/news/news.vue'</span><br><span class="hljs-comment">// 修改为</span><br><span class="hljs-keyword">const</span> Home = <span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">require</span>([<span class="hljs-string">'./component/home/home.vue'</span>, resolve]);<br><span class="hljs-keyword">const</span> News = <span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> <span class="hljs-built_in">require</span>([<span class="hljs-string">'./component/news/news.vue'</span>, r]);<br></code></pre></td></tr></table></figure><h3 id="8-去除控制台开发的提示"><a href="#8-去除控制台开发的提示" class="headerlink" title="8.去除控制台开发的提示"></a>8.去除控制台开发的提示</h3><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">plugins: [<br>    <span class="hljs-keyword">new</span> webpack.DefinePlugin(&#123;<br>        <span class="hljs-string">'process.env'</span>: &#123;<br>            <span class="hljs-attr">NODE_ENV</span>: <span class="hljs-string">'"production"'</span><br>        &#125;<br>    &#125;)<br>]<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>输入URL地址敲回车之后发生了什么</title>
      <link href="/2018/11/10/enter-event/"/>
      <url>/2018/11/10/enter-event/</url>
      
        <content type="html"><![CDATA[<h2 id="输入URL地址敲回车之后发生了什么"><a href="#输入URL地址敲回车之后发生了什么" class="headerlink" title="输入URL地址敲回车之后发生了什么"></a>输入URL地址敲回车之后发生了什么</h2><blockquote><p> 输入网址敲回车之后,<br> 浏览器开始向DNS服务器发送请求,    (request)请求<br> DNS服务器解析,<br> 找到IP地址对应的服务器,<br> 服务器根据对应的端口号找到对应的项目,<br> 将需要的数据代码编码后返回给浏览器客户端,并将数据的类型告诉浏览器(HTML/json…),     (response)响应<br> 浏览器将接收到的数据根据返回来的数据类型进行解析,</p></blockquote><ul><li><p>http事物: request请求和response响应都成功就是一个完整的HTTP事物;</p></li><li><p><a href="https://www.baidu.com:443/xx/yy/index.html?name=aa&amp;age=30#id=5" target="_blank" rel="noopener">https://www.baidu.com:443/xx/yy/index.html?name=aa&amp;age=30#id=5</a></p></li><li><p>(https) – (www.baidu.com ) – (443) – (/xx/yy/index.html) – (name=aa&amp;age=30) – (id=5)</p></li></ul><h2 id="1-HTTPS-传输协议"><a href="#1-HTTPS-传输协议" class="headerlink" title="1.(HTTPS) 传输协议"></a>1.(HTTPS) 传输协议</h2><blockquote><p>https / http  完成客户端和服务端的数据交互传输<br>https: 更加安全<br>http: 超文本传输协议<br>FTP: 往服务器上上传项目文件</p></blockquote><h2 id="2-www-baidu-com-域名"><a href="#2-www-baidu-com-域名" class="headerlink" title="2.(www.baidu.com) 域名:"></a>2.(www.baidu.com) 域名:</h2><blockquote><p>一级域名<br>二级域名<br>三级域名</p></blockquote><h2 id="3-443-端口号"><a href="#3-443-端口号" class="headerlink" title="3.(443) 端口号:"></a>3.(443) 端口号:</h2><ul><li>根据端口号找到对应的项目<blockquote><p>http: 默认端口号80<br>https: 默认端口号443<br>FTP: 默认端口号21</p></blockquote></li></ul><h2 id="4-xx-yy-index-html-项目地址"><a href="#4-xx-yy-index-html-项目地址" class="headerlink" title="4.(/xx/yy/index.html)项目地址"></a>4.(/xx/yy/index.html)项目地址</h2><ul><li>根据地址值找到项目下的具体页面文件<blockquote><p>/xx/yy/index.html 真实地址, 请求资源文件<br>/xxx  伪地址, 请求数据</p></blockquote></li></ul><h2 id="5-name-aa-amp-age-30-参数"><a href="#5-name-aa-amp-age-30-参数" class="headerlink" title="5.(name=aa&amp;age=30)参数"></a>5.(name=aa&amp;age=30)参数</h2><ul><li>参数格式是后台规定的,根据参数的值返回响应的数据</li></ul><h2 id="6-id-5-哈希值-Hash值"><a href="#6-id-5-哈希值-Hash值" class="headerlink" title="6.(id=5) 哈希值 Hash值"></a>6.(id=5) 哈希值 Hash值</h2><blockquote><p>锚点定位<br>路由</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> http </tag>
            
            <tag> url </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javascript学习之json常用方法</title>
      <link href="/2018/02/16/page/javascript-json/"/>
      <url>/2018/02/16/page/javascript-json/</url>
      
        <content type="html"><![CDATA[<h1 id="javascript中JSON语法有三种表示方法："><a href="#javascript中JSON语法有三种表示方法：" class="headerlink" title="javascript中JSON语法有三种表示方法："></a>javascript中JSON语法有三种表示方法：</h1><h3 id="简单值-“hello-json”"><a href="#简单值-“hello-json”" class="headerlink" title="简单值:      “hello json”"></a>简单值:      “hello json”</h3><h3 id="对象-“name”-”jack”"><a href="#对象-“name”-”jack”" class="headerlink" title="对象:        {“name”:”jack”}"></a>对象:        {“name”:”jack”}</h3><h3 id="数组-“aaa”-”bbb”-“ccc”-”ddd”"><a href="#数组-“aaa”-”bbb”-“ccc”-”ddd”" class="headerlink" title="数组:        [{“aaa”:”bbb”},{“ccc”:”ddd”}]"></a>数组:        [{“aaa”:”bbb”},{“ccc”:”ddd”}]</h3><h2 id="JSON常用的两个方法："><a href="#JSON常用的两个方法：" class="headerlink" title="JSON常用的两个方法："></a>JSON常用的两个方法：</h2><h2 id="stringify-和-parse"><a href="#stringify-和-parse" class="headerlink" title="stringify() 和 parse()"></a>stringify() 和 parse()</h2><h2 id="stringify用法："><a href="#stringify用法：" class="headerlink" title="*stringify用法："></a>*stringify用法：</h2><h4 id="用法一：-把javascript对象转化成JSON格式"><a href="#用法一：-把javascript对象转化成JSON格式" class="headerlink" title="用法一： 把javascript对象转化成JSON格式:"></a>用法一： 把javascript对象转化成JSON格式:</h4><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> demo = &#123;<br>  <span class="hljs-string">"name"</span>:<span class="hljs-string">"aaa"</span>,<br>  <span class="hljs-string">"type"</span>:<span class="hljs-string">"bbb"</span> <br>&#125;<br><span class="hljs-keyword">var</span> jsonDemo = <span class="hljs-built_in">JSON</span>.stringify(demo);<br><span class="hljs-built_in">console</span>.log(jsonDemo);<br></code></pre></td></tr></table></figure><ul><li>得到结果：</li></ul><figure class="hljs highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<span class="hljs-attr">"name"</span>:<span class="hljs-string">"aaa"</span>,<span class="hljs-attr">"type"</span>:<span class="hljs-string">"bbb"</span>&#125;<br></code></pre></td></tr></table></figure><h4 id="用法二：把javascript对象转化成JSON格式，增加过滤，只留想要的数据"><a href="#用法二：把javascript对象转化成JSON格式，增加过滤，只留想要的数据" class="headerlink" title="用法二：把javascript对象转化成JSON格式，增加过滤，只留想要的数据"></a>用法二：把javascript对象转化成JSON格式，增加过滤，只留想要的数据</h4><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> demo = &#123;<br><span class="hljs-string">"name"</span>:<span class="hljs-string">"aaa"</span>,<br><span class="hljs-string">"sex"</span>:<span class="hljs-string">"boy"</span>,<br><span class="hljs-string">"age"</span>: <span class="hljs-number">20</span><br>&#125;<br><span class="hljs-keyword">var</span> jsonDemo = <span class="hljs-built_in">JSON</span>.stringify(demo,[<span class="hljs-string">"name"</span>]);<br><span class="hljs-built_in">console</span>.log(jsonDemo);<br></code></pre></td></tr></table></figure><ul><li>得到结果：</li></ul><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs josn">&#123;&quot;name&quot;:&quot;aaa&quot;&#125;<br></code></pre></td></tr></table></figure><h4 id="用法三：把javascript对象转化成JSON格式，并改变原有的值"><a href="#用法三：把javascript对象转化成JSON格式，并改变原有的值" class="headerlink" title="用法三：把javascript对象转化成JSON格式，并改变原有的值"></a>用法三：把javascript对象转化成JSON格式，并改变原有的值</h4><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> demo = &#123;<br><span class="hljs-string">"name"</span>:<span class="hljs-string">"aaa"</span>,<br><span class="hljs-string">"sex"</span>:<span class="hljs-string">"bbb"</span>,<br><span class="hljs-string">"type"</span>:<span class="hljs-string">"ccc"</span><br>&#125;<br><span class="hljs-keyword">var</span> jsonDemo = <span class="hljs-built_in">JSON</span>.stringify(demo,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key, value</span>) </span>&#123;<br><span class="hljs-keyword">switch</span>(key)&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">"name"</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">"a"</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">"sex"</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">"b"</span>;<br><span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> value;<br>&#125;<br>&#125;);<br><span class="hljs-built_in">console</span>.log(jsonDemo);<br></code></pre></td></tr></table></figure><ul><li>得到结果：</li></ul><figure class="hljs highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<span class="hljs-attr">"name"</span>:<span class="hljs-string">"a"</span>,<span class="hljs-attr">"sex"</span>:<span class="hljs-string">"b"</span>,<span class="hljs-attr">"type"</span>:<span class="hljs-string">"ccc"</span>&#125;<br></code></pre></td></tr></table></figure><h4 id="用法四：把javascript对象转化成JSON格式，并控制缩进和空白符"><a href="#用法四：把javascript对象转化成JSON格式，并控制缩进和空白符" class="headerlink" title="用法四：把javascript对象转化成JSON格式，并控制缩进和空白符"></a>用法四：把javascript对象转化成JSON格式，并控制缩进和空白符</h4><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> book = &#123;<br><span class="hljs-string">"title"</span>: <span class="hljs-string">"aaa"</span>,<br><span class="hljs-string">"type"</span>: <span class="hljs-string">"bbb"</span>,<br><span class="hljs-string">"page"</span>: <span class="hljs-number">50</span><br>&#125;<br><span class="hljs-keyword">var</span> jsonBook = <span class="hljs-built_in">JSON</span>.stringify(book,<span class="hljs-literal">null</span>,<span class="hljs-string">"$$"</span>);<br><span class="hljs-built_in">console</span>.log(jsonBook)<br></code></pre></td></tr></table></figure><ul><li>得到结果：</li><li><figure class="hljs highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br><span class="hljs-attr">"title"</span>: <span class="hljs-string">"aaa"</span>,<br><span class="hljs-attr">"type"</span>: <span class="hljs-string">"bbb"</span>,<br><span class="hljs-attr">"page"</span>: <span class="hljs-number">50</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>－该方法第三个参数如果为数字，那么就是每个属性前面缩进的字符数。</p><h2 id="parse-方法"><a href="#parse-方法" class="headerlink" title="parse()方法"></a>parse()方法</h2><h4 id="用法一：把JSON转化成javascript格式-用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。"><a href="#用法一：把JSON转化成javascript格式-用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。" class="headerlink" title="用法一：把JSON转化成javascript格式, 用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。"></a>用法一：把JSON转化成javascript格式, 用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。</h4><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> book = <span class="hljs-string">'&#123;"title":"aaa", "type":"bbb", "page":"50"&#125;'</span>;<br>  <span class="hljs-keyword">var</span> demo = <span class="hljs-built_in">JSON</span>.parse(book);<br>  <span class="hljs-built_in">console</span>.log(demo);<br></code></pre></td></tr></table></figure><ul><li>得到结果：</li></ul><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<span class="hljs-attr">title</span>: <span class="hljs-string">"aaa"</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">"bbb"</span>, <span class="hljs-attr">page</span>: <span class="hljs-string">"50"</span>&#125;<br></code></pre></td></tr></table></figure><h4 id="用法二：把JSON转化为javascript过程中，改变原有的值"><a href="#用法二：把JSON转化为javascript过程中，改变原有的值" class="headerlink" title="用法二：把JSON转化为javascript过程中，改变原有的值"></a>用法二：把JSON转化为javascript过程中，改变原有的值</h4><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> book = <span class="hljs-string">'&#123;"title":"aaa", "type":"bbb", "page":50&#125;'</span>;<br>  <span class="hljs-keyword">var</span> demo = <span class="hljs-built_in">JSON</span>.stringify(book);<br>  <span class="hljs-keyword">var</span> javascriptDemo = <span class="hljs-built_in">JSON</span>.parse(demo, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key, value</span>) </span>&#123;<br> <span class="hljs-keyword">switch</span> (key) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">"title"</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">"bbbbbb"</span>;<br><span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> value;<br> &#125;<br>  &#125;);<br>  <span class="hljs-built_in">console</span>.log(javascriptDemo);<br></code></pre></td></tr></table></figure><ul><li>得到结果：<figure class="hljs highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<span class="hljs-attr">"title"</span>:<span class="hljs-string">"aaa"</span>, <span class="hljs-attr">"type"</span>:<span class="hljs-string">"bbb"</span>, <span class="hljs-attr">"page"</span>:<span class="hljs-number">50</span>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> js学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> json </tag>
            
            <tag> js </tag>
            
            <tag> js基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ajax基础知识和核心原理</title>
      <link href="/2018/02/15/ajax_base/"/>
      <url>/2018/02/15/ajax_base/</url>
      
        <content type="html"><![CDATA[<h2 id="ajax基础知识"><a href="#ajax基础知识" class="headerlink" title="ajax基础知识"></a>ajax基础知识</h2><h3 id="1-什么是ajax"><a href="#1-什么是ajax" class="headerlink" title="1.什么是ajax:"></a>1.什么是ajax:</h3><ul><li>Async Javascript And XML ====&gt; 异步的JS和XML;</li><li>XML:可扩展的标记语言(自定义的一些标签,包裹数据,服务器传递数据);</li></ul><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--&lt;?xml version="1.0" encoding="UTF-8" ?&gt;--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">student</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>王二小<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">age</span>&gt;</span>33<span class="hljs-tag">&lt;/<span class="hljs-name">age</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">sex</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">sex</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">student</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-Ajax异步的概念"><a href="#2-Ajax异步的概念" class="headerlink" title="2. Ajax异步的概念:"></a>2. Ajax异步的概念:</h2><ul><li><code>局部刷新</code>:数据传递的是json字符串,前后端分离</li><li>1).向服务器发送ajax请求;</li><li>2).将服务器返回的数据经过前端的解析处理,绑定到页面上;</li><li>3).页面只需要改变一部分,整个页面不需要重新的渲染;</li><li><code>全局刷新</code>:页面的整体刷新,当页面上数据发生改变时,向后台发送请求,后台会将页面的数据重新渲染一遍,将渲染好的页面返回给客户端呈现,这是全局刷新,也是前后端不分离。这就要求后台去套数据,一般会使用jsp来套数据;</li></ul><h2 id="前后端分离和不分离的优势和劣势"><a href="#前后端分离和不分离的优势和劣势" class="headerlink" title="前后端分离和不分离的优势和劣势"></a>前后端分离和不分离的优势和劣势</h2><h3 id="不分离的优势"><a href="#不分离的优势" class="headerlink" title="不分离的优势:"></a>不分离的优势:</h3><ul><li>1.页面上的数据都是服务器渲染好的,源代码上能看到数据,有利于SEO优化(SEO:搜索引擎的收录和抓取);</li><li>2.从服务器上获取的页面已经是渲染好的,不需要客户端在去额外的请求,所以页面加载速度比较快(前提是服务器够快),一般京东淘宝这样的页面首屏一般都是前后端不分离,直接渲染好页面给前端返回;</li><li><h4 id="不分离的劣势"><a href="#不分离的劣势" class="headerlink" title="不分离的劣势:"></a>不分离的劣势:</h4></li><li><p>1.如果页面有很多内容需要改变,需要实时获取数据,每次更新数据都要重新刷新一下页面,客户体验不好;</p></li><li>2.每次都是服务器渲染的话,对服务器的要求比较高,服务器的压力比较大,如果服务器处理不过来,就会导致加载变慢甚至服务器崩溃;所以京东淘宝等网站只有首屏才会采用服务器渲染以提高页面加载速度;</li><li>3.目前市场上前后端分离的项目占大部分;</li><li><h4 id="分离的优势"><a href="#分离的优势" class="headerlink" title="分离的优势"></a>分离的优势</h4></li><li><p>1.可以根据需求任意改变页面的某一部分的数据更新,而不用刷新整个页面(例如:实时刷新,表单提交,用户登录),用户体验好;</p></li><li>2.有利于开发,提高开发效率,开发的时候前后端互不影响,不需要考虑各自使用的技术,相当于实现了技术的分离;可以进行同时开发,项目开始的时候,只需要制定以下交互文档(API文档),规定请求的url,请求方式,参数,返回数据格式等等,前端也可以使用node模拟接口和数据,来验证和调试页面;</li></ul><h4 id="分离的弊端"><a href="#分离的弊端" class="headerlink" title="分离的弊端"></a>分离的弊端</h4><ul><li>1.不利于SEO优化(注意:后期使用JS将数据绑定到页面上,不会在源代码上体现,所以不会被SEO收录和抓取);</li><li>2.刚开始加载时,请求资源文件的时候如果请求次数过多,会影响页面的加载速度;为了防止加载速度过慢,可以进行优化处理;</li></ul><h3 id="基于原生实现ajax"><a href="#基于原生实现ajax" class="headerlink" title="基于原生实现ajax"></a>基于原生实现ajax</h3><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建ajax对象:</span><br><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br><span class="hljs-comment">// 定义请求方式,同步或者异步,请求路径等等:</span><br>xhr.open(<span class="hljs-string">"method"</span>, <span class="hljs-string">"URL"</span>, <span class="hljs-keyword">async</span>, user.name, user.password);<br><span class="hljs-comment">// 定义返回状态:</span><br>xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br><span class="hljs-keyword">if</span> (xhr.readyState === <span class="hljs-number">4</span> &amp;&amp; xhr.status === <span class="hljs-number">200</span>) &#123;<br><span class="hljs-comment">// 获取响应的文本内容;</span><br><span class="hljs-keyword">let</span> res = xhr.responseText;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 开始发送请求(请求主体的内容数据):</span><br>xhr.send(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><h3 id="分析open的参数"><a href="#分析open的参数" class="headerlink" title="分析open的参数:"></a>分析open的参数:</h3><h4 id="method-ajax的请求方式"><a href="#method-ajax的请求方式" class="headerlink" title="method: ajax的请求方式:"></a>method: ajax的请求方式:</h4><ul><li>1).<code>GET</code>系列方式(获取数据):</li><li>get: 从服务器获取数据;</li><li>delete: 从服务器上删除某些文件;</li><li>head: 获取响应头信息;(不要响应主体,只要响应头);</li><li><p>……</p></li><li><p>2).<code>POST</code>系列方式((推送数据):</p></li><li>post: 向服务器传递数据;</li><li>put: 向服务器添加指定的资源文件;</li><li><p>……</p></li><li><p><code>不管是哪一种方式,都可以向服务器发送数据,也可以获取数据,但是一般GET系列以获取为主,POST系列就是以发送数据为主;</code></p></li><li><code>1).想获取动态展示的数据(如:新闻列表),一般使用GET请求,因为只需要告诉服务器需要什么,服务器就返回需要的内容;</code></li><li><code>2).当页面上有大量信息需要发送给服务器(如:表单提交),服务器接收到数据只需要返回成功或失败的状态,此时合适POST请求;</code></li></ul><h3 id="第一个参数-GET和POST具体有哪些区别"><a href="#第一个参数-GET和POST具体有哪些区别" class="headerlink" title="第一个参数:GET和POST具体有哪些区别"></a>第一个参数:GET和POST具体有哪些区别</h3><h4 id="区别1-数据携带方式-GET向服务器发送请求时-发送的内容比POST少-获取的比POST多"><a href="#区别1-数据携带方式-GET向服务器发送请求时-发送的内容比POST少-获取的比POST多" class="headerlink" title="区别1:数据携带方式:  GET向服务器发送请求时,发送的内容比POST少,获取的比POST多;"></a>区别1:数据携带方式:  <code>GET</code>向服务器发送请求时,发送的内容比<code>POST</code>少,获取的比<code>POST</code>多;</h4><ul><li>1.GET请求的参数是拼接在url上的,通过url的参数形式来传递数据,但是url的大小是有限制的,只有几KB,一旦超过限制,就会被默认剪切掉,所以无法携带大量的数据;</li><li>2.<code>POST</code>发送的数据是通过请求主体实现的,理论上大小是没有限制的,但是真实项目中为了保证传输数据的速度,也会加一些限制(例如:上传资料/图片等等文件时,后台服务器做一下特殊处理);</li></ul><h4 id="区别2-缓存问题-GET请求容易走缓存-POST不会"><a href="#区别2-缓存问题-GET请求容易走缓存-POST不会" class="headerlink" title="区别2:缓存问题: GET请求容易走缓存,POST不会:"></a>区别2:缓存问题: <code>GET</code>请求容易走缓存,<code>POST</code>不会:</h4><ul><li><code>GET</code>通过url传参数的方式请求数据,当遇到实时获取数据的时候,以为url是一样的,参数也是一样的,此时浏览器就会默认读取缓存中的内容返回给页面,导致获取不到服务器最新的数据,一般都是在参数后面加一个时间戳或者随机数来防止浏览器读取缓存;</li><li><code>POST</code>请求不会走缓存,因为请求的数据在请求主体中,是不会走缓存的;</li></ul><h4 id="区别3-安全性-GET请求法师没有POST请求方式安全"><a href="#区别3-安全性-GET请求法师没有POST请求方式安全" class="headerlink" title="区别3:安全性: GET请求法师没有POST请求方式安全:"></a>区别3:安全性: <code>GET</code>请求法师没有<code>POST</code>请求方式安全:</h4><ul><li><code>GET</code>的参数在url上,一些简单的黑客技术,拦截url(url劫持),也可以把客户端传递的信息获取到,导致信息泄露;</li><li><code>POST</code>的信息都在请求主体中,相对比较安全;</li></ul><h3 id="第二个参数-URL"><a href="#第二个参数-URL" class="headerlink" title="第二个参数:URL"></a>第二个参数:URL</h3><ul><li><code>这个url地址就是后台给的地址,一般都会有一个API文档,参照文档写就成;</code></li></ul><h3 id="第三个参数-Async"><a href="#第三个参数-Async" class="headerlink" title="第三个参数: Async"></a>第三个参数: Async</h3><ul><li>async: true 不写就是默认true,===&gt;异步;</li><li>async:false ===&gt; 同步;</li></ul><h3 id="最后两个参数-用户名-密码"><a href="#最后两个参数-用户名-密码" class="headerlink" title="最后两个参数:用户名,密码"></a>最后两个参数:用户名,密码</h3><blockquote><p><code>一般不需要写,只有一些服务器不允许匿名访问,只有开通权限的才可以访问,比如一些重要机密的,银行等这样的服务器才会设置权限;</code></p></blockquote><h4 id="第三部分解析"><a href="#第三部分解析" class="headerlink" title="第三部分解析"></a>第三部分解析</h4><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>ajax请求中xhr.readyState的状态码: </p><ul><li>0: 创建一个ajax对象,默认状态是0;</li><li>1: 执行xhr.open是1;</li><li>2: 请求已发送,并接受到了响应头是2;</li><li>3: 响应主体在路上是3;</li><li>4:响应主体返回客户端是4;</li></ul><p>ajax请求中xhr.status的HTTP网络状态码:</p><ul><li>200:成功状态,一个完整的HTTP事物完成,以2开头的都是成功状态;</li><li>300:以3开头的状态码也是成功状态,只不过是服务器做了一些处理;</li><li>301:永久重定向(永久转移),一般都是域名的迁移;比如京东的www.360buy.com重定向到www.jd.com;</li><li>302:临时重定向(临时转移),在新版的HTTP中307也代表临时重定向,一般是在处理服务器的负载均衡,当一个服务器负荷太大,将内容临时迁移到另一个服务器上处理,主要是一些图片,有一些大公司一般都有专门处理图片的服务器;</li><li>304:从浏览器中读取缓存,把一些不经常更新的文件和图片缓存,减少服务器的压力,增加页面的加载速度;</li></ul><p>以4开头的都是失败的,一般都是客户端的错误;</p><ul><li>400:请求参数错误;</li><li>401:无权限访问;</li><li>404:访问的地址不存在;</li></ul><p>以5开头的一般都是服务器的错误;</p><ul><li>500:服务器未知错误;</li><li>503:服务器超负载;</li></ul></blockquote><h3 id="ajax常用的属性和方法有哪些"><a href="#ajax常用的属性和方法有哪些" class="headerlink" title="ajax常用的属性和方法有哪些"></a>ajax常用的属性和方法有哪些</h3><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br><span class="hljs-built_in">console</span>.dir(xhr);<br></code></pre></td></tr></table></figure><blockquote><p>[属性]</p><ul><li>readyState:存储的是ajax的状态码;</li><li>responseText/responseXML:返回的是响应主体的内容,只是格式不一样,使用不同的属性接收即可;<ul><li>responseText 一般都是json字符串;</li><li>responseXML是XML格式的数据字符串;</li></ul></li><li>status:记录服务器返回的HTTP状态码;</li><li>statusText:对返回状态码status的描述;</li><li>timeout:设置ajax请求的超时时间;超过设置的时间响应主体还没回来,浏览器就会把请求强制断开;</li></ul><p>[方法]</p><ul><li>abort():强制中断ajax请求;</li><li>getAllResponseHeaders();获取全部响应头的信息(获取的是一堆字符串文本);</li><li>getResponseHeader(“属性名”);获取指定的响应头;如:getResponseHeader(“date”);获取响应头中存储的服务器的时间;</li><li>open(); 略</li><li>overrideMimeType();重写MIME类型;</li><li>send(); 略</li><li>setRequestHeader(“属性名”,属性值);设置请求头;<code>注意</code>:必须写在open()之后,send()之前,内容不可以是中文,否则会报错;</li></ul><p>[事件]</p><ul><li>onabort();当ajax中断的时候触发的事件;</li><li>onreadystatechange();当ajax状态发生变化就会触发的事件;</li><li>ontimeout();当ajax超时触发的事件;</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> ajax </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>node学习笔记</title>
      <link href="/2018/02/15/node_base/"/>
      <url>/2018/02/15/node_base/</url>
      
        <content type="html"><![CDATA[<h2 id="1-node-能够解决什么问题"><a href="#1-node-能够解决什么问题" class="headerlink" title="1.node 能够解决什么问题?"></a>1.node 能够解决什么问题?</h2><blockquote><p>node的首要目标是提供一种简单的,用于创建高性能服务器的开发工具;<br>Web服务器的瓶颈在于并发的用户量,对比java和PHP的实现方式;</p></blockquote><h2 id="2-node是什么"><a href="#2-node是什么" class="headerlink" title="2.node是什么?"></a>2.node是什么?</h2><blockquote><p>node.js是一个基于Chrome V8 引擎的JavaScript运行环境,让JavaScript的执行效率与底端的C语言的执行效率相近;<br>node.js使用了一个事件驱动,非阻塞式I/O的模型,使其轻量又高效;<br>node.js的包管理器npm,是全球最大的开源库生态系统;</p></blockquote><h2 id="3-node特点"><a href="#3-node特点" class="headerlink" title="3.node特点"></a>3.node特点</h2><h3 id="3-1-为什么JavaScript是单线程"><a href="#3-1-为什么JavaScript是单线程" class="headerlink" title="3.1 为什么JavaScript是单线程?"></a>3.1 为什么JavaScript是单线程?</h3><blockquote><p>这是由JavaScript这门脚本语言的用途决定的;<br>Web Worker并没有改变JavaScript单线程的本质;</p></blockquote><h3 id="3-2-浏览器模型"><a href="#3-2-浏览器模型" class="headerlink" title="3.2 浏览器模型"></a>3.2 浏览器模型</h3><blockquote><p>用户界面:包括地址栏,前进后退按钮,书签菜单等;<br>浏览器引擎: 在用户界面和呈现引擎之间传送指令;<br>呈现引擎:又称渲染引擎,也被成为浏览器内核,在线程方面又称UI线程;<br>网络:用于网络调用,比如: HTTP请求;<br>用户界面后端:用于绘制基本的窗口小部件,UI线程和JS共用一个线程;<br>JavaScript解析器:用于解析和执行JavaScript代码;<br>数据存储:这是持久层;浏览器需要在硬盘上保存各种数据,例如Cookie;</p></blockquote><h3 id="3-3-除了JS线程和UI线程之外的其它线程"><a href="#3-3-除了JS线程和UI线程之外的其它线程" class="headerlink" title="3.3 除了JS线程和UI线程之外的其它线程"></a>3.3 除了JS线程和UI线程之外的其它线程</h3><blockquote><p>浏览器事件触发线程<br>定时触发器线程<br>异步HTTP请求线程</p></blockquote><h3 id="3-4-任务队列"><a href="#3-4-任务队列" class="headerlink" title="3.4 任务队列"></a>3.4 任务队列</h3><blockquote><p>1.所有同步任务都是在主线程上执行,形成一个执行栈;<br>2.主线程之外,还存在一个任务队列,只要异步任务有了运行结果,就在任务队列中放置一个事件;<br>3.一旦执行栈中的所有同步任务执行完毕,系统就会读取任务队列,看看里面有哪些事件,哪些对应的异步任务,于是结束等待状态,进入执行栈,开始执行;<br>4.主线程不断重复上面的第三步;</p></blockquote><h3 id="3-5-EventLoop"><a href="#3-5-EventLoop" class="headerlink" title="3.5 EventLoop"></a>3.5 EventLoop</h3><blockquote><p>主线程从任务队列中读取事件,这个过程是循环不断的,所以整个的这种运行机制又称为EventLoop(事件循环);</p></blockquote><h3 id="3-6-node-js的EventLoop"><a href="#3-6-node-js的EventLoop" class="headerlink" title="3.6 node.js的EventLoop"></a>3.6 node.js的EventLoop</h3><blockquote><p>1.V8引擎解析JavaScript脚本;<br>2.解析后的代码,调用node API;<br>3.libuv库负责node API的执行,将不用的任务分配给不同的线程,形成一个EventLoop(事件循环),以异步的方式将任务的执行结果返回个V8引擎;<br>4.V8引擎再将结果返回给 用户;</p></blockquote><h3 id="3-7-同步与异步"><a href="#3-7-同步与异步" class="headerlink" title="3.7 同步与异步"></a>3.7 同步与异步</h3><blockquote><p>同步和异步关注的是消息通知机制;<br><code>同步</code>就是发出调用后,没有得到结果之前,该调用不返回,一旦调用返回,就得到返回值了。简而言之就是调用者主动等待这个调用的结果;<br><code>异步</code>则相反,调用者在发出调用后这个调用就直接返回了,所以没有返回结果,即:当一个异步过程调用发出后,调用者不会立刻得到结果,而是调用发出后,被调用者通过状态、通知或回调函数处理这个调用;</p></blockquote><h3 id="3-8-阻塞与非阻塞"><a href="#3-8-阻塞与非阻塞" class="headerlink" title="3.8 阻塞与非阻塞"></a>3.8 阻塞与非阻塞</h3><blockquote><p>阻塞和非阻塞关注的是程序在等待调用结果(消息/返回值)时的状态;<br><code>阻塞</code>调用是指调用结果返回之前,当前线程会被挂起,只有在得到结果之后才会返回;<br><code>非阻塞</code>调用是指在不能立刻得到结果之前,该调用不会阻塞当前线程;</p></blockquote><h3 id="3-9-组合"><a href="#3-9-组合" class="headerlink" title="3.9 组合"></a>3.9 组合</h3><p><strong><code>同步异步取决于被调用者,阻塞非阻塞取决于调用者;</code></strong></p><blockquote><p>同步阻塞: A给B打电话商量事情,通话过程中B考虑了1分钟(同步),A等待了1分钟什么也没干(阻塞);<br>异步阻塞: A给B打电话商量事情,B挂断电话1分钟后回复A(异步),A等待了1分钟什么也没干(阻塞);<br>同步非阻塞: A给B打电话商量事情,通话过程中B考虑了1分钟(同步),A在这1分钟里干了别的事情(非阻塞)<br>异步非阻塞: A给B打电话商量事情,B挂断电话1分钟后回复A(异步),A在这1分钟里干了别的事情(非阻塞);</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>做过的案例</title>
      <link href="/2018/02/15/case-demo-2/"/>
      <url>/2018/02/15/case-demo-2/</url>
      
        <content type="html"><![CDATA[<h2 id="豆瓣电影案例"><a href="#豆瓣电影案例" class="headerlink" title="豆瓣电影案例"></a><a href="http://www.wanglichao.top/douban-movie/">豆瓣电影案例</a></h2><h2 id="备忘录案例"><a href="#备忘录案例" class="headerlink" title="备忘录案例"></a><a href="http://www.wanglichao.top/todo/">备忘录案例</a></h2><h2 id="弹力运动案例"><a href="#弹力运动案例" class="headerlink" title="弹力运动案例"></a><a href="http://flex.wanglichao.top/" target="_blank" rel="noopener">弹力运动案例</a></h2><h2 id="开屏导航栏"><a href="#开屏导航栏" class="headerlink" title="开屏导航栏"></a><a href="http://spread.wanglichao.top/" target="_blank" rel="noopener">开屏导航栏</a></h2><h2 id="微金所案例"><a href="#微金所案例" class="headerlink" title="微金所案例"></a><a href="http://wjs.wanglichao.top/" target="_blank" rel="noopener">微金所案例</a></h2><h2 id="电商平台案例"><a href="#电商平台案例" class="headerlink" title="电商平台案例"></a><a href="http://www.wanglichao.top/vue-project-01/">电商平台案例</a></h2><h2 id="未完成的读书器"><a href="#未完成的读书器" class="headerlink" title="未完成的读书器"></a><a href="http://www.wanglichao.top/case_FictionReader/">未完成的读书器</a></h2><h2 id="商城后台管理系统案例"><a href="#商城后台管理系统案例" class="headerlink" title="商城后台管理系统案例"></a><a href="https://github.com/wangwangwanglichao/admin-v2-fe/tree/tag-product-02" target="_blank" rel="noopener">商城后台管理系统案例</a></h2>]]></content>
      
      
      <categories>
          
          <category> 案例 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 案例 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS编码方式</title>
      <link href="/2018/02/15/JS_base/"/>
      <url>/2018/02/15/JS_base/</url>
      
        <content type="html"><![CDATA[<h2 id="JS的编码解码"><a href="#JS的编码解码" class="headerlink" title="JS的编码解码"></a>JS的编码解码</h2><ul><li>1.escape/unescape(一般只有js支持,前端网页之间的数据传递的时候进行的中文编码和解码);</li><li>2.encodeURI/decodeURI;所有的语言都支持;</li><li>3.encodeURIComponent/decodeURIComponent;同上面,这个可以编译一些特殊字符,上面的不行,最常用的是这个;</li></ul><h2 id="ajax的异步和同步问题"><a href="#ajax的异步和同步问题" class="headerlink" title="ajax的异步和同步问题"></a>ajax的异步和同步问题</h2><ul><li>ajax任务:发送请求到收到响应主体内容(完整的HTTP事物);</li><li>ajax任务开始时发送请求开始(xhr.send());</li><li>同步请求下,绑定监听状态的事件(onreadystatechange)放在open之前可以监听1,4的状态,不可以放在send之后,因为send执行就已经状态为4, 结束了;</li><li>异步请求下,绑定监听状态的事件(onreadystatechange)放在open之前可以监听1,2,3,4的状态,放在open之后可以监听2,3,4的状态,</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>node介绍</title>
      <link href="/2018/02/15/nodejs_base/"/>
      <url>/2018/02/15/nodejs_base/</url>
      
        <content type="html"><![CDATA[<h2 id="nodejs介绍"><a href="#nodejs介绍" class="headerlink" title="nodejs介绍"></a>nodejs介绍</h2><h4 id="nodejs不是一门语言-是一个运行环境-在node环境中运行JS"><a href="#nodejs不是一门语言-是一个运行环境-在node环境中运行JS" class="headerlink" title="nodejs不是一门语言,是一个运行环境,在node环境中运行JS;"></a>nodejs不是一门语言,是一个运行环境,在node环境中运行JS;</h4><blockquote><p>1.使用的是Chrome的V8引擎;<br>2.基于事件驱动的I/O操作(input/output);<br>3.单线程异步开发;<br>4.因为使用JS,所以适合前端人员上手;<br>5.自带NPM包管理器(全球最大的包管理器,使用NPM安装各种开发需要的安装包);<br>6.模块化开发,node自带很多内置模块;</p></blockquote><h3 id="node中的模块"><a href="#node中的模块" class="headerlink" title="node中的模块"></a>node中的模块</h3><h4 id="node中的模块分为三种"><a href="#node中的模块分为三种" class="headerlink" title="node中的模块分为三种"></a>node中的模块分为三种</h4><blockquote><p>1.内置模块: node自带的模块,如fs,http,url…等等;官方中文文档: <a href="http://nodejs.cn/api" target="_blank" rel="noopener">http://nodejs.cn/api</a><br>2.自定义模块: 自己写的模块,一个JS就是一个模块,用的时候需要导入进来;<br>3.第三方模块: 别人发布的模块,需要下载安装来使用(一般使用NPM包管理器安装);</p></blockquote><h3 id="如何使用npm安装第三方模块"><a href="#如何使用npm安装第三方模块" class="headerlink" title="如何使用npm安装第三方模块"></a>如何使用npm安装第三方模块</h3><blockquote><p><code>npm init -y</code><br>创建package.json文件,记录开发依赖<br><code>npm install less -g</code><br>将less安装在全局中;<br>g  –&gt; global, node中的全局对象<br><code>npm install less</code><br>将less安装在当前项目下;<br><code>npm install less --save-dev</code><br>“–save” 生产依赖<br>“–save-dev” 开发依赖</p><p>在package.json文件中,出现:<br><code>&quot;devDependencies&quot;: {     &quot;less&quot;: &quot;^2.7.3&quot;}</code><br>来记录开发依赖;</p><p><code>&quot;dependencies&quot;: {    &quot;bootstrap&quot;: &quot;^4.0.0&quot;}</code><br>来记录生产依赖</p><p>安装了第三方模块会在当前项目下自动创建一个node_modules文件夹和一个package-lock.json文件</p><ul><li>NODE <ul><li>node_modules</li><li>package-lock.json</li></ul></li></ul><p>得到一个package.json文件,里面有配置好的文件名称,直接运行npm install回车,即可安装所有文件,叫做跑环境;</p></blockquote><h3 id="fs模块"><a href="#fs模块" class="headerlink" title="fs模块"></a>fs模块</h3><blockquote><p>fs是node内置模块,处理文件写入和读取;<br>内置模块需要require导入进来</p><ul><li>引入fs模块</li><li>let fs = require(“fs”);</li><li></li><li>读取文件内容</li><li>fs.readFile();异步读取,不管是否读取完成,后面代码不受影响,继续执行;</li><li>fs.readFileSync();同步读取,只有读取完成后才会执行后面的代码;</li><li>fs.readFileSync([“pathName路径(必填)]”,[编码格式”urf-8”(选填)]);</li><li>fs.readFile([“pathName路径(必填)]”,[编码格式”urf-8”(选填)], (error, value) =&gt; {</li><li>todoSomething…</li><li>});</li><li></li><li>写入文件内容</li><li>fs.writeFile(“文件的路径”, “写入的内容”, “编码”, 回调函数callback);异步写入;</li><li>fs.writeFileSync(“文件的路径”, “写入的内容”, “编码”);同步写入;</li><li>写入文件内容相当于重写文件内容,之前的内容就会覆盖消失;</li><li></li><li>读取文件夹(文件目录)</li><li>fs.readdir(“路径”, (error, value) =&gt; {</li><li>value是一个数组:[“文件夹名字”, “文件夹名字”,…];</li><li>todoSomething…</li><li>});</li><li>fs.readdirSync(“路径”); 也是返回一个数组;</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>人生最重要的三种能力</title>
      <link href="/2018/02/14/article-0001/"/>
      <url>/2018/02/14/article-0001/</url>
      
        <content type="html"><![CDATA[<h1 id="网络转载——人生最重要的三种能力，不是读书能学来的"><a href="#网络转载——人生最重要的三种能力，不是读书能学来的" class="headerlink" title="网络转载——人生最重要的三种能力，不是读书能学来的"></a>网络转载——人生最重要的三种能力，不是读书能学来的</h1><h3 id="一、人际交往中的期望值管理能力"><a href="#一、人际交往中的期望值管理能力" class="headerlink" title="一、人际交往中的期望值管理能力"></a>一、人际交往中的期望值管理能力</h3><h3 id="二、阈值自控意识"><a href="#二、阈值自控意识" class="headerlink" title="二、阈值自控意识"></a>二、阈值自控意识</h3><h3 id="三、应对主观时空扭曲的能力"><a href="#三、应对主观时空扭曲的能力" class="headerlink" title="三、应对主观时空扭曲的能力"></a>三、应对主观时空扭曲的能力</h3><h2 id="一-期望值管理能力"><a href="#一-期望值管理能力" class="headerlink" title="(一)期望值管理能力"></a>(一)期望值管理能力</h2><ul><li>影视剧中往往有这样的观感：一个地痞或者土匪，平日无恶不作。到了最后一集，哎，这货突然抗日了，例如《大宅门》里的三爷。</li><li>这时候观众对其好感度会突然爆棚，甚至超过许多没有爆点的正面角色，前几十集的劣迹简直一笔勾销。</li><li>这就是期望值在前期被编剧压低之后的福利.</li><li>先记住一个公式：</li><li>快乐值 = 现实 - 期望值</li><li>我们刚进入一个团队时，如果一开始就大招尽出，会导致周围人和领导对你的期望值不断升高。</li><li>最后总会有一次你满足不了对方的要求，这时候对你的负面评价也会随之而起，甚至会低过一直表现平平的同仁。</li><li>有人将其总结为“不胜任陷阱”，因为在一个上升通道中，只要达到了上层的期望，就会被继续提拔。</li><li>知道提拔到一个你不能胜任的岗位，让所有人失望，这个升迁过程才会结束。</li><li>这一点在情场上也依然适用，你会发现浪子回头会获得相当的赞美，许多女人甚至可以不计较你之前是个多么烂的人；</li><li>但老实巴交的“好好男人”一旦被抓到一次不老实就立刻被打入“渣男”的行列再也不得翻身。</li><li>娱乐圈这样的例子年年都有，不再赘述。</li><li>这就需要我们对别人对我们的期望值进行有限管理。</li><li>比较常见的手段是憋大招，有一些在对方期待之外的东西不到关键时刻不能随便拿出来用。</li><li>但周围人也不是傻瓜，次数多了，别人都会倾向于相信你藏着一手。</li><li>例如学生时代那些永远叫嚷着这次考砸了的第一名们，信誉早已破产，其他人对其期望值依然在持续上升，这时候成熟的压力可想而知。</li><li><strong>要真正做到有效控制周围人对你的期望值，需要做到真正无迹可寻，并在所有非必要的时候压抑自己的表现欲与虚荣心。</strong></li><li>我认为这是进入职场的第一课。</li></ul><h2 id="（二）阈值自控意识"><a href="#（二）阈值自控意识" class="headerlink" title="（二）阈值自控意识"></a>（二）阈值自控意识</h2><ul><li>阈值又叫临界值，指释放一个行为反应所需要的最小刺激强度。</li><li>引用网上的一段文章：</li><li>A片害了无数正常的男青年，没有A片的岁月里，男孩子满脑邪念充盈。</li><li>可是在这个网络色情泛滥的当今，他们居然对生活中的女人没了想法，这不能不成为信息时代人类异化的经典案例。</li><li>何以至此？阈值使然。也就是不断的持续刺激，太高了男人们欲望的触发点。</li><li>上个世纪初，女人旗袍坐下时偶尔可一瞥的白花花大腿就可以出发老夫子们的欲念；</li><li>可是100年后，看着满屏的玉体横陈，很多人居然会叹上一句： 没意思！</li><li>这就是时代的变迁，使得阈值不断上升的最好例证。</li><li>举个极端的例子，释迦牟尼本是个迦毗罗卫国的王子，很早就过着锦衣玉食的生活。其父为其修筑 春/夏/冬 三座宫殿。但他获得很厌世。</li><li>其父为其选来印度最妖艳美丽的女子来取悦他，但是美酒美女对他的边际效用已经小道忽略，食欲肉欲的一切无法使他获得更高的满足，只有离开世俗创造佛教去了。</li><li>他一出生就享受物质的极大满足，导致他的阈值搞到普通人难以想象的程度，最后凡是物质都无法使他快活。</li><li>中国的例子是贾宝玉，从小活在女人堆里，最后也做和尚去了</li><li>反而自小出家的人却未必能忘俗，所以施耐庵会有和尚最淫一说，潘巧云与裴如海那一段有很精妙的点评。</li><li>自幼出家的人，从未享受过世俗的快感，所以阈值很低，一点就着。</li><li>能大彻大悟的慧根认识，往往反而是富家弟子，也就不奇怪了。</li><li>女人亦然。</li><li>泛滥的韩剧将正常的女生活生生逼成大龄剩女，归根到底也是阈值作怪。</li><li>本来少女看见年轻男子怀春，是老天爷安排的正常心理活动。现在这个自然的程序被突然打断，横插10部韩剧，男一号个个多金英俊完美，还有若干男二男三争抢。</li><li>电视机钱的女人们于是看傻了，爱情阈值被活生生地抬道天上，身边的男人自然再也看不上。</li><li>但你深刻理解了阈值对个人幸福与快乐的影响后，你就知道这个该概念不仅用在性和爱情上，更可以推广到人生幸福的方方面面。</li><li>了解边际效用递减的规律，并学会一定程度的禁欲和自控，是防止阈值升高的不二法门。</li><li>这绝对是需要在人生早期就要着力培养和锻炼的素质与意识，尤其对于男性。</li><li>顺便提下，频繁观看色情片造成的刺激过度，会抑制大脑内对性刺激做出神经反应的奖赏机制。</li><li>与药物成瘾相似，这种神经抑制会促使强迫的色情成瘾行为，并对正常的性意愿和性欲造成影响，可惜，对于有些人，这些话来的有点晚了。</li></ul><h2 id="（三）应对主观时空扭曲的能力"><a href="#（三）应对主观时空扭曲的能力" class="headerlink" title="（三）应对主观时空扭曲的能力"></a>（三）应对主观时空扭曲的能力</h2><ul><li>这个概念有点玄。这里说的时空扭曲，指的是主观的时间流逝感觉随着年龄开始加速，而且一发不可收拾。</li><li>相信大部分人都有这样的感觉，时间过的越来越快了。</li><li>小学时是一个月一个月过，大学一学期一学期过，工作后就变成了一年一年过。</li><li>越往上过度越快，问问你的父母，他们会告诉你十年一眨眼就没了，他们讨论着十几年二十年前的陈年旧事，好像就发生在昨天。</li><li>网上的一个说法比较有趣：</li><li>“五岁的时候人的记忆有五年，这时候过一年，到六岁时，记忆增加了五分之一；六岁到七岁，记忆增加六分之一。</li><li>以此类推，到了二十岁的时候，过一年，记忆便只增加二十分之一。</li><li>这一年的时光虽然没变，但是参照物变了，所以大家就感觉时间过得快了。</li><li>可能等你六十岁的时候，过一年记忆只增加六十分之一，那时候就过得更快了。”</li><li>这个说法有一定的道理。</li><li>如果你仔细回忆一下会发现：</li><li>童年的课间十分钟足够你从楼上跑下去玩点什么；</li><li>但现在你坐在公司电脑前，才喝了杯热饮，把东西摊开准备干活，啥都没干呢一个小时就没了。</li><li>小时候两个月的暑假特别漫长，现在的一个月不就是四个星期，一眨眼就没了。</li><li>如果用记忆增量理论来解释，就就说明我们在成年后的工作和生活都是在简单重复，所以大脑中的“总数居”并没有像儿时那样迅猛增长。</li><li>大脑处理今天的24小时，只需要动用几年前就已经存好的索引，驾轻就熟。</li><li>总信息量几乎没有增加，你主观上感受到的“新东西”当然就少，而体验“新东西”恰恰是放慢主管时间的命门。</li><li><strong>要解决时空扭曲的问题，我们必须走出“熟悉区”，“熟悉区”是时空黑洞，会不断加速消耗，吞噬你的时间。</strong></li><li>如果你走出办公室，去陌生的国家一个月，就会发现这一个月并没有像办公室里那样，星期三过完就差不多能指望星期天了，而是觉得一个星期比在办公室两个星期都要多，这便是对抗时空扭曲的一个例子。</li><li>并不是只有旅游才能有这样的效果，你如果在自己身上多试验，会发现能找到很多使用于你个人的手段，但前提是你要有“摆脱熟悉区”的意识。</li><li><strong>这是我认为人的一生所需要掌握的最重要能力之一，掌握了对抗时空扭曲的本领，你就能延长主观生命。</strong></li><li><img src="http://wx2.sinaimg.cn/mw690/005Io8Oqgy1fof7bt6ywdj30m80m8mzw.jpg" alt="不慌是一种底气，不乱是一种境界"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 人生杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人生 </tag>
            
            <tag> 职场 </tag>
            
            <tag> 能力 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo 常用命令入门</title>
      <link href="/2018/02/11/Hexo-base/"/>
      <url>/2018/02/11/Hexo-base/</url>
      
        <content type="html"><![CDATA[<p>欢迎使用hexo! 这是第一篇文章， 查阅 <a href="https://hexo.io/docs/" target="_blank" rel="noopener">文档</a>了解更多信息。 如果在使用Hexo时遇到任何问题, 你可以在 <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">故障诊断</a>中找到答案， 或者在<a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>上向我提问。（前面的链接不是我的<a href="https://github.com/wangwangwanglichao" target="_blank" rel="noopener">Github</a>哦！是原作者的）</p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="创建一个新帖子"><a href="#创建一个新帖子" class="headerlink" title="创建一个新帖子"></a>创建一个新帖子</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span><br></code></pre></td></tr></table></figure><p>详细信息: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">作品示例</a></p><h3 id="运行服务器"><a href="#运行服务器" class="headerlink" title="运行服务器"></a>运行服务器</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>详细信息: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">服务器</a></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>详细信息: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">生成</a></p><h3 id="部署到远程站点"><a href="#部署到远程站点" class="headerlink" title="部署到远程站点"></a>部署到远程站点</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>详细信息: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">部署</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>你好,Hexo</title>
      <link href="/2018/02/11/hello-Hexo/"/>
      <url>/2018/02/11/hello-Hexo/</url>
      
        <content type="html"><![CDATA[<h1 id="Hi！我是王立超"><a href="#Hi！我是王立超" class="headerlink" title="Hi！我是王立超"></a>Hi！我是王立超</h1><hr><pre><code>一个很普通的人,目前做着一份很普通的工作;后来经过朋友推荐开始边工作边自学前端的菜鸟之路;不管道路有多坎坷,我都不想放弃;每天只要有进步;我就为自己高兴,因为我距离自己的梦想更近了一些;想成为一名前端工程师,我,一直在路上...</code></pre><hr><ul><li>这是我第一次使用hexo搭建我的博客，终于成功了，好高兴！</li><li>努力学习中，希望自己每天都有进步,加油！</li></ul>]]></content>
      
      
      <categories>
          
          <category> 搭建博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS布局之多列布局</title>
      <link href="/2018/02/11/CSSlayout-02/"/>
      <url>/2018/02/11/CSSlayout-02/</url>
      
        <content type="html"><![CDATA[<ul><li>前端布局非常重要的一环就是页面框架的搭建，也是最基础的一环。在页面框架搭建之中，又有居中布局/多列布局/全局布局。本文介绍一下多列布局的一些技巧。</li></ul><h1 id="多列布局"><a href="#多列布局" class="headerlink" title="多列布局"></a>多列布局</h1><h2 id="定宽-自适应"><a href="#定宽-自适应" class="headerlink" title="定宽 + 自适应"></a>定宽 + 自适应</h2><h4 id="1-使用float-overflow："><a href="#1-使用float-overflow：" class="headerlink" title="1.使用float + overflow："></a>1.使用float + overflow：</h4><ul><li>原理: 通过将左边子元素脱离文档流,设置右边子元素规定当内容溢出元素框时发生的事情以达到多列布局;</li><li>用法：先将左边子元素设置为float:left;再设置右边子元素为overflow:hidden;</li><li>示例：</li></ul><figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">'parent'</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">'left'</span>&gt;</span>我是内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">'right'</span>&gt;</span>我是内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.left</span> &#123;<br><span class="hljs-attribute">float</span>: left;<br><span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br><span class="hljs-attribute">margin-right</span>: <span class="hljs-number">20px</span>;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br><span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>优点:简单。</li><li>缺点:不支持IE6。</li></ul><h4 id="2-使用float-margin"><a href="#2-使用float-margin" class="headerlink" title="2.使用float + margin"></a>2.使用float + margin</h4><ul><li>原理:通过将左边子元素脱离文档流,右边子元素向右移动一定的距离,以达到视觉上的多列布局;</li><li>用法:左边子元素设置为float:left,再设置右边子元素margin-left;</li><li>示例:</li></ul><figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">'parent'</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">'left'</span>&gt;</span>我是内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">'right'</span>&gt;</span>我是内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.left</span> &#123;<br><span class="hljs-attribute">float</span>: left;<br><span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br><span class="hljs-attribute">margin-left</span>: <span class="hljs-number">120px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>优点:简单;</li><li>缺点:兼容性存在一定的问题,IE6下有3px的bug;right下的p清除浮动将产生bug;</li></ul><h4 id="3-使用float-margin-改良版"><a href="#3-使用float-margin-改良版" class="headerlink" title="3.使用float + margin (改良版)"></a>3.使用float + margin (改良版)</h4><ul><li><p>原理:在1的基础上,通过向右边子元素添加一个父元素,再加上设置左边子元素、右边父元素属性使之产生BFC以去除bug。</p></li><li><p>示例:</p></li></ul><figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">'parent'</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">'left'</span>&gt;</span>我是内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">'right-fix'</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">'right'</span>&gt;</span><br>我是内容<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.left</span> &#123;<br><span class="hljs-attribute">float</span>: left;<br><span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br><span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.right-fix</span> &#123;<br><span class="hljs-attribute">float</span>: right;<br><span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br><span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br><span class="hljs-attribute">margin-left</span>: <span class="hljs-number">120px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-使用table"><a href="#4-使用table" class="headerlink" title="4.使用table"></a>4.使用table</h4><ul><li>原理:通过将父元素设置为表格,将左右子元素转化为类似于同一行的td,从而达到多列布局</li><li><p>用法:先将父元素设置为display:table;width:100%;table-layout:fixed;,再设置左右子元素display:table-cell;最后设置左子元素的width、padding-right;</p></li><li><p>示例:</p></li></ul><figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">'parent'</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">'left'</span>&gt;</span><br>我是内容<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">'right'</span>&gt;</span><br>我是内容<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br><span class="hljs-attribute">display</span>:table;<br><span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>;<br><span class="hljs-attribute">table-layout</span>:fixed;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br><span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br><span class="hljs-attribute">padding-right</span>: <span class="hljs-number">20px</span>;<br>&#125;<br><span class="hljs-selector-class">.right</span>,<br><span class="hljs-selector-class">.left</span> &#123;<br><span class="hljs-attribute">display</span>:table-cell;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-使用flex"><a href="#5-使用flex" class="headerlink" title="5.使用flex"></a>5.使用flex</h4><ul><li>原理:通过设置flex属性,从而达到多列布局</li><li><p>用法:先将父元素设置为display:flex;再设置左边子元素flex:1;最后设置左边子元素的width/margin-right;</p></li><li><p>示例:</p></li></ul><figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">'parent'</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">'left'</span>&gt;</span><br>我是内容<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">'right'</span>&gt;</span><br>我是内容<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br><span class="hljs-attribute">display</span>:flex;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br><span class="hljs-attribute">width</span>: <span class="hljs-number">100</span>;<br><span class="hljs-attribute">margin-right</span>: <span class="hljs-number">20px</span>;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br><span class="hljs-attribute">flex</span>:<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>优点:flex很强大;</li><li>缺点:兼容性和性能方面存在一定问题;</li></ul><h2 id="两列定宽-一列自适应"><a href="#两列定宽-一列自适应" class="headerlink" title="两列定宽 + 一列自适应"></a>两列定宽 + 一列自适应</h2><ul><li>这种情况和两列定宽差不多,先将左边子元素和中间子元素设置为float:left;width;margin-right;再设置右边子元素overflow:hidden;</li></ul><figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">'parent'</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">'left'</span>&gt;</span><br>我是左侧内容<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">'center'</span>&gt;</span><br>我是中间内容<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">'right'</span>&gt;</span><br>我是右侧内容<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.left</span>,<br><span class="hljs-selector-class">.center</span> &#123;<br><span class="hljs-attribute">float</span>:left;<br><span class="hljs-attribute">width</span>:<span class="hljs-number">100px</span>;<br><span class="hljs-attribute">margin-right</span>:<span class="hljs-number">20px</span>;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br><span class="hljs-attribute">overflow</span>:hidden;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="不定宽-自适应"><a href="#不定宽-自适应" class="headerlink" title="不定宽 + 自适应"></a>不定宽 + 自适应</h2><h4 id="使用float-overflow"><a href="#使用float-overflow" class="headerlink" title="使用float + overflow"></a>使用float + overflow</h4><ul><li>原理:类似于两列定宽;</li><li><p>用法:将左侧框设置为float:left、margin-right:xx,再设置右侧框overflow:hidden,最后设置左侧框的内容宽度;</p></li><li><p>示例:</p></li></ul><figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">'parent'</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">'left'</span>&gt;</span><br>我是内容<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">'right'</span>&gt;</span><br>我是内容<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.left</span> &#123;<br>    <span class="hljs-attribute">float</span>: left;<br>    <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">20px</span>;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><span class="hljs-selector-class">.left</span> <span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>优点: 简单;</li><li>缺点: IE6下兼容性存在问题;</li></ul><h4 id="使用table"><a href="#使用table" class="headerlink" title="使用table"></a>使用table</h4><ul><li>原理: 通过将父元素改变为表格,将左右框转换为类似于同一行的td以达到多列布局,设置父元素宽度100%,给左框子元素一个固定宽度从而达到自适应.</li><li>用法: 将父元素设置为display:table;width:100%;再设置左右侧子元素display:table-cell;最后设置左侧子元素width:0.1%;padding-right:xx;以及左侧子元素中的内容宽度width:xxx;</li><li>示例:</li></ul><figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">'parent'</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">'left'</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是left内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">'right'</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是right内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>    <span class="hljs-attribute">display</span>: table;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span>,<br><span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">display</span>: table-cell;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0.1%</span>;<br>    <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">20px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span> <span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>注意: IE6/7不支持;</li></ul><h4 id="使用flex"><a href="#使用flex" class="headerlink" title="使用flex"></a>使用flex</h4><ul><li>原理: 通过设置CSS3中flex属性达到多列布局,加上给左侧子元素的内容定宽,给右侧子元素设置flex达到不定宽+自适应;</li><li>用法: 父元素设置display:flex;右侧子元素设置flex:1;左侧子元素margin-right:00px;内容设置宽度;</li><li>示例:</li></ul><figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">'parent'</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">'left'</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是left内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">'right'</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是right内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parnet</span> &#123;<br>  <span class="hljs-attribute">display</span>:flex;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">20px</span>;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span> <span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>优缺点: flex很强大,但是兼容性和性能都存在一些问题;</li></ul><h2 id="两列不定宽-一列自适应"><a href="#两列不定宽-一列自适应" class="headerlink" title="两列不定宽 + 一列自适应"></a>两列不定宽 + 一列自适应</h2><ul><li>原理: 类似于一列不定宽+一列自适应</li><li>用法: 左、中设置为float:left;margin-right:xxx;并设置内容宽度,右设置overflow:hidden;</li><li>示例:<figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"parent"</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"center"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>center<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.left</span>,<br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">20px</span>;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><span class="hljs-selector-class">.left</span> <span class="hljs-selector-tag">p</span>,<br><span class="hljs-selector-class">.center</span> <span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="等分布局"><a href="#等分布局" class="headerlink" title="等分布局"></a>等分布局</h2><ul><li>公式转化: </li><li>总宽度 = 子元素宽度 <em> n + 间隙宽度 </em> (n - 1)</li><li>总宽度 = 子元素宽度 <em> n + 间隙宽度 </em> n - 间隙宽度</li><li>总宽度 + 间隙宽度 =( 子元素宽度 + 间隙宽度 ) * n</li><li>两个问题: 如何让总宽度增加间隙宽度   如何让每个子元素宽度包含间隙宽度</li></ul><h4 id="使用float"><a href="#使用float" class="headerlink" title="使用float"></a>使用float</h4><ul><li>原理: 增大父元素的实际宽度,使用CSS3属性box-sizing进行辅助布局;</li><li>用法: 父元素margin-left:-<strong>px;子元素float:left;width:25%;padding-left:</strong>px;box-sizing:border-box;</li><li>示例:<figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"parent"</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"column"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"column"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"column"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"column"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>``` <br>```css<br>.parent &#123;<br>  margin-left: -20px;<br>&#125;<br>.column &#123;<br>  float:left;<br>  width: 25%;<br>  padding-left: 20px;<br>  box-sizing: border-box;<br>&#125;<br>```  <br>- 注意: IE6/7兼容性存在一些问题; <br><br>#### 使用table<br>- 原理: 通过增加一个父元素的修正框,增加其宽度,并将父元素转换为table,将子元素转换为table-cell进行布局;<br>- 用法: 父元素修正框设置为margin-left:-**px;父元素display:table;width:100%;table-layout:fixed;子元素display:table-cell;padding-left:**px;<br>- 示例;<br>```html<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"parent-fix"</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"parent"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"column"</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>111<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"column"</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>222<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"column"</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>333<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"column"</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>444<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent-fix</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">20px</span>;<br>&#125;<br><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">display</span>: table;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">table-layout</span>: fixed;<br>&#125;<br><span class="hljs-selector-class">.column</span> &#123;<br>  <span class="hljs-attribute">display</span>: table-cell;<br>  <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>优点: 结构和块数无关联;</li><li>缺点: 嵌套层数增加;</li></ul><h4 id="使用flex-1"><a href="#使用flex-1" class="headerlink" title="使用flex"></a>使用flex</h4><ul><li>原理: 通过设置CSS3中的flex属性达到等分布局;</li><li>用法: 父元素display:flex;子元素flex:1;并设置间距;</li><li>示例:<figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"parent"</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"column"</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>111<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"column"</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>222<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"column"</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>333<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"column"</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>444<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>&#125;<br><span class="hljs-selector-class">.column</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-selector-class">.column</span>+<span class="hljs-selector-class">.column</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>优点: 代码量少,与块数无关;</li><li>缺点: 低版本浏览器兼容性存在问题;</li></ul><h2 id="定宽-自适应-两块高度相同"><a href="#定宽-自适应-两块高度相同" class="headerlink" title="定宽 + 自适应 + 两块高度相同"></a>定宽 + 自适应 + 两块高度相同</h2><h4 id="使用float-1"><a href="#使用float-1" class="headerlink" title="使用float"></a>使用float</h4><ul><li>原理: 通过过分加大左右子框的高度，辅助超出隐藏，以达到视觉上的等高。</li><li>用法: 父元素overflow: hidden，左右子元素padding-bottom: 9999px、margin-bottom: -9999px，左子元素float: left、width、margin-right，右子元素overflow: hidden;</li><li>示例:<figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"parent"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>&#123;<br>    <span class="hljs-attribute">background</span>: none<span class="hljs-meta">!important</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span>,<span class="hljs-selector-class">.right</span>&#123;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-number">#444</span>;<br>&#125;<br><span class="hljs-selector-class">.parent</span>&#123;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><span class="hljs-selector-class">.left</span>,<span class="hljs-selector-class">.right</span>&#123;<br>    <span class="hljs-attribute">padding-bottom</span>: <span class="hljs-number">9999px</span>;<br>    <span class="hljs-attribute">margin-bottom</span>: -<span class="hljs-number">9999px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span>&#123;<br>    <br>    <span class="hljs-attribute">float</span>: left; <br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">20px</span>;<br>&#125;<br><span class="hljs-selector-class">.right</span>&#123;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>优点: 兼容性好;</li><li>缺点: 伪等高,不是真正意义上的等高;</li></ul><h4 id="使用table-1"><a href="#使用table-1" class="headerlink" title="使用table"></a>使用table</h4><ul><li>原理：将父框转化为tabel，将子框转化为tabel-cell布局，以达到定宽+自适应+两块高度一样高。</li><li>用法：父元素display:table、width:100%、table-layout:fixed，左右子元素display:table-cell，左子元素width、padding-right。</li><li>示例:<figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"parent"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span>.right<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">display</span>: table;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">table-layout</span>: fixed;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">20px</span>;<br>&#125;<br><span class="hljs-selector-class">.right</span>,<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">display</span>: table-cell;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用flex-2"><a href="#使用flex-2" class="headerlink" title="使用flex"></a>使用flex</h4><ul><li>原理: 通过设置CSS3布局利器flex中的flex属性以达到定宽+自适应+两块高度一样高。</li><li>用法：父元素display: flex，左子元素width、margin-right;右子元素flex:1。</li><li>示例:<figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"parent"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">20px</span>;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>优缺点: 代码量少,简洁,但是兼容性存在一些问题;</li></ul><h4 id="使用display"><a href="#使用display" class="headerlink" title="使用display"></a>使用display</h4><ul><li>原理: 通过设置display中的CSS3的-webkit-box属性以达到定宽+自适应+两块高度一样高。</li><li>用法: 父元素display: -webkit-box、width:100%，左子元素width、margin-right，右子元素-webkit-box-flex: 1;</li><li>示例:<figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"parent"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">display</span>: -webkit-box;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">20px</span>;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">-webkit-box-flex</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>缺点: 兼容性存在较大问题;</li></ul><h2 id="全屏布局"><a href="#全屏布局" class="headerlink" title="全屏布局"></a>全屏布局</h2><h4 id="全屏布局的特点"><a href="#全屏布局的特点" class="headerlink" title="全屏布局的特点:"></a>全屏布局的特点:</h4><ul><li>滚动条不是全局滚动条,而是出现在内容区域里,一般是主内容区域;</li><li>浏览器变大时,撑满窗口;</li></ul><h3 id="全屏布局的方法"><a href="#全屏布局的方法" class="headerlink" title="全屏布局的方法"></a>全屏布局的方法</h3><h4 id="使用position"><a href="#使用position" class="headerlink" title="使用position"></a>使用position</h4><ul><li>原理: 将上下部分固定,中间部分使用定宽+自适应+等高;</li><li>用法: 见示例;</li><li>示例:<figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"parent"</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"top"</span>&gt;</span>top<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"inner"</span>&gt;</span>right-inner<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"bottom"</span>&gt;</span>bottom<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span>,<br><span class="hljs-selector-tag">body</span>,<br><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">color</span>: white;<br>&#125;<br><span class="hljs-selector-class">.top</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">background-color</span>: blue;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>  <span class="hljs-attribute">overflow</span>: auto;<br>&#125;<br><span class="hljs-selector-class">.right</span> <span class="hljs-selector-class">.inner</span> &#123;<br>  <span class="hljs-attribute">min-height</span>: <span class="hljs-number">1000px</span>;<br>&#125;<br><span class="hljs-selector-class">.bottom</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">background-color</span>: black;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>优缺点: 兼容性好,IE6以下不支持;</li></ul><h4 id="使用flex-3"><a href="#使用flex-3" class="headerlink" title="使用flex"></a>使用flex</h4><ul><li>原理: 通过CSS3中flex属性和flex-direction属性;</li><li>用法: 见示例;</li><li>示例: <figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"parent"</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"top"</span>&gt;</span>top<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"middle"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"inner"</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"bottom"</span>&gt;</span>bottom<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span>,<br><span class="hljs-selector-tag">body</span>,<br><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">color</span>: white;<br>&#125;<br><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">flex-direction</span>: column;<br>&#125;<br><span class="hljs-selector-class">.top</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: blue;<br>&#125;<br><span class="hljs-selector-class">.bottom</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">background-color</span>: black;<br>&#125;<br><span class="hljs-selector-class">.middle</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">display</span>: flex;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">overflow</span>: auto;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>&#125;<br><span class="hljs-selector-class">.right</span> <span class="hljs-selector-class">.inner</span> &#123;<br>  <span class="hljs-attribute">min-height</span>: <span class="hljs-number">1000px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>优缺点: 兼容性差,IE9及以下不兼容;</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端布局 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS布局之水平居中和垂直居中</title>
      <link href="/2018/02/11/CSSlayout-01/"/>
      <url>/2018/02/11/CSSlayout-01/</url>
      
        <content type="html"><![CDATA[<ul><li>前端布局非常重要的一环就是页面框架的搭建，也是最基础的一环。在页面框架搭建之中，又有居中布局/多列布局/全局布局。今天介绍一下居中布局的一些技巧。</li></ul><h1 id="居中布局"><a href="#居中布局" class="headerlink" title="居中布局"></a>居中布局</h1><h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><h4 id="1-使用inline-block-text-align："><a href="#1-使用inline-block-text-align：" class="headerlink" title="1.使用inline-block + text-align："></a>1.使用inline-block + text-align：</h4><ul><li>原理：先将子框由块级元素改变为行内块元素，再通过设置行内块元素居中以达到水平居中的目的。#####</li><li>用法：对子框设置display:inline-block,对父框设置text-align:center。</li><li>示例：</li></ul><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">`&lt;div class=&apos;parent&apos;&gt;<br>&lt;div class=&apos;child&apos;&gt;DEMO&lt;/div&gt;<br>&lt;/div&gt;<br>.child &#123;<br>display: inline-block;<br>&#125;<br>.parent &#123;<br>text-align: center;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>优点:兼容性好。</li><li>缺点:.child里的文字也会水平居中。(可以在.child里添加text-align:left还原)</li></ul><h4 id="2-使用table-margin"><a href="#2-使用table-margin" class="headerlink" title="2.使用table + margin"></a>2.使用table + margin</h4><ul><li>原理:先将子框设置为块级表格来显示,再设置子框居中以达到居中水平.</li><li>用法:对子框设置display:table,再设置margin:0 auto;</li><li>示例:</li></ul><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">`&lt;div class=&apos;parent&apos;&gt;<br>&lt;div class=&apos;child&apos;&gt;DEMO&lt;/div&gt;<br>&lt;/div&gt;<br>.child &#123;<br>display: table;<br>margin: 0 auto;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>优点:只设置了child,IE8以上都支持;</li><li>缺点:不支持IE6/IE7,将div换成了table;</li></ul><h4 id="3-使用absolute-transform"><a href="#3-使用absolute-transform" class="headerlink" title="3.使用absolute + transform"></a>3.使用absolute + transform</h4><ul><li>原理:将子框设置为绝对定位,移动子框,使子框左侧距离相对框左侧边框的距离为相对框宽度的一半,再通过向左移动子框的一半宽度以达到水平居中。父框需要设置为相对定位(或者绝对定位),使父框成为子框的相对框。</li><li>用法:对父框设置position:relative(absolute);对子框设置position:absolute;left:50%;transform:translateX(-50%);</li><li>示例:</li></ul><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">`&lt;div class=&apos;parent&apos;&gt;<br>&lt;div class=&apos;child&apos;&gt;DEMO&lt;/div&gt;<br>&lt;/div&gt;<br>.parent &#123;<br>position: relative;<br>&#125;<br>.child &#123;<br>position: absolute;<br>left: 50%;<br>transform: translateX(-50%);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>优点:居中元素不会对其它元素产生影响;</li><li>缺点:transform属于CSS3内容,兼容性存在一定问题;</li></ul><h4 id="4-使用flex-margin"><a href="#4-使用flex-margin" class="headerlink" title="4.使用flex + margin"></a>4.使用flex + margin</h4><ul><li>原理:通过CSS3中的布局利器flex将子框转换为flex item,再设置子框居中以达到居中目的。</li><li>用法:先将父框设置为display:flex;再设置子框margin:0 auto;</li><li>示例:</li></ul><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">`&lt;div class=&apos;parent&apos;&gt;<br>&lt;div class=&apos;child&apos;&gt;DEMO&lt;/div&gt;<br>&lt;/div&gt;<br>.parent &#123;<br>display:flex;<br>&#125;<br>.child &#123;<br>margin:0 auto;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>缺点:IE6/7/8等低版本浏览器不支持;</li></ul><h4 id="5-使用flex-justify-content"><a href="#5-使用flex-justify-content" class="headerlink" title="5.使用flex + justify-content"></a>5.使用flex + justify-content</h4><ul><li>原理:通过CSS3中的布局利器flex中的justify-content属性来达到居中目的;</li><li>用法:先将父框设置为display:flex;再设置justify-content:center;</li><li>示例:</li></ul><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">`&lt;div class=&apos;parent&apos;&gt;<br>&lt;div class=&apos;child&apos;&gt;DEMO&lt;/div&gt;<br>&lt;/div&gt;<br>.parent &#123;<br>display:flex;<br>justify-content: center;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>优点:只设置parent即可;</li><li>缺点:IE6/7/8等低版本浏览器不支持;</li></ul><h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><h4 id="1-使用table-cell-vertical-align"><a href="#1-使用table-cell-vertical-align" class="headerlink" title="1.使用table-cell + vertical-align"></a>1.使用table-cell + vertical-align</h4><ul><li>原理:通过将父框转化为一个表格单元格显示,在通过设置属性,使表格单元格内容垂直居中;</li><li>用法:先将父框设置为display:table-cell;再设置vertical-align:middle;</li><li>实例:</li></ul><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">`&lt;div class=&apos;parent&apos;&gt;<br>&lt;div class=&apos;child&apos;&gt;DEMO&lt;/div&gt;<br>&lt;/div&gt;<br>.parent &#123;<br>display:table-cell;<br>vertical-align: middle;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>优点: 兼容性较好,IE8以上都支持;</li><li>缺点: 将div元素转化为了table元素;</li></ul><h4 id="2-使用absolute-transform"><a href="#2-使用absolute-transform" class="headerlink" title="2.使用absolute + transform"></a>2.使用absolute + transform</h4><ul><li>原理:类似于上面说过的水平居中的原理，将子框设置为绝对定位，移动子框，使子框上边距离相对框上边边框的距离为相对框高度的一半，再通过向上移动子框的高度的一半以达到垂直居中;父框需设置为相对定位或者绝对定位，使其成为子框的相对框；</li><li>用法:先将父框设置为position:relative(absolute);再设置子框position:absolute;top:50%;transform:translateY(-50%);</li><li>实例:</li></ul><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">`&lt;div class=&apos;parent&apos;&gt;<br>&lt;div class=&apos;child&apos;&gt;DEMO&lt;/div&gt;<br>&lt;/div&gt;<br>.parent &#123;<br>position:relative;<br>&#125;<br>.child &#123;<br>position: absolute;<br>top: 50%;<br>transform: translateY(-50%);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>优点: 居中元素不会对其它元素产生影响;</li><li>缺点: transform属于CSS3内容,兼容性存在一定问题;</li></ul><h4 id="３-使用flex-align-items"><a href="#３-使用flex-align-items" class="headerlink" title="３.使用flex + align-items"></a>３.使用flex + align-items</h4><ul><li>原理:通过CSS3中的布局利器flex中的align-items属性来达到居中目的;</li><li>用法:先将父框设置为display:flex;再设置align-items:center;</li><li>示例:</li></ul><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">`&lt;div class=&apos;parent&apos;&gt;<br>&lt;div class=&apos;child&apos;&gt;DEMO&lt;/div&gt;<br>&lt;/div&gt;<br>.parent &#123;<br>display:flex;<br>align-items: center;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>优点:只设置parent即可;</li><li>缺点:IE6/7/8等低版本浏览器不支持;</li></ul><h2 id="水平-垂直-居中"><a href="#水平-垂直-居中" class="headerlink" title="水平 + 垂直　居中"></a>水平 + 垂直　居中</h2><p>####　1.使用absolute + transform</p><ul><li>原理:将水平居中和垂直居中相结合;</li><li>用法:先将父框设置为position:relative(absolute);再设置子框position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);</li><li>实例:</li></ul><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">`&lt;div class=&apos;parent&apos;&gt;<br>&lt;div class=&apos;child&apos;&gt;DEMO&lt;/div&gt;<br>&lt;/div&gt;<br>.parent &#123;<br>position:relative;<br>&#125;<br>.child &#123;<br>position: absolute;<br>left: 50%;<br>top: 50%;<br>transform: translate(-50%,-50%);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>优点: 居中元素不会对其它元素产生影响;</li><li>缺点: transform属于CSS3内容,兼容性存在一定问题;</li></ul><h4 id="2-使用inline-block-text-align-table-cell-vertical-align"><a href="#2-使用inline-block-text-align-table-cell-vertical-align" class="headerlink" title="2.使用inline-block + text-align + table-cell + vertical-align"></a>2.使用inline-block + text-align + table-cell + vertical-align</h4><ul><li>原理:使用inline-block+text-align水平居中;再用table-cell+vertical-align垂直居中;将二者结合起来;</li><li>实例:</li></ul><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">`&lt;div class=&apos;parent&apos;&gt;<br>&lt;div class=&apos;child&apos;&gt;DEMO&lt;/div&gt;<br>&lt;/div&gt;<br>.parent &#123;<br>text-align:center;<br>display:table-cell;<br>vertical-align:middle;<br>&#125;<br>.child &#123;<br>display: inline-block;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>优点: 兼容性较好;</li><li>缺点: 使用起来比较麻烦;</li></ul><h4 id="2-使用flex-justify-content-align-items"><a href="#2-使用flex-justify-content-align-items" class="headerlink" title="2.使用flex + justify-content + align-items"></a>2.使用flex + justify-content + align-items</h4><ul><li>原理:通过设置flex中的justify-content和align-items,从而达到水平垂直居中;</li><li>实例:</li></ul><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">`&lt;div class=&apos;parent&apos;&gt;<br>&lt;div class=&apos;child&apos;&gt;DEMO&lt;/div&gt;<br>&lt;/div&gt;<br>.parent &#123;<br>display:flex;<br>justify-content:center;<br>align-items:center;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>优点: 只设置parent元素;</li><li>缺点: 兼容性存在一些问题;</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端布局 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
